<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LogAxis.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jfreechart$JaCoCo.exec</a> &gt; <a href="index.source.html" class="el_package">org.jfree.chart.axis</a> &gt; <span class="el_source">LogAxis.java</span></div><h1>LogAxis.java</h1><pre class="source lang-java linenums">/* ===========================================================
 * JFreeChart : a free chart library for the Java(tm) platform
 * ===========================================================
 *
 * (C) Copyright 2000-2013, by Object Refinery Limited and Contributors.
 *
 * Project Info:  http://www.jfree.org/jfreechart/index.html
 *
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2.1 of the License, or
 * (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
 * USA.
 *
 * [Oracle and Java are registered trademarks of Oracle and/or its affiliates. 
 * Other names may be trademarks of their respective owners.]
 *
 * ------------
 * LogAxis.java
 * ------------
 * (C) Copyright 2006-2013, by Object Refinery Limited and Contributors.
 *
 * Original Author:  David Gilbert (for Object Refinery Limited);
 * Contributor(s):   Andrew Mickish (patch 1868745);
 *                   Peter Kolb (patches 1934255 and 2603321);
 *
 * Changes
 * -------
 * 24-Aug-2006 : Version 1 (DG);
 * 22-Mar-2007 : Use defaultAutoArrange attribute (DG);
 * 02-Aug-2007 : Fixed zooming bug, added support for margins (DG);
 * 14-Feb-2008 : Changed default minorTickCount to 9 - see bug report
 *               1892419 (DG);
 * 15-Feb-2008 : Applied a variation of patch 1868745 by Andrew Mickish to
 *               fix a labelling bug when the axis appears at the top or
 *               right of the chart (DG);
 * 19-Mar-2008 : Applied patch 1902418 by Andrew Mickish to fix bug in tick
 *               labels for vertical axis (DG);
 * 26-Mar-2008 : Changed createTickLabel() method from private to protected -
 *               see patch 1918209 by Andrew Mickish (DG);
 * 25-Sep-2008 : Moved minor tick fields up to superclass, see patch 1934255
 *               by Peter Kolb (DG);
 * 14-Jan-2009 : Fetch minor ticks from TickUnit, and corrected
 *               createLogTickUnits() (DG);
 * 21-Jan-2009 : No need to call setMinorTickCount() in constructor (DG);
 * 19-Mar-2009 : Added entity support - see patch 2603321 by Peter Kolb (DG);
 * 30-Mar-2009 : Added pan(double) method (DG);
 * 28-Oct-2011 : Fixed endless loop for 0 TickUnit, # 3429707 (MH);
 * 02-Jul-2013 : Use ParamChecks (DG);
 * 01-Aug-2013 : Added attributedLabel override to support superscripts,
 *               subscripts and more (DG); */

package org.jfree.chart.axis;

import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.font.FontRenderContext;
import java.awt.font.LineMetrics;
import java.awt.geom.Rectangle2D;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

import org.jfree.chart.event.AxisChangeEvent;
import org.jfree.chart.plot.Plot;
import org.jfree.chart.plot.PlotRenderingInfo;
import org.jfree.chart.plot.ValueAxisPlot;
import org.jfree.chart.util.LogFormat;
import org.jfree.chart.util.ParamChecks;
import org.jfree.data.Range;
import org.jfree.ui.RectangleEdge;
import org.jfree.ui.RectangleInsets;
import org.jfree.ui.TextAnchor;

/**
 * A numerical axis that uses a logarithmic scale.  The class is an
 * alternative to the {@link LogarithmicAxis} class.
 *
 * @since 1.0.7
 */
public class LogAxis extends ValueAxis {

    /** The logarithm base. */
<span class="fc" id="L96">    private double base = 10.0;</span>

    /** The logarithm of the base value - cached for performance. */
<span class="fc" id="L99">    private double baseLog = Math.log(10.0);</span>

    /**  The smallest value permitted on the axis. */
<span class="fc" id="L102">    private double smallestValue = 1E-100;</span>

    /** The current tick unit. */
    private NumberTickUnit tickUnit;

    /** The override number format. */
    private NumberFormat numberFormatOverride;

    /**
     * Creates a new &lt;code&gt;LogAxis&lt;/code&gt; with no label.
     */
    public LogAxis() {
<span class="fc" id="L114">        this(null);</span>
<span class="fc" id="L115">    }</span>

    /**
     * Creates a new &lt;code&gt;LogAxis&lt;/code&gt; with the given label.
     *
     * @param label  the axis label (&lt;code&gt;null&lt;/code&gt; permitted).
     */
    public LogAxis(String label) {
<span class="fc" id="L123">        super(label, createLogTickUnits(Locale.getDefault()));</span>
<span class="fc" id="L124">        setDefaultAutoRange(new Range(0.01, 1.0));</span>
<span class="fc" id="L125">        this.tickUnit = new NumberTickUnit(1.0, new DecimalFormat(&quot;0.#&quot;), 9);</span>
<span class="fc" id="L126">    }</span>

    /**
     * Returns the base for the logarithm calculation.
     *
     * @return The base for the logarithm calculation.
     *
     * @see #setBase(double)
     */
    public double getBase() {
<span class="nc" id="L136">        return this.base;</span>
    }

    /**
     * Sets the base for the logarithm calculation and sends an
     * {@link AxisChangeEvent} to all registered listeners.
     *
     * @param base  the base value (must be &gt; 1.0).
     *
     * @see #getBase()
     */
    public void setBase(double base) {
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">        if (base &lt;= 1.0) {</span>
<span class="nc" id="L149">            throw new IllegalArgumentException(&quot;Requires 'base' &gt; 1.0.&quot;);</span>
        }
<span class="fc" id="L151">        this.base = base;</span>
<span class="fc" id="L152">        this.baseLog = Math.log(base);</span>
<span class="fc" id="L153">        fireChangeEvent();</span>
<span class="fc" id="L154">    }</span>

    /**
     * Returns the smallest value represented by the axis.
     *
     * @return The smallest value represented by the axis.
     *
     * @see #setSmallestValue(double)
     */
    public double getSmallestValue() {
<span class="nc" id="L164">        return this.smallestValue;</span>
    }

    /**
     * Sets the smallest value represented by the axis and sends an
     * {@link AxisChangeEvent} to all registered listeners.
     *
     * @param value  the value.
     *
     * @see #getSmallestValue()
     */
    public void setSmallestValue(double value) {
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">        if (value &lt;= 0.0) {</span>
<span class="nc" id="L177">            throw new IllegalArgumentException(&quot;Requires 'value' &gt; 0.0.&quot;);</span>
        }
<span class="fc" id="L179">        this.smallestValue = value;</span>
<span class="fc" id="L180">        fireChangeEvent();</span>
<span class="fc" id="L181">    }</span>

    /**
     * Returns the current tick unit.
     *
     * @return The current tick unit.
     *
     * @see #setTickUnit(NumberTickUnit)
     */
    public NumberTickUnit getTickUnit() {
<span class="fc" id="L191">        return this.tickUnit;</span>
    }

    /**
     * Sets the tick unit for the axis and sends an {@link AxisChangeEvent} to
     * all registered listeners.  A side effect of calling this method is that
     * the &quot;auto-select&quot; feature for tick units is switched off (you can
     * restore it using the {@link ValueAxis#setAutoTickUnitSelection(boolean)}
     * method).
     *
     * @param unit  the new tick unit (&lt;code&gt;null&lt;/code&gt; not permitted).
     *
     * @see #getTickUnit()
     */
    public void setTickUnit(NumberTickUnit unit) {
        // defer argument checking...
<span class="nc" id="L207">        setTickUnit(unit, true, true);</span>
<span class="nc" id="L208">    }</span>

    /**
     * Sets the tick unit for the axis and, if requested, sends an
     * {@link AxisChangeEvent} to all registered listeners.  In addition, an
     * option is provided to turn off the &quot;auto-select&quot; feature for tick units
     * (you can restore it using the
     * {@link ValueAxis#setAutoTickUnitSelection(boolean)} method).
     *
     * @param unit  the new tick unit (&lt;code&gt;null&lt;/code&gt; not permitted).
     * @param notify  notify listeners?
     * @param turnOffAutoSelect  turn off the auto-tick selection?
     *
     * @see #getTickUnit()
     */
    public void setTickUnit(NumberTickUnit unit, boolean notify,
            boolean turnOffAutoSelect) {

<span class="fc" id="L226">        ParamChecks.nullNotPermitted(unit, &quot;unit&quot;);</span>
<span class="fc" id="L227">        this.tickUnit = unit;</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">        if (turnOffAutoSelect) {</span>
<span class="nc" id="L229">            setAutoTickUnitSelection(false, false);</span>
        }
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">        if (notify) {</span>
<span class="nc" id="L232">            fireChangeEvent();</span>
        }

<span class="fc" id="L235">    }</span>

    /**
     * Returns the number format override.  If this is non-null, then it will
     * be used to format the numbers on the axis.
     *
     * @return The number formatter (possibly &lt;code&gt;null&lt;/code&gt;).
     *
     * @see #setNumberFormatOverride(NumberFormat)
     */
    public NumberFormat getNumberFormatOverride() {
<span class="fc" id="L246">        return this.numberFormatOverride;</span>
    }

    /**
     * Sets the number format override.  If this is non-null, then it will be
     * used to format the numbers on the axis.
     *
     * @param formatter  the number formatter (&lt;code&gt;null&lt;/code&gt; permitted).
     *
     * @see #getNumberFormatOverride()
     */
    public void setNumberFormatOverride(NumberFormat formatter) {
<span class="nc" id="L258">        this.numberFormatOverride = formatter;</span>
<span class="nc" id="L259">        fireChangeEvent();</span>
<span class="nc" id="L260">    }</span>

    /**
     * Calculates the log of the given value, using the current base.
     *
     * @param value  the value.
     *
     * @return The log of the given value.
     *
     * @see #calculateValue(double)
     * @see #getBase()
     */
    public double calculateLog(double value) {
<span class="fc" id="L273">        return Math.log(value) / this.baseLog;</span>
    }

    /**
     * Calculates the value from a given log.
     *
     * @param log  the log value (must be &gt; 0.0).
     *
     * @return The value with the given log.
     *
     * @see #calculateLog(double)
     * @see #getBase()
     */
    public double calculateValue(double log) {
<span class="fc" id="L287">        return Math.pow(this.base, log);</span>
    }

    /**
     * Converts a Java2D coordinate to an axis value, assuming that the
     * axis covers the specified &lt;code&gt;edge&lt;/code&gt; of the &lt;code&gt;area&lt;/code&gt;.
     *
     * @param java2DValue  the Java2D coordinate.
     * @param area  the area.
     * @param edge  the edge that the axis belongs to.
     *
     * @return A value along the axis scale.
     */
    public double java2DToValue(double java2DValue, Rectangle2D area,
            RectangleEdge edge) {

<span class="fc" id="L303">        Range range = getRange();</span>
<span class="fc" id="L304">        double axisMin = calculateLog(range.getLowerBound());</span>
<span class="fc" id="L305">        double axisMax = calculateLog(range.getUpperBound());</span>

<span class="fc" id="L307">        double min = 0.0;</span>
<span class="fc" id="L308">        double max = 0.0;</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">        if (RectangleEdge.isTopOrBottom(edge)) {</span>
<span class="fc" id="L310">            min = area.getX();</span>
<span class="fc" id="L311">            max = area.getMaxX();</span>
        }
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">        else if (RectangleEdge.isLeftOrRight(edge)) {</span>
<span class="fc" id="L314">            min = area.getMaxY();</span>
<span class="fc" id="L315">            max = area.getY();</span>
        }
<span class="fc" id="L317">        double log = 0.0;</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">        if (isInverted()) {</span>
<span class="fc" id="L319">            log = axisMax - (java2DValue - min) / (max - min)</span>
                    * (axisMax - axisMin);
        }
        else {
<span class="fc" id="L323">            log = axisMin + (java2DValue - min) / (max - min)</span>
                    * (axisMax - axisMin);
        }
<span class="fc" id="L326">        return calculateValue(log);</span>
    }

    /**
     * Converts a value on the axis scale to a Java2D coordinate relative to
     * the given &lt;code&gt;area&lt;/code&gt;, based on the axis running along the
     * specified &lt;code&gt;edge&lt;/code&gt;.
     *
     * @param value  the data value.
     * @param area  the area.
     * @param edge  the edge.
     *
     * @return The Java2D coordinate corresponding to &lt;code&gt;value&lt;/code&gt;.
     */
    public double valueToJava2D(double value, Rectangle2D area,
            RectangleEdge edge) {

<span class="fc" id="L343">        Range range = getRange();</span>
<span class="fc" id="L344">        double axisMin = calculateLog(range.getLowerBound());</span>
<span class="fc" id="L345">        double axisMax = calculateLog(range.getUpperBound());</span>
<span class="fc" id="L346">        value = calculateLog(value);</span>

<span class="fc" id="L348">        double min = 0.0;</span>
<span class="fc" id="L349">        double max = 0.0;</span>
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">        if (RectangleEdge.isTopOrBottom(edge)) {</span>
<span class="fc" id="L351">            min = area.getX();</span>
<span class="fc" id="L352">            max = area.getMaxX();</span>
        }
<span class="nc bnc" id="L354" title="All 2 branches missed.">        else if (RectangleEdge.isLeftOrRight(edge)) {</span>
<span class="nc" id="L355">            max = area.getMinY();</span>
<span class="nc" id="L356">            min = area.getMaxY();</span>
        }
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">        if (isInverted()) {</span>
<span class="nc" id="L359">            return max</span>
                   - ((value - axisMin) / (axisMax - axisMin)) * (max - min);
        }
        else {
<span class="fc" id="L363">            return min</span>
                   + ((value - axisMin) / (axisMax - axisMin)) * (max - min);
        }
    }

    /**
     * Configures the axis.  This method is typically called when an axis
     * is assigned to a new plot.
     */
    public void configure() {
<span class="fc bfc" id="L373" title="All 2 branches covered.">        if (isAutoRange()) {</span>
<span class="fc" id="L374">            autoAdjustRange();</span>
        }
<span class="fc" id="L376">    }</span>

    /**
     * Adjusts the axis range to match the data range that the axis is
     * required to display.
     */
    protected void autoAdjustRange() {
<span class="fc" id="L383">        Plot plot = getPlot();</span>
<span class="pc bpc" id="L384" title="1 of 2 branches missed.">        if (plot == null) {</span>
<span class="nc" id="L385">            return;  // no plot, no data</span>
        }

<span class="pc bpc" id="L388" title="1 of 2 branches missed.">        if (plot instanceof ValueAxisPlot) {</span>
<span class="fc" id="L389">            ValueAxisPlot vap = (ValueAxisPlot) plot;</span>

<span class="fc" id="L391">            Range r = vap.getDataRange(this);</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">            if (r == null) {</span>
<span class="fc" id="L393">                r = getDefaultAutoRange();</span>
            }

<span class="fc" id="L396">            double upper = r.getUpperBound();</span>
<span class="fc" id="L397">            double lower = Math.max(r.getLowerBound(), this.smallestValue);</span>
<span class="fc" id="L398">            double range = upper - lower;</span>

            // if fixed auto range, then derive lower bound...
<span class="fc" id="L401">            double fixedAutoRange = getFixedAutoRange();</span>
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">            if (fixedAutoRange &gt; 0.0) {</span>
<span class="nc" id="L403">                lower = Math.max(upper - fixedAutoRange, this.smallestValue);</span>
            }
            else {
                // ensure the autorange is at least &lt;minRange&gt; in size...
<span class="fc" id="L407">                double minRange = getAutoRangeMinimumSize();</span>
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">                if (range &lt; minRange) {</span>
<span class="nc" id="L409">                    double expand = (minRange - range) / 2;</span>
<span class="nc" id="L410">                    upper = upper + expand;</span>
<span class="nc" id="L411">                    lower = lower - expand;</span>
                }

                // apply the margins - these should apply to the exponent range
<span class="fc" id="L415">                double logUpper = calculateLog(upper);</span>
<span class="fc" id="L416">                double logLower = calculateLog(lower);</span>
<span class="fc" id="L417">                double logRange = logUpper - logLower;</span>
<span class="fc" id="L418">                logUpper = logUpper + getUpperMargin() * logRange;</span>
<span class="fc" id="L419">                logLower = logLower - getLowerMargin() * logRange;</span>
<span class="fc" id="L420">                upper = calculateValue(logUpper);</span>
<span class="fc" id="L421">                lower = calculateValue(logLower);</span>
            }

<span class="fc" id="L424">            setRange(new Range(lower, upper), false, false);</span>
        }

<span class="fc" id="L427">    }</span>

    /**
     * Draws the axis on a Java 2D graphics device (such as the screen or a
     * printer).
     *
     * @param g2  the graphics device (&lt;code&gt;null&lt;/code&gt; not permitted).
     * @param cursor  the cursor location (determines where to draw the axis).
     * @param plotArea  the area within which the axes and plot should be drawn.
     * @param dataArea  the area within which the data should be drawn.
     * @param edge  the axis location (&lt;code&gt;null&lt;/code&gt; not permitted).
     * @param plotState  collects information about the plot
     *                   (&lt;code&gt;null&lt;/code&gt; permitted).
     *
     * @return The axis state (never &lt;code&gt;null&lt;/code&gt;).
     */
    public AxisState draw(Graphics2D g2, double cursor, Rectangle2D plotArea,
            Rectangle2D dataArea, RectangleEdge edge,
            PlotRenderingInfo plotState) {

        AxisState state;
        // if the axis is not visible, don't draw it...
<span class="nc bnc" id="L449" title="All 2 branches missed.">        if (!isVisible()) {</span>
<span class="nc" id="L450">            state = new AxisState(cursor);</span>
            // even though the axis is not visible, we need ticks for the
            // gridlines...
<span class="nc" id="L453">            List ticks = refreshTicks(g2, state, dataArea, edge);</span>
<span class="nc" id="L454">            state.setTicks(ticks);</span>
<span class="nc" id="L455">            return state;</span>
        }
<span class="nc" id="L457">        state = drawTickMarksAndLabels(g2, cursor, plotArea, dataArea, edge);</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">        if (getAttributedLabel() != null) {</span>
<span class="nc" id="L459">            state = drawAttributedLabel(getAttributedLabel(), g2, plotArea, </span>
                    dataArea, edge, state);
            
        } else {
<span class="nc" id="L463">            state = drawLabel(getLabel(), g2, plotArea, dataArea, edge, state);</span>
        }
<span class="nc" id="L465">        createAndAddEntity(cursor, state, dataArea, edge, plotState);</span>
<span class="nc" id="L466">        return state;</span>
    }

    /**
     * Calculates the positions of the tick labels for the axis, storing the
     * results in the tick label list (ready for drawing).
     *
     * @param g2  the graphics device.
     * @param state  the axis state.
     * @param dataArea  the area in which the plot should be drawn.
     * @param edge  the location of the axis.
     *
     * @return A list of ticks.
     *
     */
    public List refreshTicks(Graphics2D g2, AxisState state,
            Rectangle2D dataArea, RectangleEdge edge) {
<span class="fc" id="L483">        List result = new java.util.ArrayList();</span>
<span class="pc bpc" id="L484" title="1 of 2 branches missed.">        if (RectangleEdge.isTopOrBottom(edge)) {</span>
<span class="fc" id="L485">            result = refreshTicksHorizontal(g2, dataArea, edge);</span>
        }
<span class="nc bnc" id="L487" title="All 2 branches missed.">        else if (RectangleEdge.isLeftOrRight(edge)) {</span>
<span class="nc" id="L488">            result = refreshTicksVertical(g2, dataArea, edge);</span>
        }
<span class="fc" id="L490">        return result;</span>
    }

    /**
     * Returns a list of ticks for an axis at the top or bottom of the chart.
     *
     * @param g2  the graphics device.
     * @param dataArea  the data area.
     * @param edge  the edge.
     *
     * @return A list of ticks.
     */
    protected List refreshTicksHorizontal(Graphics2D g2, Rectangle2D dataArea,
            RectangleEdge edge) {

<span class="fc" id="L505">        Range range = getRange();</span>
<span class="fc" id="L506">        List ticks = new ArrayList();</span>
<span class="fc" id="L507">        Font tickLabelFont = getTickLabelFont();</span>
<span class="fc" id="L508">        g2.setFont(tickLabelFont);</span>
        TextAnchor textAnchor;
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">        if (edge == RectangleEdge.TOP) {</span>
<span class="fc" id="L511">            textAnchor = TextAnchor.BOTTOM_CENTER;</span>
        }
        else {
<span class="nc" id="L514">            textAnchor = TextAnchor.TOP_CENTER;</span>
        }

<span class="pc bpc" id="L517" title="1 of 2 branches missed.">        if (isAutoTickUnitSelection()) {</span>
<span class="fc" id="L518">            selectAutoTickUnit(g2, dataArea, edge);</span>
        }
<span class="fc" id="L520">        int minorTickCount = this.tickUnit.getMinorTickCount();</span>
<span class="fc" id="L521">        double start = Math.floor(calculateLog(getLowerBound()));</span>
<span class="fc" id="L522">        double end = Math.ceil(calculateLog(getUpperBound()));</span>
<span class="fc" id="L523">        double current = start;</span>
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">        boolean hasTicks = (this.tickUnit.getSize() &gt; 0.0)</span>
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">                           &amp;&amp; !Double.isInfinite(start);</span>
<span class="pc bpc" id="L526" title="3 of 4 branches missed.">        while (hasTicks &amp;&amp; current &lt;= end) {</span>
<span class="nc" id="L527">            double v = calculateValue(current);</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">            if (range.contains(v)) {</span>
<span class="nc" id="L529">                ticks.add(new NumberTick(TickType.MAJOR, v, createTickLabel(v),</span>
                        textAnchor, TextAnchor.CENTER, 0.0));
            }
            // add minor ticks (for gridlines)
<span class="nc" id="L533">            double next = Math.pow(this.base, current</span>
<span class="nc" id="L534">                    + this.tickUnit.getSize());</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">            for (int i = 1; i &lt; minorTickCount; i++) {</span>
<span class="nc" id="L536">                double minorV = v + i * ((next - v) / minorTickCount);</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">                if (range.contains(minorV)) {</span>
<span class="nc" id="L538">                    ticks.add(new NumberTick(TickType.MINOR, minorV, &quot;&quot;,</span>
                            textAnchor, TextAnchor.CENTER, 0.0));
                }
            }
<span class="nc" id="L542">            current = current + this.tickUnit.getSize();</span>
<span class="nc" id="L543">        }</span>
<span class="fc" id="L544">        return ticks;</span>
    }

    /**
     * Returns a list of ticks for an axis at the left or right of the chart.
     *
     * @param g2  the graphics device.
     * @param dataArea  the data area.
     * @param edge  the edge.
     *
     * @return A list of ticks.
     */
    protected List refreshTicksVertical(Graphics2D g2, Rectangle2D dataArea,
            RectangleEdge edge) {

<span class="nc" id="L559">        Range range = getRange();</span>
<span class="nc" id="L560">        List ticks = new ArrayList();</span>
<span class="nc" id="L561">        Font tickLabelFont = getTickLabelFont();</span>
<span class="nc" id="L562">        g2.setFont(tickLabelFont);</span>
        TextAnchor textAnchor;
<span class="nc bnc" id="L564" title="All 2 branches missed.">        if (edge == RectangleEdge.RIGHT) {</span>
<span class="nc" id="L565">            textAnchor = TextAnchor.CENTER_LEFT;</span>
        }
        else {
<span class="nc" id="L568">            textAnchor = TextAnchor.CENTER_RIGHT;</span>
        }

<span class="nc bnc" id="L571" title="All 2 branches missed.">        if (isAutoTickUnitSelection()) {</span>
<span class="nc" id="L572">            selectAutoTickUnit(g2, dataArea, edge);</span>
        }
<span class="nc" id="L574">        int minorTickCount = this.tickUnit.getMinorTickCount();</span>
<span class="nc" id="L575">        double start = Math.floor(calculateLog(getLowerBound()));</span>
<span class="nc" id="L576">        double end = Math.ceil(calculateLog(getUpperBound()));</span>
<span class="nc" id="L577">        double current = start;</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">        boolean hasTicks = (this.tickUnit.getSize() &gt; 0.0)</span>
<span class="nc bnc" id="L579" title="All 2 branches missed.">                           &amp;&amp; !Double.isInfinite(start);</span>
<span class="nc bnc" id="L580" title="All 4 branches missed.">        while (hasTicks &amp;&amp; current &lt;= end) {</span>
<span class="nc" id="L581">            double v = calculateValue(current);</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">            if (range.contains(v)) {</span>
<span class="nc" id="L583">                ticks.add(new NumberTick(TickType.MAJOR, v, createTickLabel(v),</span>
                        textAnchor, TextAnchor.CENTER, 0.0));
            }
            // add minor ticks (for gridlines)
<span class="nc" id="L587">            double next = Math.pow(this.base, current</span>
<span class="nc" id="L588">                    + this.tickUnit.getSize());</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">            for (int i = 1; i &lt; minorTickCount; i++) {</span>
<span class="nc" id="L590">                double minorV = v + i * ((next - v) / minorTickCount);</span>
<span class="nc bnc" id="L591" title="All 2 branches missed.">                if (range.contains(minorV)) {</span>
<span class="nc" id="L592">                    ticks.add(new NumberTick(TickType.MINOR, minorV, &quot;&quot;,</span>
                            textAnchor, TextAnchor.CENTER, 0.0));
                }
            }
<span class="nc" id="L596">            current = current + this.tickUnit.getSize();</span>
<span class="nc" id="L597">        }</span>
<span class="nc" id="L598">        return ticks;</span>
    }

    /**
     * Selects an appropriate tick value for the axis.  The strategy is to
     * display as many ticks as possible (selected from an array of 'standard'
     * tick units) without the labels overlapping.
     *
     * @param g2  the graphics device.
     * @param dataArea  the area defined by the axes.
     * @param edge  the axis location.
     *
     * @since 1.0.7
     */
    protected void selectAutoTickUnit(Graphics2D g2, Rectangle2D dataArea,
            RectangleEdge edge) {

<span class="pc bpc" id="L615" title="1 of 2 branches missed.">        if (RectangleEdge.isTopOrBottom(edge)) {</span>
<span class="fc" id="L616">            selectHorizontalAutoTickUnit(g2, dataArea, edge);</span>
        }
<span class="nc bnc" id="L618" title="All 2 branches missed.">        else if (RectangleEdge.isLeftOrRight(edge)) {</span>
<span class="nc" id="L619">            selectVerticalAutoTickUnit(g2, dataArea, edge);</span>
        }

<span class="fc" id="L622">    }</span>

    /**
     * Selects an appropriate tick value for the axis.  The strategy is to
     * display as many ticks as possible (selected from an array of 'standard'
     * tick units) without the labels overlapping.
     *
     * @param g2  the graphics device.
     * @param dataArea  the area defined by the axes.
     * @param edge  the axis location.
     *
     * @since 1.0.7
     */
   protected void selectHorizontalAutoTickUnit(Graphics2D g2,
           Rectangle2D dataArea, RectangleEdge edge) {

<span class="fc" id="L638">        double tickLabelWidth = estimateMaximumTickLabelWidth(g2,</span>
<span class="fc" id="L639">                getTickUnit());</span>

        // start with the current tick unit...
<span class="fc" id="L642">        TickUnitSource tickUnits = getStandardTickUnits();</span>
<span class="fc" id="L643">        TickUnit unit1 = tickUnits.getCeilingTickUnit(getTickUnit());</span>
<span class="fc" id="L644">        double unit1Width = exponentLengthToJava2D(unit1.getSize(), dataArea,</span>
                edge);

        // then extrapolate...
<span class="fc" id="L648">        double guess = (tickLabelWidth / unit1Width) * unit1.getSize();</span>

<span class="fc" id="L650">        NumberTickUnit unit2 = (NumberTickUnit)</span>
<span class="fc" id="L651">                tickUnits.getCeilingTickUnit(guess);</span>
<span class="fc" id="L652">        double unit2Width = exponentLengthToJava2D(unit2.getSize(), dataArea,</span>
                edge);

<span class="fc" id="L655">        tickLabelWidth = estimateMaximumTickLabelWidth(g2, unit2);</span>
<span class="pc bpc" id="L656" title="1 of 2 branches missed.">        if (tickLabelWidth &gt; unit2Width) {</span>
<span class="nc" id="L657">            unit2 = (NumberTickUnit) tickUnits.getLargerTickUnit(unit2);</span>
        }

<span class="fc" id="L660">        setTickUnit(unit2, false, false);</span>

<span class="fc" id="L662">    }</span>

    /**
     * Converts a length in data coordinates into the corresponding length in
     * Java2D coordinates.
     *
     * @param length  the length.
     * @param area  the plot area.
     * @param edge  the edge along which the axis lies.
     *
     * @return The length in Java2D coordinates.
     *
     * @since 1.0.7
     */
    public double exponentLengthToJava2D(double length, Rectangle2D area,
                                RectangleEdge edge) {
<span class="fc" id="L678">        double one = valueToJava2D(calculateValue(1.0), area, edge);</span>
<span class="fc" id="L679">        double l = valueToJava2D(calculateValue(length + 1.0), area, edge);</span>
<span class="fc" id="L680">        return Math.abs(l - one);</span>
    }

    /**
     * Selects an appropriate tick value for the axis.  The strategy is to
     * display as many ticks as possible (selected from an array of 'standard'
     * tick units) without the labels overlapping.
     *
     * @param g2  the graphics device.
     * @param dataArea  the area in which the plot should be drawn.
     * @param edge  the axis location.
     *
     * @since 1.0.7
     */
    protected void selectVerticalAutoTickUnit(Graphics2D g2, 
            Rectangle2D dataArea, RectangleEdge edge) {

<span class="nc" id="L697">        double tickLabelHeight = estimateMaximumTickLabelHeight(g2);</span>

        // start with the current tick unit...
<span class="nc" id="L700">        TickUnitSource tickUnits = getStandardTickUnits();</span>
<span class="nc" id="L701">        TickUnit unit1 = tickUnits.getCeilingTickUnit(getTickUnit());</span>
<span class="nc" id="L702">        double unitHeight = exponentLengthToJava2D(unit1.getSize(), dataArea,</span>
                edge);

        // then extrapolate...
<span class="nc" id="L706">        double guess = (tickLabelHeight / unitHeight) * unit1.getSize();</span>

<span class="nc" id="L708">        NumberTickUnit unit2 = (NumberTickUnit)</span>
<span class="nc" id="L709">                tickUnits.getCeilingTickUnit(guess);</span>
<span class="nc" id="L710">        double unit2Height = exponentLengthToJava2D(unit2.getSize(), dataArea,</span>
                edge);

<span class="nc" id="L713">        tickLabelHeight = estimateMaximumTickLabelHeight(g2);</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">        if (tickLabelHeight &gt; unit2Height) {</span>
<span class="nc" id="L715">            unit2 = (NumberTickUnit) tickUnits.getLargerTickUnit(unit2);</span>
        }

<span class="nc" id="L718">        setTickUnit(unit2, false, false);</span>

<span class="nc" id="L720">    }</span>

    /**
     * Estimates the maximum tick label height.
     *
     * @param g2  the graphics device.
     *
     * @return The maximum height.
     *
     * @since 1.0.7
     */
    protected double estimateMaximumTickLabelHeight(Graphics2D g2) {

<span class="nc" id="L733">        RectangleInsets tickLabelInsets = getTickLabelInsets();</span>
<span class="nc" id="L734">        double result = tickLabelInsets.getTop() + tickLabelInsets.getBottom();</span>

<span class="nc" id="L736">        Font tickLabelFont = getTickLabelFont();</span>
<span class="nc" id="L737">        FontRenderContext frc = g2.getFontRenderContext();</span>
<span class="nc" id="L738">        result += tickLabelFont.getLineMetrics(&quot;123&quot;, frc).getHeight();</span>
<span class="nc" id="L739">        return result;</span>

    }

    /**
     * Estimates the maximum width of the tick labels, assuming the specified
     * tick unit is used.
     * &lt;P&gt;
     * Rather than computing the string bounds of every tick on the axis, we
     * just look at two values: the lower bound and the upper bound for the
     * axis.  These two values will usually be representative.
     *
     * @param g2  the graphics device.
     * @param unit  the tick unit to use for calculation.
     *
     * @return The estimated maximum width of the tick labels.
     *
     * @since 1.0.7
     */
    protected double estimateMaximumTickLabelWidth(Graphics2D g2, 
            TickUnit unit) {

<span class="fc" id="L761">        RectangleInsets tickLabelInsets = getTickLabelInsets();</span>
<span class="fc" id="L762">        double result = tickLabelInsets.getLeft() + tickLabelInsets.getRight();</span>

<span class="pc bpc" id="L764" title="1 of 2 branches missed.">        if (isVerticalTickLabels()) {</span>
            // all tick labels have the same width (equal to the height of the
            // font)...
<span class="nc" id="L767">            FontRenderContext frc = g2.getFontRenderContext();</span>
<span class="nc" id="L768">            LineMetrics lm = getTickLabelFont().getLineMetrics(&quot;0&quot;, frc);</span>
<span class="nc" id="L769">            result += lm.getHeight();</span>
<span class="nc" id="L770">        }</span>
        else {
            // look at lower and upper bounds...
<span class="fc" id="L773">            FontMetrics fm = g2.getFontMetrics(getTickLabelFont());</span>
<span class="fc" id="L774">            Range range = getRange();</span>
<span class="fc" id="L775">            double lower = range.getLowerBound();</span>
<span class="fc" id="L776">            double upper = range.getUpperBound();</span>
            String lowerStr, upperStr;
<span class="fc" id="L778">            NumberFormat formatter = getNumberFormatOverride();</span>
<span class="pc bpc" id="L779" title="1 of 2 branches missed.">            if (formatter != null) {</span>
<span class="nc" id="L780">                lowerStr = formatter.format(lower);</span>
<span class="nc" id="L781">                upperStr = formatter.format(upper);</span>
            }
            else {
<span class="fc" id="L784">                lowerStr = unit.valueToString(lower);</span>
<span class="fc" id="L785">                upperStr = unit.valueToString(upper);</span>
            }
<span class="fc" id="L787">            double w1 = fm.stringWidth(lowerStr);</span>
<span class="fc" id="L788">            double w2 = fm.stringWidth(upperStr);</span>
<span class="fc" id="L789">            result += Math.max(w1, w2);</span>
        }

<span class="fc" id="L792">        return result;</span>

    }

    /**
     * Zooms in on the current range.
     *
     * @param lowerPercent  the new lower bound.
     * @param upperPercent  the new upper bound.
     */
    public void zoomRange(double lowerPercent, double upperPercent) {
<span class="nc" id="L803">        Range range = getRange();</span>
<span class="nc" id="L804">        double start = range.getLowerBound();</span>
<span class="nc" id="L805">        double end = range.getUpperBound();</span>
<span class="nc" id="L806">        double log1 = calculateLog(start);</span>
<span class="nc" id="L807">        double log2 = calculateLog(end);</span>
<span class="nc" id="L808">        double length = log2 - log1;</span>
        Range adjusted;
<span class="nc bnc" id="L810" title="All 2 branches missed.">        if (isInverted()) {</span>
<span class="nc" id="L811">            double logA = log1 + length * (1 - upperPercent);</span>
<span class="nc" id="L812">            double logB = log1 + length * (1 - lowerPercent);</span>
<span class="nc" id="L813">            adjusted = new Range(calculateValue(logA), calculateValue(logB));</span>
<span class="nc" id="L814">        }</span>
        else {
<span class="nc" id="L816">            double logA = log1 + length * lowerPercent;</span>
<span class="nc" id="L817">            double logB = log1 + length * upperPercent;</span>
<span class="nc" id="L818">            adjusted = new Range(calculateValue(logA), calculateValue(logB));</span>
        }
<span class="nc" id="L820">        setRange(adjusted);</span>
<span class="nc" id="L821">    }</span>

    /**
     * Slides the axis range by the specified percentage.
     *
     * @param percent  the percentage.
     *
     * @since 1.0.13
     */
    public void pan(double percent) {
<span class="nc" id="L831">        Range range = getRange();</span>
<span class="nc" id="L832">        double lower = range.getLowerBound();</span>
<span class="nc" id="L833">        double upper = range.getUpperBound();</span>
<span class="nc" id="L834">        double log1 = calculateLog(lower);</span>
<span class="nc" id="L835">        double log2 = calculateLog(upper);</span>
<span class="nc" id="L836">        double length = log2 - log1;</span>
<span class="nc" id="L837">        double adj = length * percent;</span>
<span class="nc" id="L838">        log1 = log1 + adj;</span>
<span class="nc" id="L839">        log2 = log2 + adj;</span>
<span class="nc" id="L840">        setRange(calculateValue(log1), calculateValue(log2));</span>
<span class="nc" id="L841">    }</span>

    /**
     * Creates a tick label for the specified value.  Note that this method
     * was 'private' prior to version 1.0.10.
     *
     * @param value  the value.
     *
     * @return The label.
     *
     * @since 1.0.10
     */
    protected String createTickLabel(double value) {
<span class="nc bnc" id="L854" title="All 2 branches missed.">        if (this.numberFormatOverride != null) {</span>
<span class="nc" id="L855">            return this.numberFormatOverride.format(value);</span>
        }
        else {
<span class="nc" id="L858">            return this.tickUnit.valueToString(value);</span>
        }
    }

    /**
     * Tests this axis for equality with an arbitrary object.
     *
     * @param obj  the object (&lt;code&gt;null&lt;/code&gt; permitted).
     *
     * @return A boolean.
     */
    public boolean equals(Object obj) {
<span class="pc bpc" id="L870" title="1 of 2 branches missed.">        if (obj == this) {</span>
<span class="nc" id="L871">            return true;</span>
        }
<span class="pc bpc" id="L873" title="1 of 2 branches missed.">        if (!(obj instanceof LogAxis)) {</span>
<span class="nc" id="L874">            return false;</span>
        }
<span class="fc" id="L876">        LogAxis that = (LogAxis) obj;</span>
<span class="fc bfc" id="L877" title="All 2 branches covered.">        if (this.base != that.base) {</span>
<span class="fc" id="L878">            return false;</span>
        }
<span class="fc bfc" id="L880" title="All 2 branches covered.">        if (this.smallestValue != that.smallestValue) {</span>
<span class="fc" id="L881">            return false;</span>
        }
<span class="fc" id="L883">        return super.equals(obj);</span>
    }

    /**
     * Returns a hash code for this instance.
     *
     * @return A hash code.
     */
    public int hashCode() {
<span class="fc" id="L892">        int result = 193;</span>
<span class="fc" id="L893">        long temp = Double.doubleToLongBits(this.base);</span>
<span class="fc" id="L894">        result = 37 * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));</span>
<span class="fc" id="L895">        temp = Double.doubleToLongBits(this.smallestValue);</span>
<span class="fc" id="L896">        result = 37 * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));</span>
<span class="pc bpc" id="L897" title="1 of 2 branches missed.">        if (this.numberFormatOverride != null) {</span>
<span class="nc" id="L898">            result = 37 * result + this.numberFormatOverride.hashCode();</span>
        }
<span class="fc" id="L900">        result = 37 * result + this.tickUnit.hashCode();</span>
<span class="fc" id="L901">        return result;</span>
    }

    /**
     * Returns a collection of tick units for log (base 10) values.
     * Uses a given Locale to create the DecimalFormats.
     *
     * @param locale the locale to use to represent Numbers.
     *
     * @return A collection of tick units for integer values.
     *
     * @since 1.0.7
     */
    public static TickUnitSource createLogTickUnits(Locale locale) {
<span class="fc" id="L915">        TickUnits units = new TickUnits();</span>
<span class="fc" id="L916">        NumberFormat numberFormat = new LogFormat();</span>
<span class="fc" id="L917">        units.add(new NumberTickUnit(0.05, numberFormat, 2));</span>
<span class="fc" id="L918">        units.add(new NumberTickUnit(0.1, numberFormat, 10));</span>
<span class="fc" id="L919">        units.add(new NumberTickUnit(0.2, numberFormat, 2));</span>
<span class="fc" id="L920">        units.add(new NumberTickUnit(0.5, numberFormat, 5));</span>
<span class="fc" id="L921">        units.add(new NumberTickUnit(1, numberFormat, 10));</span>
<span class="fc" id="L922">        units.add(new NumberTickUnit(2, numberFormat, 10));</span>
<span class="fc" id="L923">        units.add(new NumberTickUnit(3, numberFormat, 15));</span>
<span class="fc" id="L924">        units.add(new NumberTickUnit(4, numberFormat, 20));</span>
<span class="fc" id="L925">        units.add(new NumberTickUnit(5, numberFormat, 25));</span>
<span class="fc" id="L926">        units.add(new NumberTickUnit(6, numberFormat));</span>
<span class="fc" id="L927">        units.add(new NumberTickUnit(7, numberFormat));</span>
<span class="fc" id="L928">        units.add(new NumberTickUnit(8, numberFormat));</span>
<span class="fc" id="L929">        units.add(new NumberTickUnit(9, numberFormat));</span>
<span class="fc" id="L930">        units.add(new NumberTickUnit(10, numberFormat));</span>
<span class="fc" id="L931">        return units;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>