<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FieldRotation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Math</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math4.geometry.euclidean.threed</a> &gt; <span class="el_source">FieldRotation.java</span></div><h1>FieldRotation.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.math4.geometry.euclidean.threed;

import java.io.Serializable;

import org.apache.commons.numbers.quaternion.Quaternion;
import org.apache.commons.geometry.euclidean.threed.Vector3D;
import org.apache.commons.geometry.euclidean.threed.rotation.QuaternionRotation;
import org.apache.commons.math4.Field;
import org.apache.commons.math4.RealFieldElement;
import org.apache.commons.math4.exception.MathArithmeticException;
import org.apache.commons.math4.exception.MathIllegalArgumentException;
import org.apache.commons.math4.exception.util.LocalizedFormats;
import org.apache.commons.math4.util.FastMath;
import org.apache.commons.math4.util.MathArrays;

/**
 * Implementation of rotation using {@link RealFieldElement}.
 * &lt;p&gt;Instance of this class are guaranteed to be immutable.&lt;/p&gt;
 *
 * @param &lt;T&gt; the type of the field elements
 * @see FieldVector3D
 * @see RotationOrder
 * @since 3.2
 */

public class FieldRotation&lt;T extends RealFieldElement&lt;T&gt;&gt; implements Serializable {

    /** Serializable version identifier */
    private static final long serialVersionUID = 20130224l;

    /** Scalar coordinate of the quaternion. */
    private final T q0;

    /** First coordinate of the vectorial part of the quaternion. */
    private final T q1;

    /** Second coordinate of the vectorial part of the quaternion. */
    private final T q2;

    /** Third coordinate of the vectorial part of the quaternion. */
    private final T q3;

    /** Build a rotation from the quaternion coordinates.
     * &lt;p&gt;A rotation can be built from a &lt;em&gt;normalized&lt;/em&gt; quaternion,
     * i.e. a quaternion for which q&lt;sub&gt;0&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt; +
     * q&lt;sub&gt;1&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt; + q&lt;sub&gt;2&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt; +
     * q&lt;sub&gt;3&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt; = 1. If the quaternion is not normalized,
     * the constructor can normalize it in a preprocessing step.&lt;/p&gt;
     * &lt;p&gt;Note that some conventions put the scalar part of the quaternion
     * as the 4&lt;sup&gt;th&lt;/sup&gt; component and the vector part as the first three
     * components. This is &lt;em&gt;not&lt;/em&gt; our convention. We put the scalar part
     * as the first component.&lt;/p&gt;
     * @param q0 scalar part of the quaternion
     * @param q1 first coordinate of the vectorial part of the quaternion
     * @param q2 second coordinate of the vectorial part of the quaternion
     * @param q3 third coordinate of the vectorial part of the quaternion
     * @param needsNormalization if true, the coordinates are considered
     * not to be normalized, a normalization preprocessing step is performed
     * before using them
     */
<span class="fc" id="L78">    public FieldRotation(final T q0, final T q1, final T q2, final T q3, final boolean needsNormalization) {</span>

<span class="fc bfc" id="L80" title="All 2 branches covered.">        if (needsNormalization) {</span>
            // normalization preprocessing
<span class="fc" id="L82">            final T inv =</span>
<span class="fc" id="L83">                    q0.multiply(q0).add(q1.multiply(q1)).add(q2.multiply(q2)).add(q3.multiply(q3)).sqrt().reciprocal();</span>
<span class="fc" id="L84">            this.q0 = inv.multiply(q0);</span>
<span class="fc" id="L85">            this.q1 = inv.multiply(q1);</span>
<span class="fc" id="L86">            this.q2 = inv.multiply(q2);</span>
<span class="fc" id="L87">            this.q3 = inv.multiply(q3);</span>
<span class="fc" id="L88">        } else {</span>
<span class="fc" id="L89">            this.q0 = q0;</span>
<span class="fc" id="L90">            this.q1 = q1;</span>
<span class="fc" id="L91">            this.q2 = q2;</span>
<span class="fc" id="L92">            this.q3 = q3;</span>
        }

<span class="fc" id="L95">    }</span>

    /** Build a rotation from an axis and an angle.
     * &lt;p&gt;We use the convention that angles are oriented according to
     * the effect of the rotation on vectors around the axis. That means
     * that if (i, j, k) is a direct frame and if we first provide +k as
     * the axis and &amp;pi;/2 as the angle to this constructor, and then
     * {@link #applyTo(FieldVector3D) apply} the instance to +i, we will get
     * +j.&lt;/p&gt;
     * &lt;p&gt;Another way to represent our convention is to say that a rotation
     * of angle &amp;theta; about the unit vector (x, y, z) is the same as the
     * rotation build from quaternion components { cos(-&amp;theta;/2),
     * x * sin(-&amp;theta;/2), y * sin(-&amp;theta;/2), z * sin(-&amp;theta;/2) }.
     * Note the minus sign on the angle!&lt;/p&gt;
     * &lt;p&gt;On the one hand this convention is consistent with a vectorial
     * perspective (moving vectors in fixed frames), on the other hand it
     * is different from conventions with a frame perspective (fixed vectors
     * viewed from different frames) like the ones used for example in spacecraft
     * attitude community or in the graphics community.&lt;/p&gt;
     * @param axis axis around which to rotate
     * @param angle rotation angle.
     * @exception MathIllegalArgumentException if the axis norm is zero
     * @deprecated as of 3.6, replaced with {@link
     * #FieldRotation(FieldVector3D, RealFieldElement, RotationConvention)}
     */
    @Deprecated
    public FieldRotation(final FieldVector3D&lt;T&gt; axis, final T angle)
        throws MathIllegalArgumentException {
<span class="fc" id="L123">        this(axis, angle, RotationConvention.VECTOR_OPERATOR);</span>
<span class="fc" id="L124">    }</span>

    /** Build a rotation from an axis and an angle.
     * &lt;p&gt;We use the convention that angles are oriented according to
     * the effect of the rotation on vectors around the axis. That means
     * that if (i, j, k) is a direct frame and if we first provide +k as
     * the axis and &amp;pi;/2 as the angle to this constructor, and then
     * {@link #applyTo(FieldVector3D) apply} the instance to +i, we will get
     * +j.&lt;/p&gt;
     * &lt;p&gt;Another way to represent our convention is to say that a rotation
     * of angle &amp;theta; about the unit vector (x, y, z) is the same as the
     * rotation build from quaternion components { cos(-&amp;theta;/2),
     * x * sin(-&amp;theta;/2), y * sin(-&amp;theta;/2), z * sin(-&amp;theta;/2) }.
     * Note the minus sign on the angle!&lt;/p&gt;
     * &lt;p&gt;On the one hand this convention is consistent with a vectorial
     * perspective (moving vectors in fixed frames), on the other hand it
     * is different from conventions with a frame perspective (fixed vectors
     * viewed from different frames) like the ones used for example in spacecraft
     * attitude community or in the graphics community.&lt;/p&gt;
     * @param axis axis around which to rotate
     * @param angle rotation angle.
     * @param convention convention to use for the semantics of the angle
     * @exception MathIllegalArgumentException if the axis norm is zero
     * @since 3.6
     */
    public FieldRotation(final FieldVector3D&lt;T&gt; axis, final T angle, final RotationConvention convention)
<span class="fc" id="L150">        throws MathIllegalArgumentException {</span>

<span class="fc" id="L152">        final T norm = axis.getNorm();</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">        if (norm.getReal() == 0) {</span>
<span class="fc" id="L154">            throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_AXIS);</span>
        }

<span class="fc bfc" id="L157" title="All 2 branches covered.">        final T halfAngle = angle.multiply(convention == RotationConvention.VECTOR_OPERATOR ? -0.5 : 0.5);</span>
<span class="fc" id="L158">        final T coeff = halfAngle.sin().divide(norm);</span>

<span class="fc" id="L160">        q0 = halfAngle.cos();</span>
<span class="fc" id="L161">        q1 = coeff.multiply(axis.getX());</span>
<span class="fc" id="L162">        q2 = coeff.multiply(axis.getY());</span>
<span class="fc" id="L163">        q3 = coeff.multiply(axis.getZ());</span>

<span class="fc" id="L165">    }</span>

    /** Build a rotation from a 3X3 matrix.

     * &lt;p&gt;Rotation matrices are orthogonal matrices, i.e. unit matrices
     * (which are matrices for which m.m&lt;sup&gt;T&lt;/sup&gt; = I) with real
     * coefficients. The module of the determinant of unit matrices is
     * 1, among the orthogonal 3X3 matrices, only the ones having a
     * positive determinant (+1) are rotation matrices.&lt;/p&gt;

     * &lt;p&gt;When a rotation is defined by a matrix with truncated values
     * (typically when it is extracted from a technical sheet where only
     * four to five significant digits are available), the matrix is not
     * orthogonal anymore. This constructor handles this case
     * transparently by using a copy of the given matrix and applying a
     * correction to the copy in order to perfect its orthogonality. If
     * the Frobenius norm of the correction needed is above the given
     * threshold, then the matrix is considered to be too far from a
     * true rotation matrix and an exception is thrown.&lt;p&gt;

     * @param m rotation matrix
     * @param threshold convergence threshold for the iterative
     * orthogonality correction (convergence is reached when the
     * difference between two steps of the Frobenius norm of the
     * correction is below this threshold)

     * @exception NotARotationMatrixException if the matrix is not a 3X3
     * matrix, or if it cannot be transformed into an orthogonal matrix
     * with the given threshold, or if the determinant of the resulting
     * orthogonal matrix is negative

     */
    public FieldRotation(final T[][] m, final double threshold)
<span class="fc" id="L198">        throws NotARotationMatrixException {</span>

        // dimension check
<span class="pc bpc" id="L201" title="3 of 8 branches missed.">        if ((m.length != 3) || (m[0].length != 3) ||</span>
                (m[1].length != 3) || (m[2].length != 3)) {
<span class="fc" id="L203">            throw new NotARotationMatrixException(</span>
                                                  LocalizedFormats.ROTATION_MATRIX_DIMENSIONS,
<span class="fc" id="L205">                                                  m.length, m[0].length);</span>
        }

        // compute a &quot;close&quot; orthogonal matrix
<span class="fc" id="L209">        final T[][] ort = orthogonalizeMatrix(m, threshold);</span>

        // check the sign of the determinant
<span class="fc" id="L212">        final T d0 = ort[1][1].multiply(ort[2][2]).subtract(ort[2][1].multiply(ort[1][2]));</span>
<span class="fc" id="L213">        final T d1 = ort[0][1].multiply(ort[2][2]).subtract(ort[2][1].multiply(ort[0][2]));</span>
<span class="fc" id="L214">        final T d2 = ort[0][1].multiply(ort[1][2]).subtract(ort[1][1].multiply(ort[0][2]));</span>
<span class="fc" id="L215">        final T det =</span>
<span class="fc" id="L216">                ort[0][0].multiply(d0).subtract(ort[1][0].multiply(d1)).add(ort[2][0].multiply(d2));</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">        if (det.getReal() &lt; 0.0) {</span>
<span class="fc" id="L218">            throw new NotARotationMatrixException(</span>
                                                  LocalizedFormats.CLOSEST_ORTHOGONAL_MATRIX_HAS_NEGATIVE_DETERMINANT,
                                                  det);
        }

<span class="fc" id="L223">        final T[] quat = mat2quat(ort);</span>
<span class="fc" id="L224">        q0 = quat[0];</span>
<span class="fc" id="L225">        q1 = quat[1];</span>
<span class="fc" id="L226">        q2 = quat[2];</span>
<span class="fc" id="L227">        q3 = quat[3];</span>

<span class="fc" id="L229">    }</span>

    /** Build the rotation that transforms a pair of vectors into another pair.

     * &lt;p&gt;Except for possible scale factors, if the instance were applied to
     * the pair (u&lt;sub&gt;1&lt;/sub&gt;, u&lt;sub&gt;2&lt;/sub&gt;) it will produce the pair
     * (v&lt;sub&gt;1&lt;/sub&gt;, v&lt;sub&gt;2&lt;/sub&gt;).&lt;/p&gt;

     * &lt;p&gt;If the angular separation between u&lt;sub&gt;1&lt;/sub&gt; and u&lt;sub&gt;2&lt;/sub&gt; is
     * not the same as the angular separation between v&lt;sub&gt;1&lt;/sub&gt; and
     * v&lt;sub&gt;2&lt;/sub&gt;, then a corrected v'&lt;sub&gt;2&lt;/sub&gt; will be used rather than
     * v&lt;sub&gt;2&lt;/sub&gt;, the corrected vector will be in the (&amp;plusmn;v&lt;sub&gt;1&lt;/sub&gt;,
     * +v&lt;sub&gt;2&lt;/sub&gt;) half-plane.&lt;/p&gt;

     * @param u1 first vector of the origin pair
     * @param u2 second vector of the origin pair
     * @param v1 desired image of u1 by the rotation
     * @param v2 desired image of u2 by the rotation
     * @exception MathArithmeticException if the norm of one of the vectors is zero,
     * or if one of the pair is degenerated (i.e. the vectors of the pair are collinear)
     */
    public FieldRotation(FieldVector3D&lt;T&gt; u1, FieldVector3D&lt;T&gt; u2, FieldVector3D&lt;T&gt; v1, FieldVector3D&lt;T&gt; v2)
<span class="fc" id="L251">        throws MathArithmeticException {</span>

        // build orthonormalized base from u1, u2
        // this fails when vectors are null or collinear, which is forbidden to define a rotation
<span class="fc" id="L255">        final FieldVector3D&lt;T&gt; u3 = FieldVector3D.crossProduct(u1, u2).normalize();</span>
<span class="fc" id="L256">        u2 = FieldVector3D.crossProduct(u3, u1).normalize();</span>
<span class="fc" id="L257">        u1 = u1.normalize();</span>

        // build an orthonormalized base from v1, v2
        // this fails when vectors are null or collinear, which is forbidden to define a rotation
<span class="fc" id="L261">        final FieldVector3D&lt;T&gt; v3 = FieldVector3D.crossProduct(v1, v2).normalize();</span>
<span class="fc" id="L262">        v2 = FieldVector3D.crossProduct(v3, v1).normalize();</span>
<span class="fc" id="L263">        v1 = v1.normalize();</span>

        // buid a matrix transforming the first base into the second one
<span class="fc" id="L266">        final T[][] array = MathArrays.buildArray(u1.getX().getField(), 3, 3);</span>
<span class="fc" id="L267">        array[0][0] = u1.getX().multiply(v1.getX()).add(u2.getX().multiply(v2.getX())).add(u3.getX().multiply(v3.getX()));</span>
<span class="fc" id="L268">        array[0][1] = u1.getY().multiply(v1.getX()).add(u2.getY().multiply(v2.getX())).add(u3.getY().multiply(v3.getX()));</span>
<span class="fc" id="L269">        array[0][2] = u1.getZ().multiply(v1.getX()).add(u2.getZ().multiply(v2.getX())).add(u3.getZ().multiply(v3.getX()));</span>
<span class="fc" id="L270">        array[1][0] = u1.getX().multiply(v1.getY()).add(u2.getX().multiply(v2.getY())).add(u3.getX().multiply(v3.getY()));</span>
<span class="fc" id="L271">        array[1][1] = u1.getY().multiply(v1.getY()).add(u2.getY().multiply(v2.getY())).add(u3.getY().multiply(v3.getY()));</span>
<span class="fc" id="L272">        array[1][2] = u1.getZ().multiply(v1.getY()).add(u2.getZ().multiply(v2.getY())).add(u3.getZ().multiply(v3.getY()));</span>
<span class="fc" id="L273">        array[2][0] = u1.getX().multiply(v1.getZ()).add(u2.getX().multiply(v2.getZ())).add(u3.getX().multiply(v3.getZ()));</span>
<span class="fc" id="L274">        array[2][1] = u1.getY().multiply(v1.getZ()).add(u2.getY().multiply(v2.getZ())).add(u3.getY().multiply(v3.getZ()));</span>
<span class="fc" id="L275">        array[2][2] = u1.getZ().multiply(v1.getZ()).add(u2.getZ().multiply(v2.getZ())).add(u3.getZ().multiply(v3.getZ()));</span>

<span class="fc" id="L277">        T[] quat = mat2quat(array);</span>
<span class="fc" id="L278">        q0 = quat[0];</span>
<span class="fc" id="L279">        q1 = quat[1];</span>
<span class="fc" id="L280">        q2 = quat[2];</span>
<span class="fc" id="L281">        q3 = quat[3];</span>

<span class="fc" id="L283">    }</span>

    /** Build one of the rotations that transform one vector into another one.

     * &lt;p&gt;Except for a possible scale factor, if the instance were
     * applied to the vector u it will produce the vector v. There is an
     * infinite number of such rotations, this constructor choose the
     * one with the smallest associated angle (i.e. the one whose axis
     * is orthogonal to the (u, v) plane). If u and v are collinear, an
     * arbitrary rotation axis is chosen.&lt;/p&gt;

     * @param u origin vector
     * @param v desired image of u by the rotation
     * @exception MathArithmeticException if the norm of one of the vectors is zero
     */
<span class="fc" id="L298">    public FieldRotation(final FieldVector3D&lt;T&gt; u, final FieldVector3D&lt;T&gt; v) throws MathArithmeticException {</span>

<span class="fc" id="L300">        final T normProduct = u.getNorm().multiply(v.getNorm());</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">        if (normProduct.getReal() == 0) {</span>
<span class="fc" id="L302">            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);</span>
        }

<span class="fc" id="L305">        final T dot = FieldVector3D.dotProduct(u, v);</span>

<span class="fc bfc" id="L307" title="All 2 branches covered.">        if (dot.getReal() &lt; ((2.0e-15 - 1.0) * normProduct.getReal())) {</span>
            // special case u = -v: we select a PI angle rotation around
            // an arbitrary vector orthogonal to u
<span class="fc" id="L310">            final FieldVector3D&lt;T&gt; w = u.orthogonal();</span>
<span class="fc" id="L311">            q0 = normProduct.getField().getZero();</span>
<span class="fc" id="L312">            q1 = w.getX().negate();</span>
<span class="fc" id="L313">            q2 = w.getY().negate();</span>
<span class="fc" id="L314">            q3 = w.getZ().negate();</span>
<span class="fc" id="L315">        } else {</span>
            // general case: (u, v) defines a plane, we select
            // the shortest possible rotation: axis orthogonal to this plane
<span class="fc" id="L318">            q0 = dot.divide(normProduct).add(1.0).multiply(0.5).sqrt();</span>
<span class="fc" id="L319">            final T coeff = q0.multiply(normProduct).multiply(2.0).reciprocal();</span>
<span class="fc" id="L320">            final FieldVector3D&lt;T&gt; q = FieldVector3D.crossProduct(v, u);</span>
<span class="fc" id="L321">            q1 = coeff.multiply(q.getX());</span>
<span class="fc" id="L322">            q2 = coeff.multiply(q.getY());</span>
<span class="fc" id="L323">            q3 = coeff.multiply(q.getZ());</span>
        }

<span class="fc" id="L326">    }</span>

    /** Build a rotation from three Cardan or Euler elementary rotations.

     * &lt;p&gt;Cardan rotations are three successive rotations around the
     * canonical axes X, Y and Z, each axis being used once. There are
     * 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler
     * rotations are three successive rotations around the canonical
     * axes X, Y and Z, the first and last rotations being around the
     * same axis. There are 6 such sets of rotations (XYX, XZX, YXY,
     * YZY, ZXZ and ZYZ), the most popular one being ZXZ.&lt;/p&gt;
     * &lt;p&gt;Beware that many people routinely use the term Euler angles even
     * for what really are Cardan angles (this confusion is especially
     * widespread in the aerospace business where Roll, Pitch and Yaw angles
     * are often wrongly tagged as Euler angles).&lt;/p&gt;

     * @param order order of rotations to use
     * @param alpha1 angle of the first elementary rotation
     * @param alpha2 angle of the second elementary rotation
     * @param alpha3 angle of the third elementary rotation
     * @deprecated as of 3.6, replaced with {@link
     * #FieldRotation(RotationOrder, RotationConvention,
     * RealFieldElement, RealFieldElement, RealFieldElement)}
     */
    @Deprecated
    public FieldRotation(final RotationOrder order, final T alpha1, final T alpha2, final T alpha3) {
<span class="fc" id="L352">        this(order, RotationConvention.VECTOR_OPERATOR, alpha1, alpha2, alpha3);</span>
<span class="fc" id="L353">    }</span>

    /** Build a rotation from three Cardan or Euler elementary rotations.

     * &lt;p&gt;Cardan rotations are three successive rotations around the
     * canonical axes X, Y and Z, each axis being used once. There are
     * 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler
     * rotations are three successive rotations around the canonical
     * axes X, Y and Z, the first and last rotations being around the
     * same axis. There are 6 such sets of rotations (XYX, XZX, YXY,
     * YZY, ZXZ and ZYZ), the most popular one being ZXZ.&lt;/p&gt;
     * &lt;p&gt;Beware that many people routinely use the term Euler angles even
     * for what really are Cardan angles (this confusion is especially
     * widespread in the aerospace business where Roll, Pitch and Yaw angles
     * are often wrongly tagged as Euler angles).&lt;/p&gt;

     * @param order order of rotations to compose, from left to right
     * (i.e. we will use {@code r1.compose(r2.compose(r3, convention), convention)})
     * @param convention convention to use for the semantics of the angle
     * @param alpha1 angle of the first elementary rotation
     * @param alpha2 angle of the second elementary rotation
     * @param alpha3 angle of the third elementary rotation
     * @since 3.6
     */
    public FieldRotation(final RotationOrder order, final RotationConvention convention,
<span class="fc" id="L378">                         final T alpha1, final T alpha2, final T alpha3) {</span>
<span class="fc" id="L379">        final T one = alpha1.getField().getOne();</span>
<span class="fc" id="L380">        final FieldRotation&lt;T&gt; r1 = new FieldRotation&lt;&gt;(new FieldVector3D&lt;&gt;(one, order.getA1()), alpha1, convention);</span>
<span class="fc" id="L381">        final FieldRotation&lt;T&gt; r2 = new FieldRotation&lt;&gt;(new FieldVector3D&lt;&gt;(one, order.getA2()), alpha2, convention);</span>
<span class="fc" id="L382">        final FieldRotation&lt;T&gt; r3 = new FieldRotation&lt;&gt;(new FieldVector3D&lt;&gt;(one, order.getA3()), alpha3, convention);</span>
<span class="fc" id="L383">        final FieldRotation&lt;T&gt; composed = r1.compose(r2.compose(r3, convention), convention);</span>
<span class="fc" id="L384">        q0 = composed.q0;</span>
<span class="fc" id="L385">        q1 = composed.q1;</span>
<span class="fc" id="L386">        q2 = composed.q2;</span>
<span class="fc" id="L387">        q3 = composed.q3;</span>
<span class="fc" id="L388">    }</span>

    /** Convert an orthogonal rotation matrix to a quaternion.
     * @param ort orthogonal rotation matrix
     * @return quaternion corresponding to the matrix
     */
    private T[] mat2quat(final T[][] ort) {

<span class="fc" id="L396">        final T[] quat = MathArrays.buildArray(ort[0][0].getField(), 4);</span>

        // There are different ways to compute the quaternions elements
        // from the matrix. They all involve computing one element from
        // the diagonal of the matrix, and computing the three other ones
        // using a formula involving a division by the first element,
        // which unfortunately can be zero. Since the norm of the
        // quaternion is 1, we know at least one element has an absolute
        // value greater or equal to 0.5, so it is always possible to
        // select the right formula and avoid division by zero and even
        // numerical inaccuracy. Checking the elements in turn and using
        // the first one greater than 0.45 is safe (this leads to a simple
        // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)
<span class="fc" id="L409">        T s = ort[0][0].add(ort[1][1]).add(ort[2][2]);</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">        if (s.getReal() &gt; -0.19) {</span>
            // compute q0 and deduce q1, q2 and q3
<span class="fc" id="L412">            quat[0] = s.add(1.0).sqrt().multiply(0.5);</span>
<span class="fc" id="L413">            T inv = quat[0].reciprocal().multiply(0.25);</span>
<span class="fc" id="L414">            quat[1] = inv.multiply(ort[1][2].subtract(ort[2][1]));</span>
<span class="fc" id="L415">            quat[2] = inv.multiply(ort[2][0].subtract(ort[0][2]));</span>
<span class="fc" id="L416">            quat[3] = inv.multiply(ort[0][1].subtract(ort[1][0]));</span>
<span class="fc" id="L417">        } else {</span>
<span class="fc" id="L418">            s = ort[0][0].subtract(ort[1][1]).subtract(ort[2][2]);</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">            if (s.getReal() &gt; -0.19) {</span>
                // compute q1 and deduce q0, q2 and q3
<span class="fc" id="L421">                quat[1] = s.add(1.0).sqrt().multiply(0.5);</span>
<span class="fc" id="L422">                T inv = quat[1].reciprocal().multiply(0.25);</span>
<span class="fc" id="L423">                quat[0] = inv.multiply(ort[1][2].subtract(ort[2][1]));</span>
<span class="fc" id="L424">                quat[2] = inv.multiply(ort[0][1].add(ort[1][0]));</span>
<span class="fc" id="L425">                quat[3] = inv.multiply(ort[0][2].add(ort[2][0]));</span>
<span class="fc" id="L426">            } else {</span>
<span class="fc" id="L427">                s = ort[1][1].subtract(ort[0][0]).subtract(ort[2][2]);</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">                if (s.getReal() &gt; -0.19) {</span>
                    // compute q2 and deduce q0, q1 and q3
<span class="fc" id="L430">                    quat[2] = s.add(1.0).sqrt().multiply(0.5);</span>
<span class="fc" id="L431">                    T inv = quat[2].reciprocal().multiply(0.25);</span>
<span class="fc" id="L432">                    quat[0] = inv.multiply(ort[2][0].subtract(ort[0][2]));</span>
<span class="fc" id="L433">                    quat[1] = inv.multiply(ort[0][1].add(ort[1][0]));</span>
<span class="fc" id="L434">                    quat[3] = inv.multiply(ort[2][1].add(ort[1][2]));</span>
<span class="fc" id="L435">                } else {</span>
                    // compute q3 and deduce q0, q1 and q2
<span class="fc" id="L437">                    s = ort[2][2].subtract(ort[0][0]).subtract(ort[1][1]);</span>
<span class="fc" id="L438">                    quat[3] = s.add(1.0).sqrt().multiply(0.5);</span>
<span class="fc" id="L439">                    T inv = quat[3].reciprocal().multiply(0.25);</span>
<span class="fc" id="L440">                    quat[0] = inv.multiply(ort[0][1].subtract(ort[1][0]));</span>
<span class="fc" id="L441">                    quat[1] = inv.multiply(ort[0][2].add(ort[2][0]));</span>
<span class="fc" id="L442">                    quat[2] = inv.multiply(ort[2][1].add(ort[1][2]));</span>
                }
            }
        }

<span class="fc" id="L447">        return quat;</span>

    }

    /** Revert a rotation.
     * Build a rotation which reverse the effect of another
     * rotation. This means that if r(u) = v, then r.revert(v) = u. The
     * instance is not changed.
     * @return a new rotation whose effect is the reverse of the effect
     * of the instance
     */
    public FieldRotation&lt;T&gt; revert() {
<span class="fc" id="L459">        return new FieldRotation&lt;&gt;(q0.negate(), q1, q2, q3, false);</span>
    }

    /** Get the scalar coordinate of the quaternion.
     * @return scalar coordinate of the quaternion
     */
    public T getQ0() {
<span class="fc" id="L466">        return q0;</span>
    }

    /** Get the first coordinate of the vectorial part of the quaternion.
     * @return first coordinate of the vectorial part of the quaternion
     */
    public T getQ1() {
<span class="fc" id="L473">        return q1;</span>
    }

    /** Get the second coordinate of the vectorial part of the quaternion.
     * @return second coordinate of the vectorial part of the quaternion
     */
    public T getQ2() {
<span class="fc" id="L480">        return q2;</span>
    }

    /** Get the third coordinate of the vectorial part of the quaternion.
     * @return third coordinate of the vectorial part of the quaternion
     */
    public T getQ3() {
<span class="fc" id="L487">        return q3;</span>
    }

    /** Get the normalized axis of the rotation.
     * @return normalized axis of the rotation
     * @see #FieldRotation(FieldVector3D, RealFieldElement)
     * @deprecated as of 3.6, replaced with {@link #getAxis(RotationConvention)}
     */
    @Deprecated
    public FieldVector3D&lt;T&gt; getAxis() {
<span class="fc" id="L497">        return getAxis(RotationConvention.VECTOR_OPERATOR);</span>
    }

    /** Get the normalized axis of the rotation.
     * &lt;p&gt;
     * Note that as {@link #getAngle()} always returns an angle
     * between 0 and &amp;pi;, changing the convention changes the
     * direction of the axis, not the sign of the angle.
     * &lt;/p&gt;
     * @param convention convention to use for the semantics of the angle
     * @return normalized axis of the rotation
     * @see #FieldRotation(FieldVector3D, RealFieldElement)
     * @since 3.6
     */
    public FieldVector3D&lt;T&gt; getAxis(final RotationConvention convention) {
<span class="fc" id="L512">        final T squaredSine = q1.multiply(q1).add(q2.multiply(q2)).add(q3.multiply(q3));</span>
<span class="fc bfc" id="L513" title="All 2 branches covered.">        if (squaredSine.getReal() == 0) {</span>
<span class="fc" id="L514">            final Field&lt;T&gt; field = squaredSine.getField();</span>
<span class="fc bfc" id="L515" title="All 2 branches covered.">            return new FieldVector3D&lt;&gt;(convention == RotationConvention.VECTOR_OPERATOR ? field.getOne(): field.getOne().negate(),</span>
<span class="fc" id="L516">                                        field.getZero(),</span>
<span class="fc" id="L517">                                        field.getZero());</span>
        } else {
<span class="fc bfc" id="L519" title="All 2 branches covered.">            final double sgn = convention == RotationConvention.VECTOR_OPERATOR ? +1 : -1;</span>
<span class="fc bfc" id="L520" title="All 2 branches covered.">            if (q0.getReal() &lt; 0) {</span>
<span class="fc" id="L521">                T inverse = squaredSine.sqrt().reciprocal().multiply(sgn);</span>
<span class="fc" id="L522">                return new FieldVector3D&lt;&gt;(q1.multiply(inverse), q2.multiply(inverse), q3.multiply(inverse));</span>
            }
<span class="fc" id="L524">            final T inverse = squaredSine.sqrt().reciprocal().negate().multiply(sgn);</span>
<span class="fc" id="L525">            return new FieldVector3D&lt;&gt;(q1.multiply(inverse), q2.multiply(inverse), q3.multiply(inverse));</span>
        }
    }

    /** Get the angle of the rotation.
     * @return angle of the rotation (between 0 and &amp;pi;)
     * @see #FieldRotation(FieldVector3D, RealFieldElement)
     */
    public T getAngle() {
<span class="fc bfc" id="L534" title="All 4 branches covered.">        if ((q0.getReal() &lt; -0.1) || (q0.getReal() &gt; 0.1)) {</span>
<span class="fc" id="L535">            return q1.multiply(q1).add(q2.multiply(q2)).add(q3.multiply(q3)).sqrt().asin().multiply(2);</span>
<span class="fc bfc" id="L536" title="All 2 branches covered.">        } else if (q0.getReal() &lt; 0) {</span>
<span class="fc" id="L537">            return q0.negate().acos().multiply(2);</span>
        }
<span class="fc" id="L539">        return q0.acos().multiply(2);</span>
    }

    /** Get the Cardan or Euler angles corresponding to the instance.

     * &lt;p&gt;The equations show that each rotation can be defined by two
     * different values of the Cardan or Euler angles set. For example
     * if Cardan angles are used, the rotation defined by the angles
     * a&lt;sub&gt;1&lt;/sub&gt;, a&lt;sub&gt;2&lt;/sub&gt; and a&lt;sub&gt;3&lt;/sub&gt; is the same as
     * the rotation defined by the angles &amp;pi; + a&lt;sub&gt;1&lt;/sub&gt;, &amp;pi;
     * - a&lt;sub&gt;2&lt;/sub&gt; and &amp;pi; + a&lt;sub&gt;3&lt;/sub&gt;. This method implements
     * the following arbitrary choices:&lt;/p&gt;
     * &lt;ul&gt;
     *   &lt;li&gt;for Cardan angles, the chosen set is the one for which the
     *   second angle is between -&amp;pi;/2 and &amp;pi;/2 (i.e its cosine is
     *   positive),&lt;/li&gt;
     *   &lt;li&gt;for Euler angles, the chosen set is the one for which the
     *   second angle is between 0 and &amp;pi; (i.e its sine is positive).&lt;/li&gt;
     * &lt;/ul&gt;

     * &lt;p&gt;Cardan and Euler angle have a very disappointing drawback: all
     * of them have singularities. This means that if the instance is
     * too close to the singularities corresponding to the given
     * rotation order, it will be impossible to retrieve the angles. For
     * Cardan angles, this is often called gimbal lock. There is
     * &lt;em&gt;nothing&lt;/em&gt; to do to prevent this, it is an intrinsic problem
     * with Cardan and Euler representation (but not a problem with the
     * rotation itself, which is perfectly well defined). For Cardan
     * angles, singularities occur when the second angle is close to
     * -&amp;pi;/2 or +&amp;pi;/2, for Euler angle singularities occur when the
     * second angle is close to 0 or &amp;pi;, this implies that the identity
     * rotation is always singular for Euler angles!&lt;/p&gt;

     * @param order rotation order to use
     * @return an array of three angles, in the order specified by the set
     * @exception CardanEulerSingularityException if the rotation is
     * singular with respect to the angles set specified
     * @deprecated as of 3.6, replaced with {@link #getAngles(RotationOrder, RotationConvention)}
     */
    @Deprecated
    public T[] getAngles(final RotationOrder order)
        throws CardanEulerSingularityException {
<span class="fc" id="L581">        return getAngles(order, RotationConvention.VECTOR_OPERATOR);</span>
    }

    /** Get the Cardan or Euler angles corresponding to the instance.

     * &lt;p&gt;The equations show that each rotation can be defined by two
     * different values of the Cardan or Euler angles set. For example
     * if Cardan angles are used, the rotation defined by the angles
     * a&lt;sub&gt;1&lt;/sub&gt;, a&lt;sub&gt;2&lt;/sub&gt; and a&lt;sub&gt;3&lt;/sub&gt; is the same as
     * the rotation defined by the angles &amp;pi; + a&lt;sub&gt;1&lt;/sub&gt;, &amp;pi;
     * - a&lt;sub&gt;2&lt;/sub&gt; and &amp;pi; + a&lt;sub&gt;3&lt;/sub&gt;. This method implements
     * the following arbitrary choices:&lt;/p&gt;
     * &lt;ul&gt;
     *   &lt;li&gt;for Cardan angles, the chosen set is the one for which the
     *   second angle is between -&amp;pi;/2 and &amp;pi;/2 (i.e its cosine is
     *   positive),&lt;/li&gt;
     *   &lt;li&gt;for Euler angles, the chosen set is the one for which the
     *   second angle is between 0 and &amp;pi; (i.e its sine is positive).&lt;/li&gt;
     * &lt;/ul&gt;

     * &lt;p&gt;Cardan and Euler angle have a very disappointing drawback: all
     * of them have singularities. This means that if the instance is
     * too close to the singularities corresponding to the given
     * rotation order, it will be impossible to retrieve the angles. For
     * Cardan angles, this is often called gimbal lock. There is
     * &lt;em&gt;nothing&lt;/em&gt; to do to prevent this, it is an intrinsic problem
     * with Cardan and Euler representation (but not a problem with the
     * rotation itself, which is perfectly well defined). For Cardan
     * angles, singularities occur when the second angle is close to
     * -&amp;pi;/2 or +&amp;pi;/2, for Euler angle singularities occur when the
     * second angle is close to 0 or &amp;pi;, this implies that the identity
     * rotation is always singular for Euler angles!&lt;/p&gt;

     * @param order rotation order to use
     * @param convention convention to use for the semantics of the angle
     * @return an array of three angles, in the order specified by the set
     * @exception CardanEulerSingularityException if the rotation is
     * singular with respect to the angles set specified
     * @since 3.6
     */
    public T[] getAngles(final RotationOrder order, RotationConvention convention)
        throws CardanEulerSingularityException {

<span class="fc bfc" id="L624" title="All 2 branches covered.">        if (convention == RotationConvention.VECTOR_OPERATOR) {</span>
<span class="fc bfc" id="L625" title="All 2 branches covered.">            if (order == RotationOrder.XYZ) {</span>

                // r (+K) coordinates are :
                //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
                // (-r) (+I) coordinates are :
                // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
                final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
<span class="fc" id="L632">                FieldVector3D&lt;T&gt; v1 = applyTo(vector(0, 0, 1));</span>
<span class="fc" id="L633">                final FieldVector3D&lt;T&gt; v2 = applyInverseTo(vector(1, 0, 0));</span>
<span class="fc bfc" id="L634" title="All 4 branches covered.">                if  ((v2.getZ().getReal() &lt; -0.9999999999) || (v2.getZ().getReal() &gt; 0.9999999999)) {</span>
<span class="fc" id="L635">                    throw new CardanEulerSingularityException(true);</span>
                }
<span class="fc" id="L637">                return buildArray(v1.getY().negate().atan2(v1.getZ()),</span>
<span class="fc" id="L638">                                  v2.getZ().asin(),</span>
<span class="fc" id="L639">                                  v2.getY().negate().atan2(v2.getX()));</span>

<span class="fc bfc" id="L641" title="All 2 branches covered.">            } else if (order == RotationOrder.XZY) {</span>

                // r (+J) coordinates are :
                // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
                // (-r) (+I) coordinates are :
                // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
<span class="fc" id="L648">                final FieldVector3D&lt;T&gt; v1 = applyTo(vector(0, 1, 0));</span>
<span class="fc" id="L649">                final FieldVector3D&lt;T&gt; v2 = applyInverseTo(vector(1, 0, 0));</span>
<span class="fc bfc" id="L650" title="All 4 branches covered.">                if ((v2.getY().getReal() &lt; -0.9999999999) || (v2.getY().getReal() &gt; 0.9999999999)) {</span>
<span class="fc" id="L651">                    throw new CardanEulerSingularityException(true);</span>
                }
<span class="fc" id="L653">                return buildArray(v1.getZ().atan2(v1.getY()),</span>
<span class="fc" id="L654">                                  v2.getY().asin().negate(),</span>
<span class="fc" id="L655">                                  v2.getZ().atan2(v2.getX()));</span>

<span class="fc bfc" id="L657" title="All 2 branches covered.">            } else if (order == RotationOrder.YXZ) {</span>

                // r (+K) coordinates are :
                //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
                // (-r) (+J) coordinates are :
                // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
<span class="fc" id="L664">                final FieldVector3D&lt;T&gt; v1 = applyTo(vector(0, 0, 1));</span>
<span class="fc" id="L665">                final FieldVector3D&lt;T&gt; v2 = applyInverseTo(vector(0, 1, 0));</span>
<span class="fc bfc" id="L666" title="All 4 branches covered.">                if ((v2.getZ().getReal() &lt; -0.9999999999) || (v2.getZ().getReal() &gt; 0.9999999999)) {</span>
<span class="fc" id="L667">                    throw new CardanEulerSingularityException(true);</span>
                }
<span class="fc" id="L669">                return buildArray(v1.getX().atan2(v1.getZ()),</span>
<span class="fc" id="L670">                                  v2.getZ().asin().negate(),</span>
<span class="fc" id="L671">                                  v2.getX().atan2(v2.getY()));</span>

<span class="fc bfc" id="L673" title="All 2 branches covered.">            } else if (order == RotationOrder.YZX) {</span>

                // r (+I) coordinates are :
                // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
                // (-r) (+J) coordinates are :
                // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
<span class="fc" id="L680">                final FieldVector3D&lt;T&gt; v1 = applyTo(vector(1, 0, 0));</span>
<span class="fc" id="L681">                final FieldVector3D&lt;T&gt; v2 = applyInverseTo(vector(0, 1, 0));</span>
<span class="fc bfc" id="L682" title="All 4 branches covered.">                if ((v2.getX().getReal() &lt; -0.9999999999) || (v2.getX().getReal() &gt; 0.9999999999)) {</span>
<span class="fc" id="L683">                    throw new CardanEulerSingularityException(true);</span>
                }
<span class="fc" id="L685">                return buildArray(v1.getZ().negate().atan2(v1.getX()),</span>
<span class="fc" id="L686">                                  v2.getX().asin(),</span>
<span class="fc" id="L687">                                  v2.getZ().negate().atan2(v2.getY()));</span>

<span class="fc bfc" id="L689" title="All 2 branches covered.">            } else if (order == RotationOrder.ZXY) {</span>

                // r (+J) coordinates are :
                // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
                // (-r) (+K) coordinates are :
                // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
<span class="fc" id="L696">                final FieldVector3D&lt;T&gt; v1 = applyTo(vector(0, 1, 0));</span>
<span class="fc" id="L697">                final FieldVector3D&lt;T&gt; v2 = applyInverseTo(vector(0, 0, 1));</span>
<span class="fc bfc" id="L698" title="All 4 branches covered.">                if ((v2.getY().getReal() &lt; -0.9999999999) || (v2.getY().getReal() &gt; 0.9999999999)) {</span>
<span class="fc" id="L699">                    throw new CardanEulerSingularityException(true);</span>
                }
<span class="fc" id="L701">                return buildArray(v1.getX().negate().atan2(v1.getY()),</span>
<span class="fc" id="L702">                                  v2.getY().asin(),</span>
<span class="fc" id="L703">                                  v2.getX().negate().atan2(v2.getZ()));</span>

<span class="fc bfc" id="L705" title="All 2 branches covered.">            } else if (order == RotationOrder.ZYX) {</span>

                // r (+I) coordinates are :
                //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
                // (-r) (+K) coordinates are :
                // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
                // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
<span class="fc" id="L712">                final FieldVector3D&lt;T&gt; v1 = applyTo(vector(1, 0, 0));</span>
<span class="fc" id="L713">                final FieldVector3D&lt;T&gt; v2 = applyInverseTo(vector(0, 0, 1));</span>
<span class="fc bfc" id="L714" title="All 4 branches covered.">                if ((v2.getX().getReal() &lt; -0.9999999999) || (v2.getX().getReal() &gt; 0.9999999999)) {</span>
<span class="fc" id="L715">                    throw new CardanEulerSingularityException(true);</span>
                }
<span class="fc" id="L717">                return buildArray(v1.getY().atan2(v1.getX()),</span>
<span class="fc" id="L718">                                  v2.getX().asin().negate(),</span>
<span class="fc" id="L719">                                  v2.getY().atan2(v2.getZ()));</span>

<span class="fc bfc" id="L721" title="All 2 branches covered.">            } else if (order == RotationOrder.XYX) {</span>

                // r (+I) coordinates are :
                //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
                // (-r) (+I) coordinates are :
                // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
                // and we can choose to have theta in the interval [0 ; PI]
<span class="fc" id="L728">                final FieldVector3D&lt;T&gt; v1 = applyTo(vector(1, 0, 0));</span>
<span class="fc" id="L729">                final FieldVector3D&lt;T&gt; v2 = applyInverseTo(vector(1, 0, 0));</span>
<span class="fc bfc" id="L730" title="All 4 branches covered.">                if ((v2.getX().getReal() &lt; -0.9999999999) || (v2.getX().getReal() &gt; 0.9999999999)) {</span>
<span class="fc" id="L731">                    throw new CardanEulerSingularityException(false);</span>
                }
<span class="fc" id="L733">                return buildArray(v1.getY().atan2(v1.getZ().negate()),</span>
<span class="fc" id="L734">                                  v2.getX().acos(),</span>
<span class="fc" id="L735">                                  v2.getY().atan2(v2.getZ()));</span>

<span class="fc bfc" id="L737" title="All 2 branches covered.">            } else if (order == RotationOrder.XZX) {</span>

                // r (+I) coordinates are :
                //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
                // (-r) (+I) coordinates are :
                // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
                // and we can choose to have psi in the interval [0 ; PI]
<span class="fc" id="L744">                final FieldVector3D&lt;T&gt; v1 = applyTo(vector(1, 0, 0));</span>
<span class="fc" id="L745">                final FieldVector3D&lt;T&gt; v2 = applyInverseTo(vector(1, 0, 0));</span>
<span class="fc bfc" id="L746" title="All 4 branches covered.">                if ((v2.getX().getReal() &lt; -0.9999999999) || (v2.getX().getReal() &gt; 0.9999999999)) {</span>
<span class="fc" id="L747">                    throw new CardanEulerSingularityException(false);</span>
                }
<span class="fc" id="L749">                return buildArray(v1.getZ().atan2(v1.getY()),</span>
<span class="fc" id="L750">                                  v2.getX().acos(),</span>
<span class="fc" id="L751">                                  v2.getZ().atan2(v2.getY().negate()));</span>

<span class="fc bfc" id="L753" title="All 2 branches covered.">            } else if (order == RotationOrder.YXY) {</span>

                // r (+J) coordinates are :
                //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
                // (-r) (+J) coordinates are :
                // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
                // and we can choose to have phi in the interval [0 ; PI]
<span class="fc" id="L760">                final FieldVector3D&lt;T&gt; v1 = applyTo(vector(0, 1, 0));</span>
<span class="fc" id="L761">                final FieldVector3D&lt;T&gt; v2 = applyInverseTo(vector(0, 1, 0));</span>
<span class="fc bfc" id="L762" title="All 4 branches covered.">                if ((v2.getY().getReal() &lt; -0.9999999999) || (v2.getY().getReal() &gt; 0.9999999999)) {</span>
<span class="fc" id="L763">                    throw new CardanEulerSingularityException(false);</span>
                }
<span class="fc" id="L765">                return buildArray(v1.getX().atan2(v1.getZ()),</span>
<span class="fc" id="L766">                                  v2.getY().acos(),</span>
<span class="fc" id="L767">                                  v2.getX().atan2(v2.getZ().negate()));</span>

<span class="fc bfc" id="L769" title="All 2 branches covered.">            } else if (order == RotationOrder.YZY) {</span>

                // r (+J) coordinates are :
                //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
                // (-r) (+J) coordinates are :
                // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
                // and we can choose to have psi in the interval [0 ; PI]
<span class="fc" id="L776">                final FieldVector3D&lt;T&gt; v1 = applyTo(vector(0, 1, 0));</span>
<span class="fc" id="L777">                final FieldVector3D&lt;T&gt; v2 = applyInverseTo(vector(0, 1, 0));</span>
<span class="fc bfc" id="L778" title="All 4 branches covered.">                if ((v2.getY().getReal() &lt; -0.9999999999) || (v2.getY().getReal() &gt; 0.9999999999)) {</span>
<span class="fc" id="L779">                    throw new CardanEulerSingularityException(false);</span>
                }
<span class="fc" id="L781">                return buildArray(v1.getZ().atan2(v1.getX().negate()),</span>
<span class="fc" id="L782">                                  v2.getY().acos(),</span>
<span class="fc" id="L783">                                  v2.getZ().atan2(v2.getX()));</span>

<span class="fc bfc" id="L785" title="All 2 branches covered.">            } else if (order == RotationOrder.ZXZ) {</span>

                // r (+K) coordinates are :
                //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
                // (-r) (+K) coordinates are :
                // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
                // and we can choose to have phi in the interval [0 ; PI]
<span class="fc" id="L792">                final FieldVector3D&lt;T&gt; v1 = applyTo(vector(0, 0, 1));</span>
<span class="fc" id="L793">                final FieldVector3D&lt;T&gt; v2 = applyInverseTo(vector(0, 0, 1));</span>
<span class="fc bfc" id="L794" title="All 4 branches covered.">                if ((v2.getZ().getReal() &lt; -0.9999999999) || (v2.getZ().getReal() &gt; 0.9999999999)) {</span>
<span class="fc" id="L795">                    throw new CardanEulerSingularityException(false);</span>
                }
<span class="fc" id="L797">                return buildArray(v1.getX().atan2(v1.getY().negate()),</span>
<span class="fc" id="L798">                                  v2.getZ().acos(),</span>
<span class="fc" id="L799">                                  v2.getX().atan2(v2.getY()));</span>

            } else { // last possibility is ZYZ

                // r (+K) coordinates are :
                //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
                // (-r) (+K) coordinates are :
                // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
                // and we can choose to have theta in the interval [0 ; PI]
<span class="fc" id="L808">                final FieldVector3D&lt;T&gt; v1 = applyTo(vector(0, 0, 1));</span>
<span class="fc" id="L809">                final FieldVector3D&lt;T&gt; v2 = applyInverseTo(vector(0, 0, 1));</span>
<span class="fc bfc" id="L810" title="All 4 branches covered.">                if ((v2.getZ().getReal() &lt; -0.9999999999) || (v2.getZ().getReal() &gt; 0.9999999999)) {</span>
<span class="fc" id="L811">                    throw new CardanEulerSingularityException(false);</span>
                }
<span class="fc" id="L813">                return buildArray(v1.getY().atan2(v1.getX()),</span>
<span class="fc" id="L814">                                  v2.getZ().acos(),</span>
<span class="fc" id="L815">                                  v2.getY().atan2(v2.getX().negate()));</span>

            }
        } else {
<span class="fc bfc" id="L819" title="All 2 branches covered.">            if (order == RotationOrder.XYZ) {</span>

                // r (Cartesian3D.plusI) coordinates are :
                //  cos (theta) cos (psi), -cos (theta) sin (psi), sin (theta)
                // (-r) (Cartesian3D.plusK) coordinates are :
                // sin (theta), -sin (phi) cos (theta), cos (phi) cos (theta)
                // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
<span class="fc" id="L826">                FieldVector3D&lt;T&gt; v1 = applyTo(Vector3D.Unit.PLUS_X);</span>
<span class="fc" id="L827">                FieldVector3D&lt;T&gt; v2 = applyInverseTo(Vector3D.Unit.PLUS_Z);</span>
<span class="fc bfc" id="L828" title="All 4 branches covered.">                if ((v2.getX().getReal() &lt; -0.9999999999) || (v2.getX().getReal() &gt; 0.9999999999)) {</span>
<span class="fc" id="L829">                    throw new CardanEulerSingularityException(true);</span>
                }
<span class="fc" id="L831">                return buildArray(v2.getY().negate().atan2(v2.getZ()),</span>
<span class="fc" id="L832">                                  v2.getX().asin(),</span>
<span class="fc" id="L833">                                  v1.getY().negate().atan2(v1.getX()));</span>

<span class="fc bfc" id="L835" title="All 2 branches covered.">            } else if (order == RotationOrder.XZY) {</span>

                // r (Cartesian3D.plusI) coordinates are :
                // cos (psi) cos (theta), -sin (psi), cos (psi) sin (theta)
                // (-r) (Cartesian3D.plusJ) coordinates are :
                // -sin (psi), cos (phi) cos (psi), sin (phi) cos (psi)
                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
<span class="fc" id="L842">                FieldVector3D&lt;T&gt; v1 = applyTo(Vector3D.Unit.PLUS_X);</span>
<span class="fc" id="L843">                FieldVector3D&lt;T&gt; v2 = applyInverseTo(Vector3D.Unit.PLUS_Y);</span>
<span class="fc bfc" id="L844" title="All 4 branches covered.">                if ((v2.getX().getReal() &lt; -0.9999999999) || (v2.getX().getReal() &gt; 0.9999999999)) {</span>
<span class="fc" id="L845">                    throw new CardanEulerSingularityException(true);</span>
                }
<span class="fc" id="L847">                return buildArray(v2.getZ().atan2(v2.getY()),</span>
<span class="fc" id="L848">                                  v2.getX().asin().negate(),</span>
<span class="fc" id="L849">                                  v1.getZ().atan2(v1.getX()));</span>

<span class="fc bfc" id="L851" title="All 2 branches covered.">            } else if (order == RotationOrder.YXZ) {</span>

                // r (Cartesian3D.plusJ) coordinates are :
                // cos (phi) sin (psi), cos (phi) cos (psi), -sin (phi)
                // (-r) (Cartesian3D.plusK) coordinates are :
                // sin (theta) cos (phi), -sin (phi), cos (theta) cos (phi)
                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
<span class="fc" id="L858">                FieldVector3D&lt;T&gt; v1 = applyTo(Vector3D.Unit.PLUS_Y);</span>
<span class="fc" id="L859">                FieldVector3D&lt;T&gt; v2 = applyInverseTo(Vector3D.Unit.PLUS_Z);</span>
<span class="fc bfc" id="L860" title="All 4 branches covered.">                if ((v2.getY().getReal() &lt; -0.9999999999) || (v2.getY().getReal() &gt; 0.9999999999)) {</span>
<span class="fc" id="L861">                    throw new CardanEulerSingularityException(true);</span>
                }
<span class="fc" id="L863">                return buildArray(v2.getX().atan2(v2.getZ()),</span>
<span class="fc" id="L864">                                  v2.getY().asin().negate(),</span>
<span class="fc" id="L865">                                  v1.getX().atan2(v1.getY()));</span>

<span class="fc bfc" id="L867" title="All 2 branches covered.">            } else if (order == RotationOrder.YZX) {</span>

                // r (Cartesian3D.plusJ) coordinates are :
                // sin (psi), cos (psi) cos (phi), -cos (psi) sin (phi)
                // (-r) (Cartesian3D.plusI) coordinates are :
                // cos (theta) cos (psi), sin (psi), -sin (theta) cos (psi)
                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
<span class="fc" id="L874">                FieldVector3D&lt;T&gt; v1 = applyTo(Vector3D.Unit.PLUS_Y);</span>
<span class="fc" id="L875">                FieldVector3D&lt;T&gt; v2 = applyInverseTo(Vector3D.Unit.PLUS_X);</span>
<span class="fc bfc" id="L876" title="All 4 branches covered.">                if ((v2.getY().getReal() &lt; -0.9999999999) || (v2.getY().getReal() &gt; 0.9999999999)) {</span>
<span class="fc" id="L877">                    throw new CardanEulerSingularityException(true);</span>
                }
<span class="fc" id="L879">                return buildArray(v2.getZ().negate().atan2(v2.getX()),</span>
<span class="fc" id="L880">                                  v2.getY().asin(),</span>
<span class="fc" id="L881">                                  v1.getZ().negate().atan2(v1.getY()));</span>

<span class="fc bfc" id="L883" title="All 2 branches covered.">            } else if (order == RotationOrder.ZXY) {</span>

                // r (Cartesian3D.plusK) coordinates are :
                //  -cos (phi) sin (theta), sin (phi), cos (phi) cos (theta)
                // (-r) (Cartesian3D.plusJ) coordinates are :
                // -sin (psi) cos (phi), cos (psi) cos (phi), sin (phi)
                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
<span class="fc" id="L890">                FieldVector3D&lt;T&gt; v1 = applyTo(Vector3D.Unit.PLUS_Z);</span>
<span class="fc" id="L891">                FieldVector3D&lt;T&gt; v2 = applyInverseTo(Vector3D.Unit.PLUS_Y);</span>
<span class="fc bfc" id="L892" title="All 4 branches covered.">                if ((v2.getZ().getReal() &lt; -0.9999999999) || (v2.getZ().getReal() &gt; 0.9999999999)) {</span>
<span class="fc" id="L893">                    throw new CardanEulerSingularityException(true);</span>
                }
<span class="fc" id="L895">                return buildArray(v2.getX().negate().atan2(v2.getY()),</span>
<span class="fc" id="L896">                                  v2.getZ().asin(),</span>
<span class="fc" id="L897">                                  v1.getX().negate().atan2(v1.getZ()));</span>

<span class="fc bfc" id="L899" title="All 2 branches covered.">            } else if (order == RotationOrder.ZYX) {</span>

                // r (Cartesian3D.plusK) coordinates are :
                //  -sin (theta), cos (theta) sin (phi), cos (theta) cos (phi)
                // (-r) (Cartesian3D.plusI) coordinates are :
                // cos (psi) cos (theta), sin (psi) cos (theta), -sin (theta)
                // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
<span class="fc" id="L906">                FieldVector3D&lt;T&gt; v1 = applyTo(Vector3D.Unit.PLUS_Z);</span>
<span class="fc" id="L907">                FieldVector3D&lt;T&gt; v2 = applyInverseTo(Vector3D.Unit.PLUS_X);</span>
<span class="fc bfc" id="L908" title="All 4 branches covered.">                if  ((v2.getZ().getReal() &lt; -0.9999999999) || (v2.getZ().getReal() &gt; 0.9999999999)) {</span>
<span class="fc" id="L909">                    throw new CardanEulerSingularityException(true);</span>
                }
<span class="fc" id="L911">                return buildArray(v2.getY().atan2(v2.getX()),</span>
<span class="fc" id="L912">                                  v2.getZ().asin().negate(),</span>
<span class="fc" id="L913">                                  v1.getY().atan2(v1.getZ()));</span>

<span class="fc bfc" id="L915" title="All 2 branches covered.">            } else if (order == RotationOrder.XYX) {</span>

                // r (Cartesian3D.plusI) coordinates are :
                //  cos (theta), sin (phi2) sin (theta), cos (phi2) sin (theta)
                // (-r) (Cartesian3D.plusI) coordinates are :
                // cos (theta), sin (theta) sin (phi1), -sin (theta) cos (phi1)
                // and we can choose to have theta in the interval [0 ; PI]
<span class="fc" id="L922">                FieldVector3D&lt;T&gt; v1 = applyTo(Vector3D.Unit.PLUS_X);</span>
<span class="fc" id="L923">                FieldVector3D&lt;T&gt; v2 = applyInverseTo(Vector3D.Unit.PLUS_X);</span>
<span class="fc bfc" id="L924" title="All 4 branches covered.">                if ((v2.getX().getReal() &lt; -0.9999999999) || (v2.getX().getReal() &gt; 0.9999999999)) {</span>
<span class="fc" id="L925">                    throw new CardanEulerSingularityException(false);</span>
                }
<span class="fc" id="L927">                return buildArray(v2.getY().atan2(v2.getZ().negate()),</span>
<span class="fc" id="L928">                                  v2.getX().acos(),</span>
<span class="fc" id="L929">                                  v1.getY().atan2(v1.getZ()));</span>

<span class="fc bfc" id="L931" title="All 2 branches covered.">            } else if (order == RotationOrder.XZX) {</span>

                // r (Cartesian3D.plusI) coordinates are :
                //  cos (psi), -cos (phi2) sin (psi), sin (phi2) sin (psi)
                // (-r) (Cartesian3D.plusI) coordinates are :
                // cos (psi), sin (psi) cos (phi1), sin (psi) sin (phi1)
                // and we can choose to have psi in the interval [0 ; PI]
<span class="fc" id="L938">                FieldVector3D&lt;T&gt; v1 = applyTo(Vector3D.Unit.PLUS_X);</span>
<span class="fc" id="L939">                FieldVector3D&lt;T&gt; v2 = applyInverseTo(Vector3D.Unit.PLUS_X);</span>
<span class="fc bfc" id="L940" title="All 4 branches covered.">                if ((v2.getX().getReal() &lt; -0.9999999999) || (v2.getX().getReal() &gt; 0.9999999999)) {</span>
<span class="fc" id="L941">                    throw new CardanEulerSingularityException(false);</span>
                }
<span class="fc" id="L943">                return buildArray(v2.getZ().atan2(v2.getY()),</span>
<span class="fc" id="L944">                                  v2.getX().acos(),</span>
<span class="fc" id="L945">                                  v1.getZ().atan2(v1.getY().negate()));</span>

<span class="fc bfc" id="L947" title="All 2 branches covered.">            } else if (order == RotationOrder.YXY) {</span>

                // r (Cartesian3D.plusJ) coordinates are :
                // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
                // (-r) (Cartesian3D.plusJ) coordinates are :
                //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
                // and we can choose to have phi in the interval [0 ; PI]
<span class="fc" id="L954">                FieldVector3D&lt;T&gt; v1 = applyTo(Vector3D.Unit.PLUS_Y);</span>
<span class="fc" id="L955">                FieldVector3D&lt;T&gt; v2 = applyInverseTo(Vector3D.Unit.PLUS_Y);</span>
<span class="fc bfc" id="L956" title="All 4 branches covered.">                if ((v2.getY().getReal() &lt; -0.9999999999) || (v2.getY().getReal() &gt; 0.9999999999)) {</span>
<span class="fc" id="L957">                    throw new CardanEulerSingularityException(false);</span>
                }
<span class="fc" id="L959">                return buildArray(v2.getX().atan2(v2.getZ()),</span>
<span class="fc" id="L960">                                  v2.getY().acos(),</span>
<span class="fc" id="L961">                                  v1.getX().atan2(v1.getZ().negate()));</span>

<span class="fc bfc" id="L963" title="All 2 branches covered.">            } else if (order == RotationOrder.YZY) {</span>

                // r (Cartesian3D.plusJ) coordinates are :
                // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
                // (-r) (Cartesian3D.plusJ) coordinates are :
                //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
                // and we can choose to have psi in the interval [0 ; PI]
<span class="fc" id="L970">                FieldVector3D&lt;T&gt; v1 = applyTo(Vector3D.Unit.PLUS_Y);</span>
<span class="fc" id="L971">                FieldVector3D&lt;T&gt; v2 = applyInverseTo(Vector3D.Unit.PLUS_Y);</span>
<span class="fc bfc" id="L972" title="All 4 branches covered.">                if ((v2.getY().getReal() &lt; -0.9999999999) || (v2.getY().getReal() &gt; 0.9999999999)) {</span>
<span class="fc" id="L973">                    throw new CardanEulerSingularityException(false);</span>
                }
<span class="fc" id="L975">                return buildArray(v2.getZ().atan2(v2.getX().negate()),</span>
<span class="fc" id="L976">                                  v2.getY().acos(),</span>
<span class="fc" id="L977">                                  v1.getZ().atan2(v1.getX()));</span>

<span class="fc bfc" id="L979" title="All 2 branches covered.">            } else if (order == RotationOrder.ZXZ) {</span>

                // r (Cartesian3D.plusK) coordinates are :
                // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
                // (-r) (Cartesian3D.plusK) coordinates are :
                //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
                // and we can choose to have phi in the interval [0 ; PI]
<span class="fc" id="L986">                FieldVector3D&lt;T&gt; v1 = applyTo(Vector3D.Unit.PLUS_Z);</span>
<span class="fc" id="L987">                FieldVector3D&lt;T&gt; v2 = applyInverseTo(Vector3D.Unit.PLUS_Z);</span>
<span class="fc bfc" id="L988" title="All 4 branches covered.">                if ((v2.getZ().getReal() &lt; -0.9999999999) || (v2.getZ().getReal() &gt; 0.9999999999)) {</span>
<span class="fc" id="L989">                    throw new CardanEulerSingularityException(false);</span>
                }
<span class="fc" id="L991">                return buildArray(v2.getX().atan2(v2.getY().negate()),</span>
<span class="fc" id="L992">                                  v2.getZ().acos(),</span>
<span class="fc" id="L993">                                  v1.getX().atan2(v1.getY()));</span>

            } else { // last possibility is ZYZ

                // r (Cartesian3D.plusK) coordinates are :
                // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
                // (-r) (Cartesian3D.plusK) coordinates are :
                //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
                // and we can choose to have theta in the interval [0 ; PI]
<span class="fc" id="L1002">                FieldVector3D&lt;T&gt; v1 = applyTo(Vector3D.Unit.PLUS_Z);</span>
<span class="fc" id="L1003">                FieldVector3D&lt;T&gt; v2 = applyInverseTo(Vector3D.Unit.PLUS_Z);</span>
<span class="fc bfc" id="L1004" title="All 4 branches covered.">                if ((v2.getZ().getReal() &lt; -0.9999999999) || (v2.getZ().getReal() &gt; 0.9999999999)) {</span>
<span class="fc" id="L1005">                    throw new CardanEulerSingularityException(false);</span>
                }
<span class="fc" id="L1007">                return buildArray(v2.getY().atan2(v2.getX()),</span>
<span class="fc" id="L1008">                                  v2.getZ().acos(),</span>
<span class="fc" id="L1009">                                  v1.getY().atan2(v1.getX().negate()));</span>

            }
        }

    }

    /** Create a dimension 3 array.
     * @param a0 first array element
     * @param a1 second array element
     * @param a2 third array element
     * @return new array
     */
    private T[] buildArray(final T a0, final T a1, final T a2) {
<span class="fc" id="L1023">        final T[] array = MathArrays.buildArray(a0.getField(), 3);</span>
<span class="fc" id="L1024">        array[0] = a0;</span>
<span class="fc" id="L1025">        array[1] = a1;</span>
<span class="fc" id="L1026">        array[2] = a2;</span>
<span class="fc" id="L1027">        return array;</span>
    }

    /** Create a constant vector.
     * @param x abscissa
     * @param y ordinate
     * @param z height
     * @return a constant vector
     */
    private FieldVector3D&lt;T&gt; vector(final double x, final double y, final double z) {
<span class="fc" id="L1037">        final T zero = q0.getField().getZero();</span>
<span class="fc" id="L1038">        return new FieldVector3D&lt;&gt;(zero.add(x), zero.add(y), zero.add(z));</span>
    }

    /** Get the 3X3 matrix corresponding to the instance
     * @return the matrix corresponding to the instance
     */
    public T[][] getMatrix() {

        // products
<span class="fc" id="L1047">        final T q0q0  = q0.multiply(q0);</span>
<span class="fc" id="L1048">        final T q0q1  = q0.multiply(q1);</span>
<span class="fc" id="L1049">        final T q0q2  = q0.multiply(q2);</span>
<span class="fc" id="L1050">        final T q0q3  = q0.multiply(q3);</span>
<span class="fc" id="L1051">        final T q1q1  = q1.multiply(q1);</span>
<span class="fc" id="L1052">        final T q1q2  = q1.multiply(q2);</span>
<span class="fc" id="L1053">        final T q1q3  = q1.multiply(q3);</span>
<span class="fc" id="L1054">        final T q2q2  = q2.multiply(q2);</span>
<span class="fc" id="L1055">        final T q2q3  = q2.multiply(q3);</span>
<span class="fc" id="L1056">        final T q3q3  = q3.multiply(q3);</span>

        // create the matrix
<span class="fc" id="L1059">        final T[][] m = MathArrays.buildArray(q0.getField(), 3, 3);</span>

<span class="fc" id="L1061">        m [0][0] = q0q0.add(q1q1).multiply(2).subtract(1);</span>
<span class="fc" id="L1062">        m [1][0] = q1q2.subtract(q0q3).multiply(2);</span>
<span class="fc" id="L1063">        m [2][0] = q1q3.add(q0q2).multiply(2);</span>

<span class="fc" id="L1065">        m [0][1] = q1q2.add(q0q3).multiply(2);</span>
<span class="fc" id="L1066">        m [1][1] = q0q0.add(q2q2).multiply(2).subtract(1);</span>
<span class="fc" id="L1067">        m [2][1] = q2q3.subtract(q0q1).multiply(2);</span>

<span class="fc" id="L1069">        m [0][2] = q1q3.subtract(q0q2).multiply(2);</span>
<span class="fc" id="L1070">        m [1][2] = q2q3.add(q0q1).multiply(2);</span>
<span class="fc" id="L1071">        m [2][2] = q0q0.add(q3q3).multiply(2).subtract(1);</span>

<span class="fc" id="L1073">        return m;</span>

    }

    /** Convert to a constant vector without derivatives.
     * @return a constant vector
     */
    public QuaternionRotation toRotation() {
<span class="fc" id="L1081">        return QuaternionRotation.of(q0.getReal(), q1.getReal(), q2.getReal(), q3.getReal());</span>
    }

    /** Apply the rotation to a vector.
     * @param u vector to apply the rotation to
     * @return a new vector which is the image of u by the rotation
     */
    public FieldVector3D&lt;T&gt; applyTo(final FieldVector3D&lt;T&gt; u) {

<span class="fc" id="L1090">        final T x = u.getX();</span>
<span class="fc" id="L1091">        final T y = u.getY();</span>
<span class="fc" id="L1092">        final T z = u.getZ();</span>

<span class="fc" id="L1094">        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));</span>

<span class="fc" id="L1096">        return new FieldVector3D&lt;&gt;(q0.multiply(x.multiply(q0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),</span>
<span class="fc" id="L1097">                                    q0.multiply(y.multiply(q0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),</span>
<span class="fc" id="L1098">                                    q0.multiply(z.multiply(q0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));</span>

    }

    /** Apply the rotation to a vector.
     * @param u vector to apply the rotation to
     * @return a new vector which is the image of u by the rotation
     */
    public FieldVector3D&lt;T&gt; applyTo(final Vector3D u) {

<span class="fc" id="L1108">        final double x = u.getX();</span>
<span class="fc" id="L1109">        final double y = u.getY();</span>
<span class="fc" id="L1110">        final double z = u.getZ();</span>

<span class="fc" id="L1112">        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));</span>

<span class="fc" id="L1114">        return new FieldVector3D&lt;&gt;(q0.multiply(q0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),</span>
<span class="fc" id="L1115">                                    q0.multiply(q0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),</span>
<span class="fc" id="L1116">                                    q0.multiply(q0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));</span>

    }

    /** Apply the rotation to a vector stored in an array.
     * @param in an array with three items which stores vector to rotate
     * @param out an array with three items to put result to (it can be the same
     * array as in)
     */
    public void applyTo(final T[] in, final T[] out) {

<span class="fc" id="L1127">        final T x = in[0];</span>
<span class="fc" id="L1128">        final T y = in[1];</span>
<span class="fc" id="L1129">        final T z = in[2];</span>

<span class="fc" id="L1131">        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));</span>

<span class="fc" id="L1133">        out[0] = q0.multiply(x.multiply(q0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);</span>
<span class="fc" id="L1134">        out[1] = q0.multiply(y.multiply(q0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);</span>
<span class="fc" id="L1135">        out[2] = q0.multiply(z.multiply(q0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);</span>

<span class="fc" id="L1137">    }</span>

    /** Apply the rotation to a vector stored in an array.
     * @param in an array with three items which stores vector to rotate
     * @param out an array with three items to put result to
     */
    public void applyTo(final double[] in, final T[] out) {

<span class="fc" id="L1145">        final double x = in[0];</span>
<span class="fc" id="L1146">        final double y = in[1];</span>
<span class="fc" id="L1147">        final double z = in[2];</span>

<span class="fc" id="L1149">        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));</span>

<span class="fc" id="L1151">        out[0] = q0.multiply(q0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);</span>
<span class="fc" id="L1152">        out[1] = q0.multiply(q0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);</span>
<span class="fc" id="L1153">        out[2] = q0.multiply(q0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);</span>

<span class="fc" id="L1155">    }</span>

    /** Apply a rotation to a vector.
     * @param rot rotation to apply
     * @param u vector to apply the rotation to
     * @param &lt;T&gt; the type of the field elements
     * @return a new vector which is the image of u by the rotation
     */
    public static &lt;T extends RealFieldElement&lt;T&gt;&gt; FieldVector3D&lt;T&gt; applyTo(final QuaternionRotation rot, final FieldVector3D&lt;T&gt; u) {
<span class="fc" id="L1164">        final Quaternion r = rot.getQuaternion();</span>
<span class="fc" id="L1165">        final T x = u.getX();</span>
<span class="fc" id="L1166">        final T y = u.getY();</span>
<span class="fc" id="L1167">        final T z = u.getZ();</span>

<span class="fc" id="L1169">        final T s = x.multiply(r.getX()).add(y.multiply(r.getY())).add(z.multiply(r.getZ()));</span>

<span class="fc" id="L1171">        return new FieldVector3D&lt;&gt;(x.multiply(r.getW()).subtract(z.multiply(r.getY()).subtract(y.multiply(r.getZ()))).multiply(r.getW()).add(s.multiply(r.getX())).multiply(2).subtract(x),</span>
<span class="fc" id="L1172">                                    y.multiply(r.getW()).subtract(x.multiply(r.getZ()).subtract(z.multiply(r.getX()))).multiply(r.getW()).add(s.multiply(r.getY())).multiply(2).subtract(y),</span>
<span class="fc" id="L1173">                                    z.multiply(r.getW()).subtract(y.multiply(r.getX()).subtract(x.multiply(r.getY()))).multiply(r.getW()).add(s.multiply(r.getZ())).multiply(2).subtract(z));</span>

    }

    /** Apply the inverse of the rotation to a vector.
     * @param u vector to apply the inverse of the rotation to
     * @return a new vector which such that u is its image by the rotation
     */
    public FieldVector3D&lt;T&gt; applyInverseTo(final FieldVector3D&lt;T&gt; u) {

<span class="fc" id="L1183">        final T x = u.getX();</span>
<span class="fc" id="L1184">        final T y = u.getY();</span>
<span class="fc" id="L1185">        final T z = u.getZ();</span>

<span class="fc" id="L1187">        final T s  = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));</span>
<span class="fc" id="L1188">        final T m0 = q0.negate();</span>

<span class="fc" id="L1190">        return new FieldVector3D&lt;&gt;(m0.multiply(x.multiply(m0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),</span>
<span class="fc" id="L1191">                                    m0.multiply(y.multiply(m0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),</span>
<span class="fc" id="L1192">                                    m0.multiply(z.multiply(m0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));</span>

    }

    /** Apply the inverse of the rotation to a vector.
     * @param u vector to apply the inverse of the rotation to
     * @return a new vector which such that u is its image by the rotation
     */
    public FieldVector3D&lt;T&gt; applyInverseTo(final Vector3D u) {

<span class="fc" id="L1202">        final double x = u.getX();</span>
<span class="fc" id="L1203">        final double y = u.getY();</span>
<span class="fc" id="L1204">        final double z = u.getZ();</span>

<span class="fc" id="L1206">        final T s  = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));</span>
<span class="fc" id="L1207">        final T m0 = q0.negate();</span>

<span class="fc" id="L1209">        return new FieldVector3D&lt;&gt;(m0.multiply(m0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),</span>
<span class="fc" id="L1210">                                    m0.multiply(m0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),</span>
<span class="fc" id="L1211">                                    m0.multiply(m0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));</span>

    }

    /** Apply the inverse of the rotation to a vector stored in an array.
     * @param in an array with three items which stores vector to rotate
     * @param out an array with three items to put result to (it can be the same
     * array as in)
     */
    public void applyInverseTo(final T[] in, final T[] out) {

<span class="fc" id="L1222">        final T x = in[0];</span>
<span class="fc" id="L1223">        final T y = in[1];</span>
<span class="fc" id="L1224">        final T z = in[2];</span>

<span class="fc" id="L1226">        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));</span>
<span class="fc" id="L1227">        final T m0 = q0.negate();</span>

<span class="fc" id="L1229">        out[0] = m0.multiply(x.multiply(m0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);</span>
<span class="fc" id="L1230">        out[1] = m0.multiply(y.multiply(m0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);</span>
<span class="fc" id="L1231">        out[2] = m0.multiply(z.multiply(m0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);</span>

<span class="fc" id="L1233">    }</span>

    /** Apply the inverse of the rotation to a vector stored in an array.
     * @param in an array with three items which stores vector to rotate
     * @param out an array with three items to put result to
     */
    public void applyInverseTo(final double[] in, final T[] out) {

<span class="fc" id="L1241">        final double x = in[0];</span>
<span class="fc" id="L1242">        final double y = in[1];</span>
<span class="fc" id="L1243">        final double z = in[2];</span>

<span class="fc" id="L1245">        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));</span>
<span class="fc" id="L1246">        final T m0 = q0.negate();</span>

<span class="fc" id="L1248">        out[0] = m0.multiply(m0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);</span>
<span class="fc" id="L1249">        out[1] = m0.multiply(m0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);</span>
<span class="fc" id="L1250">        out[2] = m0.multiply(m0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);</span>

<span class="fc" id="L1252">    }</span>

    /** Apply the inverse of a rotation to a vector.
     * @param rot rotation to apply
     * @param u vector to apply the inverse of the rotation to
     * @param &lt;T&gt; the type of the field elements
     * @return a new vector which such that u is its image by the rotation
     */
    public static &lt;T extends RealFieldElement&lt;T&gt;&gt; FieldVector3D&lt;T&gt; applyInverseTo(final QuaternionRotation rot, final FieldVector3D&lt;T&gt; u) {
<span class="fc" id="L1261">        final Quaternion r = rot.getQuaternion();</span>
<span class="fc" id="L1262">        final T x = u.getX();</span>
<span class="fc" id="L1263">        final T y = u.getY();</span>
<span class="fc" id="L1264">        final T z = u.getZ();</span>

<span class="fc" id="L1266">        final T s  = x.multiply(r.getX()).add(y.multiply(r.getY())).add(z.multiply(r.getZ()));</span>
<span class="fc" id="L1267">        final double m0 = -r.getW();</span>

<span class="fc" id="L1269">        return new FieldVector3D&lt;&gt;(x.multiply(m0).subtract(z.multiply(r.getY()).subtract(y.multiply(r.getZ()))).multiply(m0).add(s.multiply(r.getX())).multiply(2).subtract(x),</span>
<span class="fc" id="L1270">                                    y.multiply(m0).subtract(x.multiply(r.getZ()).subtract(z.multiply(r.getX()))).multiply(m0).add(s.multiply(r.getY())).multiply(2).subtract(y),</span>
<span class="fc" id="L1271">                                    z.multiply(m0).subtract(y.multiply(r.getX()).subtract(x.multiply(r.getY()))).multiply(m0).add(s.multiply(r.getZ())).multiply(2).subtract(z));</span>

    }

    /** Apply the instance to another rotation.
     * &lt;p&gt;
     * Calling this method is equivalent to call
     * {@link #compose(FieldRotation, RotationConvention)
     * compose(r, RotationConvention.VECTOR_OPERATOR)}.
     * &lt;/p&gt;
     * @param r rotation to apply the rotation to
     * @return a new rotation which is the composition of r by the instance
     */
    public FieldRotation&lt;T&gt; applyTo(final FieldRotation&lt;T&gt; r) {
<span class="fc" id="L1285">        return compose(r, RotationConvention.VECTOR_OPERATOR);</span>
    }

    /** Compose the instance with another rotation.
     * &lt;p&gt;
     * If the semantics of the rotations composition corresponds to a
     * {@link RotationConvention#VECTOR_OPERATOR vector operator} convention,
     * applying the instance to a rotation is computing the composition
     * in an order compliant with the following rule : let {@code u} be any
     * vector and {@code v} its image by {@code r1} (i.e.
     * {@code r1.applyTo(u) = v}). Let {@code w} be the image of {@code v} by
     * rotation {@code r2} (i.e. {@code r2.applyTo(v) = w}). Then
     * {@code w = comp.applyTo(u)}, where
     * {@code comp = r2.compose(r1, RotationConvention.VECTOR_OPERATOR)}.
     * &lt;/p&gt;
     * &lt;p&gt;
     * If the semantics of the rotations composition corresponds to a
     * {@link RotationConvention#FRAME_TRANSFORM frame transform} convention,
     * the application order will be reversed. So keeping the exact same
     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}
     * and  {@code comp} as above, {@code comp} could also be computed as
     * {@code comp = r1.compose(r2, RotationConvention.FRAME_TRANSFORM)}.
     * &lt;/p&gt;
     * @param r rotation to apply the rotation to
     * @param convention convention to use for the semantics of the angle
     * @return a new rotation which is the composition of r by the instance
     */
    public FieldRotation&lt;T&gt; compose(final FieldRotation&lt;T&gt; r, final RotationConvention convention) {
<span class="fc bfc" id="L1313" title="All 2 branches covered.">        return convention == RotationConvention.VECTOR_OPERATOR ?</span>
<span class="fc" id="L1314">                             composeInternal(r) : r.composeInternal(this);</span>
    }

    /** Compose the instance with another rotation using vector operator convention.
     * @param r rotation to apply the rotation to
     * @return a new rotation which is the composition of r by the instance
     * using vector operator convention
     */
    private FieldRotation&lt;T&gt; composeInternal(final FieldRotation&lt;T&gt; r) {
<span class="fc" id="L1323">        return new FieldRotation&lt;&gt;(r.q0.multiply(q0).subtract(r.q1.multiply(q1).add(r.q2.multiply(q2)).add(r.q3.multiply(q3))),</span>
<span class="fc" id="L1324">                                    r.q1.multiply(q0).add(r.q0.multiply(q1)).add(r.q2.multiply(q3).subtract(r.q3.multiply(q2))),</span>
<span class="fc" id="L1325">                                    r.q2.multiply(q0).add(r.q0.multiply(q2)).add(r.q3.multiply(q1).subtract(r.q1.multiply(q3))),</span>
<span class="fc" id="L1326">                                    r.q3.multiply(q0).add(r.q0.multiply(q3)).add(r.q1.multiply(q2).subtract(r.q2.multiply(q1))),</span>
                                    false);
    }

    /** Apply the instance to another rotation.
     * &lt;p&gt;
     * Calling this method is equivalent to call
     * {@link #compose(QuaternionRotation, RotationConvention)
     * compose(r, RotationConvention.VECTOR_OPERATOR)}.
     * &lt;/p&gt;
     * @param r rotation to apply the rotation to
     * @return a new rotation which is the composition of r by the instance
     */
    public FieldRotation&lt;T&gt; applyTo(final QuaternionRotation r) {
<span class="fc" id="L1340">        return compose(r, RotationConvention.VECTOR_OPERATOR);</span>
    }

    /** Compose the instance with another rotation.
     * &lt;p&gt;
     * If the semantics of the rotations composition corresponds to a
     * {@link RotationConvention#VECTOR_OPERATOR vector operator} convention,
     * applying the instance to a rotation is computing the composition
     * in an order compliant with the following rule : let {@code u} be any
     * vector and {@code v} its image by {@code r1} (i.e.
     * {@code r1.applyTo(u) = v}). Let {@code w} be the image of {@code v} by
     * rotation {@code r2} (i.e. {@code r2.applyTo(v) = w}). Then
     * {@code w = comp.applyTo(u)}, where
     * {@code comp = r2.compose(r1, RotationConvention.VECTOR_OPERATOR)}.
     * &lt;/p&gt;
     * &lt;p&gt;
     * If the semantics of the rotations composition corresponds to a
     * {@link RotationConvention#FRAME_TRANSFORM frame transform} convention,
     * the application order will be reversed. So keeping the exact same
     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}
     * and  {@code comp} as above, {@code comp} could also be computed as
     * {@code comp = r1.compose(r2, RotationConvention.FRAME_TRANSFORM)}.
     * &lt;/p&gt;
     * @param r rotation to apply the rotation to
     * @param convention convention to use for the semantics of the angle
     * @return a new rotation which is the composition of r by the instance
     */
    public FieldRotation&lt;T&gt; compose(final QuaternionRotation r, final RotationConvention convention) {
<span class="fc bfc" id="L1368" title="All 2 branches covered.">        return convention == RotationConvention.VECTOR_OPERATOR ?</span>
<span class="fc" id="L1369">                             composeInternal(r) : applyTo(r, this);</span>
    }

    /** Compose the instance with another rotation using vector operator convention.
     * @param rot rotation to apply the rotation to
     * @return a new rotation which is the composition of r by the instance
     * using vector operator convention
     */
    private FieldRotation&lt;T&gt; composeInternal(final QuaternionRotation rot) {
<span class="fc" id="L1378">        final Quaternion r = rot.getQuaternion();</span>
<span class="fc" id="L1379">        return new FieldRotation&lt;&gt;(q0.multiply(r.getW()).subtract(q1.multiply(r.getX()).add(q2.multiply(r.getY())).add(q3.multiply(r.getZ()))),</span>
<span class="fc" id="L1380">                        q0.multiply(r.getX()).add(q1.multiply(r.getW())).add(q3.multiply(r.getY()).subtract(q2.multiply(r.getZ()))),</span>
<span class="fc" id="L1381">                        q0.multiply(r.getY()).add(q2.multiply(r.getW())).add(q1.multiply(r.getZ()).subtract(q3.multiply(r.getX()))),</span>
<span class="fc" id="L1382">                        q0.multiply(r.getZ()).add(q3.multiply(r.getW())).add(q2.multiply(r.getX()).subtract(q1.multiply(r.getY()))),</span>
                        false);
    }

    /** Apply a rotation to another rotation.
     * Applying a rotation to another rotation is computing the composition
     * in an order compliant with the following rule : let u be any
     * vector and v its image by rInner (i.e. rInner.applyTo(u) = v), let w be the image
     * of v by rOuter (i.e. rOuter.applyTo(v) = w), then w = comp.applyTo(u),
     * where comp = applyTo(rOuter, rInner).
     * @param rot1 rotation to apply
     * @param rInner rotation to apply the rotation to
     * @param &lt;T&gt; the type of the field elements
     * @return a new rotation which is the composition of r by the instance
     */
    public static &lt;T extends RealFieldElement&lt;T&gt;&gt; FieldRotation&lt;T&gt; applyTo(final QuaternionRotation rot1, final FieldRotation&lt;T&gt; rInner) {
<span class="fc" id="L1398">        final Quaternion r1 = rot1.getQuaternion();</span>
<span class="fc" id="L1399">        return new FieldRotation&lt;&gt;(rInner.q0.multiply(r1.getW()).subtract(rInner.q1.multiply(r1.getX()).add(rInner.q2.multiply(r1.getY())).add(rInner.q3.multiply(r1.getZ()))),</span>
<span class="fc" id="L1400">                                    rInner.q1.multiply(r1.getW()).add(rInner.q0.multiply(r1.getX())).add(rInner.q2.multiply(r1.getZ()).subtract(rInner.q3.multiply(r1.getY()))),</span>
<span class="fc" id="L1401">                                    rInner.q2.multiply(r1.getW()).add(rInner.q0.multiply(r1.getY())).add(rInner.q3.multiply(r1.getX()).subtract(rInner.q1.multiply(r1.getZ()))),</span>
<span class="fc" id="L1402">                                    rInner.q3.multiply(r1.getW()).add(rInner.q0.multiply(r1.getZ())).add(rInner.q1.multiply(r1.getY()).subtract(rInner.q2.multiply(r1.getX()))),</span>
                                    false);
    }

    /** Apply the inverse of the instance to another rotation.
     * &lt;p&gt;
     * Calling this method is equivalent to call
     * {@link #composeInverse(FieldRotation, RotationConvention)
     * composeInverse(r, RotationConvention.VECTOR_OPERATOR)}.
     * &lt;/p&gt;
     * @param r rotation to apply the rotation to
     * @return a new rotation which is the composition of r by the inverse
     * of the instance
     */
    public FieldRotation&lt;T&gt; applyInverseTo(final FieldRotation&lt;T&gt; r) {
<span class="fc" id="L1417">        return composeInverse(r, RotationConvention.VECTOR_OPERATOR);</span>
    }

    /** Compose the inverse of the instance with another rotation.
     * &lt;p&gt;
     * If the semantics of the rotations composition corresponds to a
     * {@link RotationConvention#VECTOR_OPERATOR vector operator} convention,
     * applying the inverse of the instance to a rotation is computing
     * the composition in an order compliant with the following rule :
     * let {@code u} be any vector and {@code v} its image by {@code r1}
     * (i.e. {@code r1.applyTo(u) = v}). Let {@code w} be the inverse image
     * of {@code v} by {@code r2} (i.e. {@code r2.applyInverseTo(v) = w}).
     * Then {@code w = comp.applyTo(u)}, where
     * {@code comp = r2.composeInverse(r1)}.
     * &lt;/p&gt;
     * &lt;p&gt;
     * If the semantics of the rotations composition corresponds to a
     * {@link RotationConvention#FRAME_TRANSFORM frame transform} convention,
     * the application order will be reversed, which means it is the
     * &lt;em&gt;innermost&lt;/em&gt; rotation that will be reversed. So keeping the exact same
     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}
     * and  {@code comp} as above, {@code comp} could also be computed as
     * {@code comp = r1.revert().composeInverse(r2.revert(), RotationConvention.FRAME_TRANSFORM)}.
     * &lt;/p&gt;
     * @param r rotation to apply the rotation to
     * @param convention convention to use for the semantics of the angle
     * @return a new rotation which is the composition of r by the inverse
     * of the instance
     */
    public FieldRotation&lt;T&gt; composeInverse(final FieldRotation&lt;T&gt; r, final RotationConvention convention) {
<span class="fc bfc" id="L1447" title="All 2 branches covered.">        return convention == RotationConvention.VECTOR_OPERATOR ?</span>
<span class="fc" id="L1448">                             composeInverseInternal(r) : r.composeInternal(revert());</span>
    }

    /** Compose the inverse of the instance with another rotation
     * using vector operator convention.
     * @param r rotation to apply the rotation to
     * @return a new rotation which is the composition of r by the inverse
     * of the instance using vector operator convention
     */
    private FieldRotation&lt;T&gt; composeInverseInternal(FieldRotation&lt;T&gt; r) {
<span class="fc" id="L1458">        return new FieldRotation&lt;&gt;(r.q0.multiply(q0).add(r.q1.multiply(q1).add(r.q2.multiply(q2)).add(r.q3.multiply(q3))).negate(),</span>
<span class="fc" id="L1459">                                    r.q0.multiply(q1).add(r.q2.multiply(q3).subtract(r.q3.multiply(q2))).subtract(r.q1.multiply(q0)),</span>
<span class="fc" id="L1460">                                    r.q0.multiply(q2).add(r.q3.multiply(q1).subtract(r.q1.multiply(q3))).subtract(r.q2.multiply(q0)),</span>
<span class="fc" id="L1461">                                    r.q0.multiply(q3).add(r.q1.multiply(q2).subtract(r.q2.multiply(q1))).subtract(r.q3.multiply(q0)),</span>
                                    false);
    }

    /** Apply the inverse of the instance to another rotation.
     * &lt;p&gt;
     * Calling this method is equivalent to call
     * {@link #composeInverse(QuaternionRotation, RotationConvention)
     * composeInverse(r, RotationConvention.VECTOR_OPERATOR)}.
     * &lt;/p&gt;
     * @param r rotation to apply the rotation to
     * @return a new rotation which is the composition of r by the inverse
     * of the instance
     */
    public FieldRotation&lt;T&gt; applyInverseTo(final QuaternionRotation r) {
<span class="fc" id="L1476">        return composeInverse(r, RotationConvention.VECTOR_OPERATOR);</span>
    }

    /** Compose the inverse of the instance with another rotation.
     * &lt;p&gt;
     * If the semantics of the rotations composition corresponds to a
     * {@link RotationConvention#VECTOR_OPERATOR vector operator} convention,
     * applying the inverse of the instance to a rotation is computing
     * the composition in an order compliant with the following rule :
     * let {@code u} be any vector and {@code v} its image by {@code r1}
     * (i.e. {@code r1.applyTo(u) = v}). Let {@code w} be the inverse image
     * of {@code v} by {@code r2} (i.e. {@code r2.applyInverseTo(v) = w}).
     * Then {@code w = comp.applyTo(u)}, where
     * {@code comp = r2.composeInverse(r1)}.
     * &lt;/p&gt;
     * &lt;p&gt;
     * If the semantics of the rotations composition corresponds to a
     * {@link RotationConvention#FRAME_TRANSFORM frame transform} convention,
     * the application order will be reversed, which means it is the
     * &lt;em&gt;innermost&lt;/em&gt; rotation that will be reversed. So keeping the exact same
     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}
     * and  {@code comp} as above, {@code comp} could also be computed as
     * {@code comp = r1.revert().composeInverse(r2.revert(), RotationConvention.FRAME_TRANSFORM)}.
     * &lt;/p&gt;
     * @param r rotation to apply the rotation to
     * @param convention convention to use for the semantics of the angle
     * @return a new rotation which is the composition of r by the inverse
     * of the instance
     */
    public FieldRotation&lt;T&gt; composeInverse(final QuaternionRotation r, final RotationConvention convention) {
<span class="fc bfc" id="L1506" title="All 2 branches covered.">        return convention == RotationConvention.VECTOR_OPERATOR ?</span>
<span class="fc" id="L1507">                             composeInverseInternal(r) : applyTo(r, revert());</span>
    }

    /** Compose the inverse of the instance with another rotation
     * using vector operator convention.
     * @param rot rotation to apply the rotation to
     * @return a new rotation which is the composition of r by the inverse
     * of the instance using vector operator convention
     */
    private FieldRotation&lt;T&gt; composeInverseInternal(QuaternionRotation rot) {
<span class="fc" id="L1517">        final Quaternion r = rot.getQuaternion();</span>
<span class="fc" id="L1518">        return new FieldRotation&lt;&gt;(q0.multiply(r.getW()).add(q1.multiply(r.getX()).add(q2.multiply(r.getY())).add(q3.multiply(r.getZ()))).negate(),</span>
<span class="fc" id="L1519">                                    q1.multiply(r.getW()).add(q3.multiply(r.getY()).subtract(q2.multiply(r.getZ()))).subtract(q0.multiply(r.getX())),</span>
<span class="fc" id="L1520">                                    q2.multiply(r.getW()).add(q1.multiply(r.getZ()).subtract(q3.multiply(r.getX()))).subtract(q0.multiply(r.getY())),</span>
<span class="fc" id="L1521">                                    q3.multiply(r.getW()).add(q2.multiply(r.getX()).subtract(q1.multiply(r.getY()))).subtract(q0.multiply(r.getZ())),</span>
                                    false);
    }

    /** Apply the inverse of a rotation to another rotation.
     * Applying the inverse of a rotation to another rotation is computing
     * the composition in an order compliant with the following rule :
     * let u be any vector and v its image by rInner (i.e. rInner.applyTo(u) = v),
     * let w be the inverse image of v by rOuter
     * (i.e. rOuter.applyInverseTo(v) = w), then w = comp.applyTo(u), where
     * comp = applyInverseTo(rOuter, rInner).
     * @param rotOuter rotation to apply the rotation to
     * @param rInner rotation to apply the rotation to
     * @param &lt;T&gt; the type of the field elements
     * @return a new rotation which is the composition of r by the inverse
     * of the instance
     */
    public static &lt;T extends RealFieldElement&lt;T&gt;&gt; FieldRotation&lt;T&gt; applyInverseTo(final QuaternionRotation rotOuter, final FieldRotation&lt;T&gt; rInner) {
<span class="fc" id="L1539">        final Quaternion rOuter = rotOuter.getQuaternion();</span>
<span class="fc" id="L1540">        return new FieldRotation&lt;&gt;(rInner.q0.multiply(rOuter.getW()).add(rInner.q1.multiply(rOuter.getX()).add(rInner.q2.multiply(rOuter.getY())).add(rInner.q3.multiply(rOuter.getZ()))).negate(),</span>
<span class="fc" id="L1541">                                    rInner.q0.multiply(rOuter.getX()).add(rInner.q2.multiply(rOuter.getZ()).subtract(rInner.q3.multiply(rOuter.getY()))).subtract(rInner.q1.multiply(rOuter.getW())),</span>
<span class="fc" id="L1542">                                    rInner.q0.multiply(rOuter.getY()).add(rInner.q3.multiply(rOuter.getX()).subtract(rInner.q1.multiply(rOuter.getZ()))).subtract(rInner.q2.multiply(rOuter.getW())),</span>
<span class="fc" id="L1543">                                    rInner.q0.multiply(rOuter.getZ()).add(rInner.q1.multiply(rOuter.getY()).subtract(rInner.q2.multiply(rOuter.getX()))).subtract(rInner.q3.multiply(rOuter.getW())),</span>
                                    false);
    }

    /** Perfect orthogonality on a 3X3 matrix.
     * @param m initial matrix (not exactly orthogonal)
     * @param threshold convergence threshold for the iterative
     * orthogonality correction (convergence is reached when the
     * difference between two steps of the Frobenius norm of the
     * correction is below this threshold)
     * @return an orthogonal matrix close to m
     * @exception NotARotationMatrixException if the matrix cannot be
     * orthogonalized with the given threshold after 10 iterations
     */
    private T[][] orthogonalizeMatrix(final T[][] m, final double threshold)
        throws NotARotationMatrixException {

<span class="fc" id="L1560">        T x00 = m[0][0];</span>
<span class="fc" id="L1561">        T x01 = m[0][1];</span>
<span class="fc" id="L1562">        T x02 = m[0][2];</span>
<span class="fc" id="L1563">        T x10 = m[1][0];</span>
<span class="fc" id="L1564">        T x11 = m[1][1];</span>
<span class="fc" id="L1565">        T x12 = m[1][2];</span>
<span class="fc" id="L1566">        T x20 = m[2][0];</span>
<span class="fc" id="L1567">        T x21 = m[2][1];</span>
<span class="fc" id="L1568">        T x22 = m[2][2];</span>
<span class="fc" id="L1569">        double fn = 0;</span>
        double fn1;

<span class="fc" id="L1572">        final T[][] o = MathArrays.buildArray(m[0][0].getField(), 3, 3);</span>

        // iterative correction: Xn+1 = Xn - 0.5 * (Xn.Mt.Xn - M)
<span class="fc" id="L1575">        int i = 0;</span>
<span class="fc bfc" id="L1576" title="All 2 branches covered.">        while (++i &lt; 11) {</span>

            // Mt.Xn
<span class="fc" id="L1579">            final T mx00 = m[0][0].multiply(x00).add(m[1][0].multiply(x10)).add(m[2][0].multiply(x20));</span>
<span class="fc" id="L1580">            final T mx10 = m[0][1].multiply(x00).add(m[1][1].multiply(x10)).add(m[2][1].multiply(x20));</span>
<span class="fc" id="L1581">            final T mx20 = m[0][2].multiply(x00).add(m[1][2].multiply(x10)).add(m[2][2].multiply(x20));</span>
<span class="fc" id="L1582">            final T mx01 = m[0][0].multiply(x01).add(m[1][0].multiply(x11)).add(m[2][0].multiply(x21));</span>
<span class="fc" id="L1583">            final T mx11 = m[0][1].multiply(x01).add(m[1][1].multiply(x11)).add(m[2][1].multiply(x21));</span>
<span class="fc" id="L1584">            final T mx21 = m[0][2].multiply(x01).add(m[1][2].multiply(x11)).add(m[2][2].multiply(x21));</span>
<span class="fc" id="L1585">            final T mx02 = m[0][0].multiply(x02).add(m[1][0].multiply(x12)).add(m[2][0].multiply(x22));</span>
<span class="fc" id="L1586">            final T mx12 = m[0][1].multiply(x02).add(m[1][1].multiply(x12)).add(m[2][1].multiply(x22));</span>
<span class="fc" id="L1587">            final T mx22 = m[0][2].multiply(x02).add(m[1][2].multiply(x12)).add(m[2][2].multiply(x22));</span>

            // Xn+1
<span class="fc" id="L1590">            o[0][0] = x00.subtract(x00.multiply(mx00).add(x01.multiply(mx10)).add(x02.multiply(mx20)).subtract(m[0][0]).multiply(0.5));</span>
<span class="fc" id="L1591">            o[0][1] = x01.subtract(x00.multiply(mx01).add(x01.multiply(mx11)).add(x02.multiply(mx21)).subtract(m[0][1]).multiply(0.5));</span>
<span class="fc" id="L1592">            o[0][2] = x02.subtract(x00.multiply(mx02).add(x01.multiply(mx12)).add(x02.multiply(mx22)).subtract(m[0][2]).multiply(0.5));</span>
<span class="fc" id="L1593">            o[1][0] = x10.subtract(x10.multiply(mx00).add(x11.multiply(mx10)).add(x12.multiply(mx20)).subtract(m[1][0]).multiply(0.5));</span>
<span class="fc" id="L1594">            o[1][1] = x11.subtract(x10.multiply(mx01).add(x11.multiply(mx11)).add(x12.multiply(mx21)).subtract(m[1][1]).multiply(0.5));</span>
<span class="fc" id="L1595">            o[1][2] = x12.subtract(x10.multiply(mx02).add(x11.multiply(mx12)).add(x12.multiply(mx22)).subtract(m[1][2]).multiply(0.5));</span>
<span class="fc" id="L1596">            o[2][0] = x20.subtract(x20.multiply(mx00).add(x21.multiply(mx10)).add(x22.multiply(mx20)).subtract(m[2][0]).multiply(0.5));</span>
<span class="fc" id="L1597">            o[2][1] = x21.subtract(x20.multiply(mx01).add(x21.multiply(mx11)).add(x22.multiply(mx21)).subtract(m[2][1]).multiply(0.5));</span>
<span class="fc" id="L1598">            o[2][2] = x22.subtract(x20.multiply(mx02).add(x21.multiply(mx12)).add(x22.multiply(mx22)).subtract(m[2][2]).multiply(0.5));</span>

            // correction on each elements
<span class="fc" id="L1601">            final double corr00 = o[0][0].getReal() - m[0][0].getReal();</span>
<span class="fc" id="L1602">            final double corr01 = o[0][1].getReal() - m[0][1].getReal();</span>
<span class="fc" id="L1603">            final double corr02 = o[0][2].getReal() - m[0][2].getReal();</span>
<span class="fc" id="L1604">            final double corr10 = o[1][0].getReal() - m[1][0].getReal();</span>
<span class="fc" id="L1605">            final double corr11 = o[1][1].getReal() - m[1][1].getReal();</span>
<span class="fc" id="L1606">            final double corr12 = o[1][2].getReal() - m[1][2].getReal();</span>
<span class="fc" id="L1607">            final double corr20 = o[2][0].getReal() - m[2][0].getReal();</span>
<span class="fc" id="L1608">            final double corr21 = o[2][1].getReal() - m[2][1].getReal();</span>
<span class="fc" id="L1609">            final double corr22 = o[2][2].getReal() - m[2][2].getReal();</span>

            // Frobenius norm of the correction
<span class="fc" id="L1612">            fn1 = corr00 * corr00 + corr01 * corr01 + corr02 * corr02 +</span>
                  corr10 * corr10 + corr11 * corr11 + corr12 * corr12 +
                  corr20 * corr20 + corr21 * corr21 + corr22 * corr22;

            // convergence test
<span class="fc bfc" id="L1617" title="All 2 branches covered.">            if (FastMath.abs(fn1 - fn) &lt;= threshold) {</span>
<span class="fc" id="L1618">                return o;</span>
            }

            // prepare next iteration
<span class="fc" id="L1622">            x00 = o[0][0];</span>
<span class="fc" id="L1623">            x01 = o[0][1];</span>
<span class="fc" id="L1624">            x02 = o[0][2];</span>
<span class="fc" id="L1625">            x10 = o[1][0];</span>
<span class="fc" id="L1626">            x11 = o[1][1];</span>
<span class="fc" id="L1627">            x12 = o[1][2];</span>
<span class="fc" id="L1628">            x20 = o[2][0];</span>
<span class="fc" id="L1629">            x21 = o[2][1];</span>
<span class="fc" id="L1630">            x22 = o[2][2];</span>
<span class="fc" id="L1631">            fn  = fn1;</span>

<span class="fc" id="L1633">        }</span>

        // the algorithm did not converge after 10 iterations
<span class="fc" id="L1636">        throw new NotARotationMatrixException(LocalizedFormats.UNABLE_TO_ORTHOGONOLIZE_MATRIX,</span>
<span class="fc" id="L1637">                                              i - 1);</span>

    }

    /** Compute the &lt;i&gt;distance&lt;/i&gt; between two rotations.
     * &lt;p&gt;The &lt;i&gt;distance&lt;/i&gt; is intended here as a way to check if two
     * rotations are almost similar (i.e. they transform vectors the same way)
     * or very different. It is mathematically defined as the angle of
     * the rotation r that prepended to one of the rotations gives the other
     * one:&lt;/p&gt;
     * &lt;div style=&quot;white-space: pre&quot;&gt;&lt;code&gt;
     *        r&lt;sub&gt;1&lt;/sub&gt;(r) = r&lt;sub&gt;2&lt;/sub&gt;
     * &lt;/code&gt;&lt;/div&gt;
     * &lt;p&gt;This distance is an angle between 0 and &amp;pi;. Its value is the smallest
     * possible upper bound of the angle in radians between r&lt;sub&gt;1&lt;/sub&gt;(v)
     * and r&lt;sub&gt;2&lt;/sub&gt;(v) for all possible vectors v. This upper bound is
     * reached for some v. The distance is equal to 0 if and only if the two
     * rotations are identical.&lt;/p&gt;
     * &lt;p&gt;Comparing two rotations should always be done using this value rather
     * than for example comparing the components of the quaternions. It is much
     * more stable, and has a geometric meaning. Also comparing quaternions
     * components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64)
     * and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite
     * their components are different (they are exact opposites).&lt;/p&gt;
     * @param r1 first rotation
     * @param r2 second rotation
     * @param &lt;T&gt; the type of the field elements
     * @return &lt;i&gt;distance&lt;/i&gt; between r1 and r2
     */
    public static &lt;T extends RealFieldElement&lt;T&gt;&gt; T distance(final FieldRotation&lt;T&gt; r1, final FieldRotation&lt;T&gt; r2) {
<span class="fc" id="L1667">        return r1.composeInverseInternal(r2).getAngle();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>