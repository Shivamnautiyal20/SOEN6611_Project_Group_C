<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BlockFieldMatrix.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Math</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math3.linear</a> &gt; <span class="el_source">BlockFieldMatrix.java</span></div><h1>BlockFieldMatrix.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.math3.linear;

import java.io.Serializable;

import org.apache.commons.math3.Field;
import org.apache.commons.math3.FieldElement;
import org.apache.commons.math3.exception.NoDataException;
import org.apache.commons.math3.exception.DimensionMismatchException;
import org.apache.commons.math3.exception.NotStrictlyPositiveException;
import org.apache.commons.math3.exception.NullArgumentException;
import org.apache.commons.math3.exception.NumberIsTooSmallException;
import org.apache.commons.math3.exception.OutOfRangeException;
import org.apache.commons.math3.exception.util.LocalizedFormats;
import org.apache.commons.math3.util.FastMath;
import org.apache.commons.math3.util.MathArrays;
import org.apache.commons.math3.util.MathUtils;

/**
 * Cache-friendly implementation of FieldMatrix using a flat arrays to store
 * square blocks of the matrix.
 * &lt;p&gt;
 * This implementation is specially designed to be cache-friendly. Square blocks are
 * stored as small arrays and allow efficient traversal of data both in row major direction
 * and columns major direction, one block at a time. This greatly increases performances
 * for algorithms that use crossed directions loops like multiplication or transposition.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The size of square blocks is a static parameter. It may be tuned according to the cache
 * size of the target computer processor. As a rule of thumbs, it should be the largest
 * value that allows three blocks to be simultaneously cached (this is necessary for example
 * for matrix multiplication). The default value is to use 36x36 blocks.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The regular blocks represent {@link #BLOCK_SIZE} x {@link #BLOCK_SIZE} squares. Blocks
 * at right hand side and bottom side which may be smaller to fit matrix dimensions. The square
 * blocks are flattened in row major order in single dimension arrays which are therefore
 * {@link #BLOCK_SIZE}&lt;sup&gt;2&lt;/sup&gt; elements long for regular blocks. The blocks are themselves
 * organized in row major order.
 * &lt;/p&gt;
 * &lt;p&gt;
 * As an example, for a block size of 36x36, a 100x60 matrix would be stored in 6 blocks.
 * Block 0 would be a Field[1296] array holding the upper left 36x36 square, block 1 would be
 * a Field[1296] array holding the upper center 36x36 square, block 2 would be a Field[1008]
 * array holding the upper right 36x28 rectangle, block 3 would be a Field[864] array holding
 * the lower left 24x36 rectangle, block 4 would be a Field[864] array holding the lower center
 * 24x36 rectangle and block 5 would be a Field[672] array holding the lower right 24x28
 * rectangle.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The layout complexity overhead versus simple mapping of matrices to java
 * arrays is negligible for small matrices (about 1%). The gain from cache efficiency leads
 * to up to 3-fold improvements for matrices of moderate to large size.
 * &lt;/p&gt;
 * @param &lt;T&gt; the type of the field elements
 * @version $Id$
 * @since 2.0
 */
public class BlockFieldMatrix&lt;T extends FieldElement&lt;T&gt;&gt; extends AbstractFieldMatrix&lt;T&gt; implements Serializable {
    /** Block size. */
    public static final int BLOCK_SIZE = 36;
    /** Serializable version identifier. */
    private static final long serialVersionUID = -4602336630143123183L;
    /** Blocks of matrix entries. */
    private final T blocks[][];
    /** Number of rows of the matrix. */
    private final int rows;
    /** Number of columns of the matrix. */
    private final int columns;
    /** Number of block rows of the matrix. */
    private final int blockRows;
    /** Number of block columns of the matrix. */
    private final int blockColumns;

    /**
     * Create a new matrix with the supplied row and column dimensions.
     *
     * @param field Field to which the elements belong.
     * @param rows Number of rows in the new matrix.
     * @param columns Number of columns in the new matrix.
     * @throws NotStrictlyPositiveException if row or column dimension is not
     * positive.
     */
    public BlockFieldMatrix(final Field&lt;T&gt; field, final int rows,
                            final int columns)
        throws NotStrictlyPositiveException {
<span class="fc" id="L103">        super(field, rows, columns);</span>
<span class="fc" id="L104">        this.rows    = rows;</span>
<span class="fc" id="L105">        this.columns = columns;</span>

        // number of blocks
<span class="fc" id="L108">        blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;</span>
<span class="fc" id="L109">        blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;</span>

        // allocate storage blocks, taking care of smaller ones at right and bottom
<span class="fc" id="L112">        blocks = createBlocksLayout(field, rows, columns);</span>
<span class="fc" id="L113">    }</span>

    /**
     * Create a new dense matrix copying entries from raw layout data.
     * &lt;p&gt;The input array &lt;em&gt;must&lt;/em&gt; already be in raw layout.&lt;/p&gt;
     * &lt;p&gt;Calling this constructor is equivalent to call:
     * &lt;pre&gt;matrix = new BlockFieldMatrix&lt;T&gt;(getField(), rawData.length, rawData[0].length,
     *                                   toBlocksLayout(rawData), false);&lt;/pre&gt;
     * &lt;/p&gt;
     *
     * @param rawData Data for the new matrix, in raw layout.
     * @throws DimensionMismatchException if the {@code blockData} shape is
     * inconsistent with block layout.
     * @see #BlockFieldMatrix(int, int, FieldElement[][], boolean)
     */
    public BlockFieldMatrix(final T[][] rawData)
        throws DimensionMismatchException {
<span class="fc" id="L130">        this(rawData.length, rawData[0].length, toBlocksLayout(rawData), false);</span>
<span class="fc" id="L131">    }</span>

    /**
     * Create a new dense matrix copying entries from block layout data.
     * &lt;p&gt;The input array &lt;em&gt;must&lt;/em&gt; already be in blocks layout.&lt;/p&gt;
     * @param rows  the number of rows in the new matrix
     * @param columns  the number of columns in the new matrix
     * @param blockData data for new matrix
     * @param copyArray if true, the input array will be copied, otherwise
     * it will be referenced
     *
     * @throws DimensionMismatchException if the {@code blockData} shape is
     * inconsistent with block layout.
     * @throws NotStrictlyPositiveException if row or column dimension is not
     * positive.
     * @see #createBlocksLayout(Field, int, int)
     * @see #toBlocksLayout(FieldElement[][])
     * @see #BlockFieldMatrix(FieldElement[][])
     */
    public BlockFieldMatrix(final int rows, final int columns,
                            final T[][] blockData, final boolean copyArray)
        throws DimensionMismatchException, NotStrictlyPositiveException {
<span class="fc" id="L153">        super(extractField(blockData), rows, columns);</span>
<span class="fc" id="L154">        this.rows    = rows;</span>
<span class="fc" id="L155">        this.columns = columns;</span>

        // number of blocks
<span class="fc" id="L158">        blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;</span>
<span class="fc" id="L159">        blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;</span>

<span class="pc bpc" id="L161" title="1 of 2 branches missed.">        if (copyArray) {</span>
            // allocate storage blocks, taking care of smaller ones at right and bottom
<span class="nc" id="L163">            blocks = MathArrays.buildArray(getField(), blockRows * blockColumns, -1);</span>
        } else {
            // reference existing array
<span class="fc" id="L166">            blocks = blockData;</span>
        }

<span class="fc" id="L169">        int index = 0;</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">        for (int iBlock = 0; iBlock &lt; blockRows; ++iBlock) {</span>
<span class="fc" id="L171">            final int iHeight = blockHeight(iBlock);</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">            for (int jBlock = 0; jBlock &lt; blockColumns; ++jBlock, ++index) {</span>
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">                if (blockData[index].length != iHeight * blockWidth(jBlock)) {</span>
<span class="nc" id="L174">                    throw new DimensionMismatchException(blockData[index].length,</span>
<span class="nc" id="L175">                                                         iHeight * blockWidth(jBlock));</span>
                }
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">                if (copyArray) {</span>
<span class="nc" id="L178">                    blocks[index] = blockData[index].clone();</span>
                }
            }
        }
<span class="fc" id="L182">    }</span>

    /**
     * Convert a data array from raw layout to blocks layout.
     * &lt;p&gt;
     * Raw layout is the straightforward layout where element at row i and
     * column j is in array element &lt;code&gt;rawData[i][j]&lt;/code&gt;. Blocks layout
     * is the layout used in {@link BlockFieldMatrix} instances, where the matrix
     * is split in square blocks (except at right and bottom side where blocks may
     * be rectangular to fit matrix size) and each block is stored in a flattened
     * one-dimensional array.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This method creates an array in blocks layout from an input array in raw layout.
     * It can be used to provide the array argument of the {@link
     * #BlockFieldMatrix(int, int, FieldElement[][], boolean)}
     * constructor.
     * &lt;/p&gt;
     * @param &lt;T&gt; Type of the field elements.
     * @param rawData Data array in raw layout.
     * @return a new data array containing the same entries but in blocks layout
     * @throws DimensionMismatchException if {@code rawData} is not rectangular
     *  (not all rows have the same length).
     * @see #createBlocksLayout(Field, int, int)
     * @see #BlockFieldMatrix(int, int, FieldElement[][], boolean)
     */
    public static &lt;T extends FieldElement&lt;T&gt;&gt; T[][] toBlocksLayout(final T[][] rawData)
        throws DimensionMismatchException {

<span class="fc" id="L211">        final int rows         = rawData.length;</span>
<span class="fc" id="L212">        final int columns      = rawData[0].length;</span>
<span class="fc" id="L213">        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;</span>
<span class="fc" id="L214">        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;</span>

        // safety checks
<span class="fc bfc" id="L217" title="All 2 branches covered.">        for (int i = 0; i &lt; rawData.length; ++i) {</span>
<span class="fc" id="L218">            final int length = rawData[i].length;</span>
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">            if (length != columns) {</span>
<span class="nc" id="L220">                throw new DimensionMismatchException(columns, length);</span>
            }
        }

        // convert array
<span class="fc" id="L225">        final Field&lt;T&gt; field = extractField(rawData);</span>
<span class="fc" id="L226">        final T[][] blocks = MathArrays.buildArray(field, blockRows * blockColumns, -1);</span>
<span class="fc" id="L227">        int blockIndex = 0;</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">        for (int iBlock = 0; iBlock &lt; blockRows; ++iBlock) {</span>
<span class="fc" id="L229">            final int pStart  = iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L230">            final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);</span>
<span class="fc" id="L231">            final int iHeight = pEnd - pStart;</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">            for (int jBlock = 0; jBlock &lt; blockColumns; ++jBlock) {</span>
<span class="fc" id="L233">                final int qStart = jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L234">                final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);</span>
<span class="fc" id="L235">                final int jWidth = qEnd - qStart;</span>

                // allocate new block
<span class="fc" id="L238">                final T[] block = MathArrays.buildArray(field, iHeight * jWidth);</span>
<span class="fc" id="L239">                blocks[blockIndex] = block;</span>

                // copy data
<span class="fc" id="L242">                int index = 0;</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">                for (int p = pStart; p &lt; pEnd; ++p) {</span>
<span class="fc" id="L244">                    System.arraycopy(rawData[p], qStart, block, index, jWidth);</span>
<span class="fc" id="L245">                    index += jWidth;</span>
                }

<span class="fc" id="L248">                ++blockIndex;</span>
            }
        }

<span class="fc" id="L252">        return blocks;</span>
    }

    /**
     * Create a data array in blocks layout.
     * &lt;p&gt;
     * This method can be used to create the array argument of the {@link
     * #BlockFieldMatrix(int, int, FieldElement[][], boolean)}
     * constructor.
     * &lt;/p&gt;
     * @param &lt;T&gt; Type of the field elements.
     * @param field Field to which the elements belong.
     * @param rows Number of rows in the new matrix.
     * @param columns Number of columns in the new matrix.
     * @return a new data array in blocks layout.
     * @see #toBlocksLayout(FieldElement[][])
     * @see #BlockFieldMatrix(int, int, FieldElement[][], boolean)
     */
    public static &lt;T extends FieldElement&lt;T&gt;&gt; T[][] createBlocksLayout(final Field&lt;T&gt; field,
                                                                       final int rows, final int columns) {
<span class="fc" id="L272">        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;</span>
<span class="fc" id="L273">        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;</span>

<span class="fc" id="L275">        final T[][] blocks = MathArrays.buildArray(field, blockRows * blockColumns, -1);</span>
<span class="fc" id="L276">        int blockIndex = 0;</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">        for (int iBlock = 0; iBlock &lt; blockRows; ++iBlock) {</span>
<span class="fc" id="L278">            final int pStart  = iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L279">            final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);</span>
<span class="fc" id="L280">            final int iHeight = pEnd - pStart;</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">            for (int jBlock = 0; jBlock &lt; blockColumns; ++jBlock) {</span>
<span class="fc" id="L282">                final int qStart = jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L283">                final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);</span>
<span class="fc" id="L284">                final int jWidth = qEnd - qStart;</span>
<span class="fc" id="L285">                blocks[blockIndex] = MathArrays.buildArray(field, iHeight * jWidth);</span>
<span class="fc" id="L286">                ++blockIndex;</span>
            }
        }

<span class="fc" id="L290">        return blocks;</span>
    }

    /** {@inheritDoc} */
    @Override
    public FieldMatrix&lt;T&gt; createMatrix(final int rowDimension,
                                       final int columnDimension)
        throws NotStrictlyPositiveException {
<span class="fc" id="L298">        return new BlockFieldMatrix&lt;T&gt;(getField(), rowDimension,</span>
                                       columnDimension);
    }

    /** {@inheritDoc} */
    @Override
    public FieldMatrix&lt;T&gt; copy() {

        // create an empty matrix
<span class="fc" id="L307">        BlockFieldMatrix&lt;T&gt; copied = new BlockFieldMatrix&lt;T&gt;(getField(), rows, columns);</span>

        // copy the blocks
<span class="fc bfc" id="L310" title="All 2 branches covered.">        for (int i = 0; i &lt; blocks.length; ++i) {</span>
<span class="fc" id="L311">            System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);</span>
        }

<span class="fc" id="L314">        return copied;</span>
    }

    /** {@inheritDoc} */
    @Override
    public FieldMatrix&lt;T&gt; add(final FieldMatrix&lt;T&gt; m)
        throws MatrixDimensionMismatchException {
        try {
<span class="fc" id="L322">            return add((BlockFieldMatrix&lt;T&gt;) m);</span>
<span class="nc" id="L323">        } catch (ClassCastException cce) {</span>

            // safety check
<span class="nc" id="L326">            checkAdditionCompatible(m);</span>

<span class="nc" id="L328">            final BlockFieldMatrix&lt;T&gt; out = new BlockFieldMatrix&lt;T&gt;(getField(), rows, columns);</span>

            // perform addition block-wise, to ensure good cache behavior
<span class="nc" id="L331">            int blockIndex = 0;</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">            for (int iBlock = 0; iBlock &lt; out.blockRows; ++iBlock) {</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">                for (int jBlock = 0; jBlock &lt; out.blockColumns; ++jBlock) {</span>

                    // perform addition on the current block
<span class="nc" id="L336">                    final T[] outBlock = out.blocks[blockIndex];</span>
<span class="nc" id="L337">                    final T[] tBlock   = blocks[blockIndex];</span>
<span class="nc" id="L338">                    final int      pStart   = iBlock * BLOCK_SIZE;</span>
<span class="nc" id="L339">                    final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, rows);</span>
<span class="nc" id="L340">                    final int      qStart   = jBlock * BLOCK_SIZE;</span>
<span class="nc" id="L341">                    final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, columns);</span>
<span class="nc" id="L342">                    int k = 0;</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">                    for (int p = pStart; p &lt; pEnd; ++p) {</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">                        for (int q = qStart; q &lt; qEnd; ++q) {</span>
<span class="nc" id="L345">                            outBlock[k] = tBlock[k].add(m.getEntry(p, q));</span>
<span class="nc" id="L346">                            ++k;</span>
                        }
                    }

                    // go to next block
<span class="nc" id="L351">                    ++blockIndex;</span>

                }
            }

<span class="nc" id="L356">            return out;</span>
        }
    }

    /**
     * Compute the sum of {@code this} and {@code m}.
     *
     * @param m matrix to be added
     * @return {@code this + m}
     * @throws MatrixDimensionMismatchException if {@code m} is not the same
     * size as {@code this}
     */
    public BlockFieldMatrix&lt;T&gt; add(final BlockFieldMatrix&lt;T&gt; m)
        throws MatrixDimensionMismatchException {

        // safety check
<span class="fc" id="L372">        checkAdditionCompatible(m);</span>

<span class="fc" id="L374">        final BlockFieldMatrix&lt;T&gt; out = new BlockFieldMatrix&lt;T&gt;(getField(), rows, columns);</span>

        // perform addition block-wise, to ensure good cache behavior
<span class="fc bfc" id="L377" title="All 2 branches covered.">        for (int blockIndex = 0; blockIndex &lt; out.blocks.length; ++blockIndex) {</span>
<span class="fc" id="L378">            final T[] outBlock = out.blocks[blockIndex];</span>
<span class="fc" id="L379">            final T[] tBlock   = blocks[blockIndex];</span>
<span class="fc" id="L380">            final T[] mBlock   = m.blocks[blockIndex];</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">            for (int k = 0; k &lt; outBlock.length; ++k) {</span>
<span class="fc" id="L382">                outBlock[k] = tBlock[k].add(mBlock[k]);</span>
            }
        }

<span class="fc" id="L386">        return out;</span>
    }

    /** {@inheritDoc} */
    @Override
    public FieldMatrix&lt;T&gt; subtract(final FieldMatrix&lt;T&gt; m)
        throws MatrixDimensionMismatchException {
        try {
<span class="fc" id="L394">            return subtract((BlockFieldMatrix&lt;T&gt;) m);</span>
<span class="nc" id="L395">        } catch (ClassCastException cce) {</span>

            // safety check
<span class="nc" id="L398">            checkSubtractionCompatible(m);</span>

<span class="nc" id="L400">            final BlockFieldMatrix&lt;T&gt; out = new BlockFieldMatrix&lt;T&gt;(getField(), rows, columns);</span>

            // perform subtraction block-wise, to ensure good cache behavior
<span class="nc" id="L403">            int blockIndex = 0;</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">            for (int iBlock = 0; iBlock &lt; out.blockRows; ++iBlock) {</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">                for (int jBlock = 0; jBlock &lt; out.blockColumns; ++jBlock) {</span>

                    // perform subtraction on the current block
<span class="nc" id="L408">                    final T[] outBlock = out.blocks[blockIndex];</span>
<span class="nc" id="L409">                    final T[] tBlock   = blocks[blockIndex];</span>
<span class="nc" id="L410">                    final int      pStart   = iBlock * BLOCK_SIZE;</span>
<span class="nc" id="L411">                    final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, rows);</span>
<span class="nc" id="L412">                    final int      qStart   = jBlock * BLOCK_SIZE;</span>
<span class="nc" id="L413">                    final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, columns);</span>
<span class="nc" id="L414">                    int k = 0;</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">                    for (int p = pStart; p &lt; pEnd; ++p) {</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">                        for (int q = qStart; q &lt; qEnd; ++q) {</span>
<span class="nc" id="L417">                            outBlock[k] = tBlock[k].subtract(m.getEntry(p, q));</span>
<span class="nc" id="L418">                            ++k;</span>
                        }
                    }

                    // go to next block
<span class="nc" id="L423">                    ++blockIndex;</span>

                }
            }

<span class="nc" id="L428">            return out;</span>
        }
    }

    /**
     * Compute {@code this - m}.
     *
     * @param m matrix to be subtracted
     * @return {@code this - m}
     * @throws MatrixDimensionMismatchException if {@code m} is not the same
     * size as {@code this}
     */
    public BlockFieldMatrix&lt;T&gt; subtract(final BlockFieldMatrix&lt;T&gt; m) throws MatrixDimensionMismatchException {
        // safety check
<span class="fc" id="L442">        checkSubtractionCompatible(m);</span>

<span class="fc" id="L444">        final BlockFieldMatrix&lt;T&gt; out = new BlockFieldMatrix&lt;T&gt;(getField(), rows, columns);</span>

        // perform subtraction block-wise, to ensure good cache behavior
<span class="fc bfc" id="L447" title="All 2 branches covered.">        for (int blockIndex = 0; blockIndex &lt; out.blocks.length; ++blockIndex) {</span>
<span class="fc" id="L448">            final T[] outBlock = out.blocks[blockIndex];</span>
<span class="fc" id="L449">            final T[] tBlock   = blocks[blockIndex];</span>
<span class="fc" id="L450">            final T[] mBlock   = m.blocks[blockIndex];</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">            for (int k = 0; k &lt; outBlock.length; ++k) {</span>
<span class="fc" id="L452">                outBlock[k] = tBlock[k].subtract(mBlock[k]);</span>
            }
        }

<span class="fc" id="L456">        return out;</span>
    }

    /** {@inheritDoc} */
    @Override
    public FieldMatrix&lt;T&gt; scalarAdd(final T d) {
<span class="fc" id="L462">        final BlockFieldMatrix&lt;T&gt; out = new BlockFieldMatrix&lt;T&gt;(getField(), rows, columns);</span>

        // perform subtraction block-wise, to ensure good cache behavior
<span class="fc bfc" id="L465" title="All 2 branches covered.">        for (int blockIndex = 0; blockIndex &lt; out.blocks.length; ++blockIndex) {</span>
<span class="fc" id="L466">            final T[] outBlock = out.blocks[blockIndex];</span>
<span class="fc" id="L467">            final T[] tBlock   = blocks[blockIndex];</span>
<span class="fc bfc" id="L468" title="All 2 branches covered.">            for (int k = 0; k &lt; outBlock.length; ++k) {</span>
<span class="fc" id="L469">                outBlock[k] = tBlock[k].add(d);</span>
            }
        }

<span class="fc" id="L473">        return out;</span>
    }

    /** {@inheritDoc} */
    @Override
    public FieldMatrix&lt;T&gt; scalarMultiply(final T d) {

<span class="fc" id="L480">        final BlockFieldMatrix&lt;T&gt; out = new BlockFieldMatrix&lt;T&gt;(getField(), rows, columns);</span>

        // perform subtraction block-wise, to ensure good cache behavior
<span class="fc bfc" id="L483" title="All 2 branches covered.">        for (int blockIndex = 0; blockIndex &lt; out.blocks.length; ++blockIndex) {</span>
<span class="fc" id="L484">            final T[] outBlock = out.blocks[blockIndex];</span>
<span class="fc" id="L485">            final T[] tBlock   = blocks[blockIndex];</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">            for (int k = 0; k &lt; outBlock.length; ++k) {</span>
<span class="fc" id="L487">                outBlock[k] = tBlock[k].multiply(d);</span>
            }
        }

<span class="fc" id="L491">        return out;</span>
    }

    /** {@inheritDoc} */
    @Override
    public FieldMatrix&lt;T&gt; multiply(final FieldMatrix&lt;T&gt; m)
        throws DimensionMismatchException {
        try {
<span class="fc" id="L499">            return multiply((BlockFieldMatrix&lt;T&gt;) m);</span>
<span class="nc" id="L500">        } catch (ClassCastException cce) {</span>

            // safety check
<span class="nc" id="L503">            checkMultiplicationCompatible(m);</span>

<span class="nc" id="L505">            final BlockFieldMatrix&lt;T&gt; out = new BlockFieldMatrix&lt;T&gt;(getField(), rows, m.getColumnDimension());</span>
<span class="nc" id="L506">            final T zero = getField().getZero();</span>

            // perform multiplication block-wise, to ensure good cache behavior
<span class="nc" id="L509">            int blockIndex = 0;</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">            for (int iBlock = 0; iBlock &lt; out.blockRows; ++iBlock) {</span>

<span class="nc" id="L512">                final int pStart = iBlock * BLOCK_SIZE;</span>
<span class="nc" id="L513">                final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);</span>

<span class="nc bnc" id="L515" title="All 2 branches missed.">                for (int jBlock = 0; jBlock &lt; out.blockColumns; ++jBlock) {</span>

<span class="nc" id="L517">                    final int qStart = jBlock * BLOCK_SIZE;</span>
<span class="nc" id="L518">                    final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());</span>

                    // select current block
<span class="nc" id="L521">                    final T[] outBlock = out.blocks[blockIndex];</span>

                    // perform multiplication on current block
<span class="nc bnc" id="L524" title="All 2 branches missed.">                    for (int kBlock = 0; kBlock &lt; blockColumns; ++kBlock) {</span>
<span class="nc" id="L525">                        final int kWidth      = blockWidth(kBlock);</span>
<span class="nc" id="L526">                        final T[] tBlock = blocks[iBlock * blockColumns + kBlock];</span>
<span class="nc" id="L527">                        final int rStart      = kBlock * BLOCK_SIZE;</span>
<span class="nc" id="L528">                        int k = 0;</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">                        for (int p = pStart; p &lt; pEnd; ++p) {</span>
<span class="nc" id="L530">                            final int lStart = (p - pStart) * kWidth;</span>
<span class="nc" id="L531">                            final int lEnd   = lStart + kWidth;</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">                            for (int q = qStart; q &lt; qEnd; ++q) {</span>
<span class="nc" id="L533">                                T sum = zero;</span>
<span class="nc" id="L534">                                int r = rStart;</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">                                for (int l = lStart; l &lt; lEnd; ++l) {</span>
<span class="nc" id="L536">                                    sum = sum.add(tBlock[l].multiply(m.getEntry(r, q)));</span>
<span class="nc" id="L537">                                    ++r;</span>
                                }
<span class="nc" id="L539">                                outBlock[k] = outBlock[k].add(sum);</span>
<span class="nc" id="L540">                                ++k;</span>
                            }
                        }
                    }

                    // go to next block
<span class="nc" id="L546">                    ++blockIndex;</span>

                }
            }

<span class="nc" id="L551">            return out;</span>
        }
    }

    /**
     * Returns the result of postmultiplying {@code this} by {@code m}.
     *
     * @param m matrix to postmultiply by
     * @return {@code this * m}
     * @throws DimensionMismatchException if the matrices are not compatible.
     */
    public BlockFieldMatrix&lt;T&gt; multiply(BlockFieldMatrix&lt;T&gt; m)
        throws DimensionMismatchException {

        // safety check
<span class="fc" id="L566">        checkMultiplicationCompatible(m);</span>

<span class="fc" id="L568">        final BlockFieldMatrix&lt;T&gt; out = new BlockFieldMatrix&lt;T&gt;(getField(), rows, m.columns);</span>
<span class="fc" id="L569">        final T zero = getField().getZero();</span>

        // perform multiplication block-wise, to ensure good cache behavior
<span class="fc" id="L572">        int blockIndex = 0;</span>
<span class="fc bfc" id="L573" title="All 2 branches covered.">        for (int iBlock = 0; iBlock &lt; out.blockRows; ++iBlock) {</span>

<span class="fc" id="L575">            final int pStart = iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L576">            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);</span>

<span class="fc bfc" id="L578" title="All 2 branches covered.">            for (int jBlock = 0; jBlock &lt; out.blockColumns; ++jBlock) {</span>
<span class="fc" id="L579">                final int jWidth = out.blockWidth(jBlock);</span>
<span class="fc" id="L580">                final int jWidth2 = jWidth  + jWidth;</span>
<span class="fc" id="L581">                final int jWidth3 = jWidth2 + jWidth;</span>
<span class="fc" id="L582">                final int jWidth4 = jWidth3 + jWidth;</span>

                // select current block
<span class="fc" id="L585">                final T[] outBlock = out.blocks[blockIndex];</span>

                // perform multiplication on current block
<span class="fc bfc" id="L588" title="All 2 branches covered.">                for (int kBlock = 0; kBlock &lt; blockColumns; ++kBlock) {</span>
<span class="fc" id="L589">                    final int kWidth = blockWidth(kBlock);</span>
<span class="fc" id="L590">                    final T[] tBlock = blocks[iBlock * blockColumns + kBlock];</span>
<span class="fc" id="L591">                    final T[] mBlock = m.blocks[kBlock * m.blockColumns + jBlock];</span>
<span class="fc" id="L592">                    int k = 0;</span>
<span class="fc bfc" id="L593" title="All 2 branches covered.">                    for (int p = pStart; p &lt; pEnd; ++p) {</span>
<span class="fc" id="L594">                        final int lStart = (p - pStart) * kWidth;</span>
<span class="fc" id="L595">                        final int lEnd   = lStart + kWidth;</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">                        for (int nStart = 0; nStart &lt; jWidth; ++nStart) {</span>
<span class="fc" id="L597">                            T sum = zero;</span>
<span class="fc" id="L598">                            int l = lStart;</span>
<span class="fc" id="L599">                            int n = nStart;</span>
<span class="fc bfc" id="L600" title="All 2 branches covered.">                            while (l &lt; lEnd - 3) {</span>
<span class="fc" id="L601">                                sum = sum.</span>
<span class="fc" id="L602">                                      add(tBlock[l].multiply(mBlock[n])).</span>
<span class="fc" id="L603">                                      add(tBlock[l + 1].multiply(mBlock[n + jWidth])).</span>
<span class="fc" id="L604">                                      add(tBlock[l + 2].multiply(mBlock[n + jWidth2])).</span>
<span class="fc" id="L605">                                      add(tBlock[l + 3].multiply(mBlock[n + jWidth3]));</span>
<span class="fc" id="L606">                                l += 4;</span>
<span class="fc" id="L607">                                n += jWidth4;</span>
                            }
<span class="fc bfc" id="L609" title="All 2 branches covered.">                            while (l &lt; lEnd) {</span>
<span class="fc" id="L610">                                sum = sum.add(tBlock[l++].multiply(mBlock[n]));</span>
<span class="fc" id="L611">                                n += jWidth;</span>
                            }
<span class="fc" id="L613">                            outBlock[k] = outBlock[k].add(sum);</span>
<span class="fc" id="L614">                            ++k;</span>
                        }
                    }
                }

                // go to next block
<span class="fc" id="L620">                ++blockIndex;</span>
            }
        }

<span class="fc" id="L624">        return out;</span>
    }

    /** {@inheritDoc} */
    @Override
    public T[][] getData() {

<span class="fc" id="L631">        final T[][] data = MathArrays.buildArray(getField(), getRowDimension(), getColumnDimension());</span>
<span class="fc" id="L632">        final int lastColumns = columns - (blockColumns - 1) * BLOCK_SIZE;</span>

<span class="fc bfc" id="L634" title="All 2 branches covered.">        for (int iBlock = 0; iBlock &lt; blockRows; ++iBlock) {</span>
<span class="fc" id="L635">            final int pStart = iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L636">            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);</span>
<span class="fc" id="L637">            int regularPos   = 0;</span>
<span class="fc" id="L638">            int lastPos      = 0;</span>
<span class="fc bfc" id="L639" title="All 2 branches covered.">            for (int p = pStart; p &lt; pEnd; ++p) {</span>
<span class="fc" id="L640">                final T[] dataP = data[p];</span>
<span class="fc" id="L641">                int blockIndex = iBlock * blockColumns;</span>
<span class="fc" id="L642">                int dataPos    = 0;</span>
<span class="fc bfc" id="L643" title="All 2 branches covered.">                for (int jBlock = 0; jBlock &lt; blockColumns - 1; ++jBlock) {</span>
<span class="fc" id="L644">                    System.arraycopy(blocks[blockIndex++], regularPos, dataP, dataPos, BLOCK_SIZE);</span>
<span class="fc" id="L645">                    dataPos += BLOCK_SIZE;</span>
                }
<span class="fc" id="L647">                System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);</span>
<span class="fc" id="L648">                regularPos += BLOCK_SIZE;</span>
<span class="fc" id="L649">                lastPos    += lastColumns;</span>
            }
        }

<span class="fc" id="L653">        return data;</span>
    }

    /** {@inheritDoc} */
    @Override
    public FieldMatrix&lt;T&gt; getSubMatrix(final int startRow, final int endRow,
                                       final int startColumn,
                                       final int endColumn)
        throws OutOfRangeException, NumberIsTooSmallException {
        // safety checks
<span class="fc" id="L663">        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);</span>

        // create the output matrix
<span class="fc" id="L666">        final BlockFieldMatrix&lt;T&gt; out =</span>
<span class="fc" id="L667">            new BlockFieldMatrix&lt;T&gt;(getField(), endRow - startRow + 1, endColumn - startColumn + 1);</span>

        // compute blocks shifts
<span class="fc" id="L670">        final int blockStartRow    = startRow    / BLOCK_SIZE;</span>
<span class="fc" id="L671">        final int rowsShift        = startRow    % BLOCK_SIZE;</span>
<span class="fc" id="L672">        final int blockStartColumn = startColumn / BLOCK_SIZE;</span>
<span class="fc" id="L673">        final int columnsShift     = startColumn % BLOCK_SIZE;</span>

        // perform extraction block-wise, to ensure good cache behavior
<span class="fc" id="L676">        int pBlock = blockStartRow;</span>
<span class="fc bfc" id="L677" title="All 2 branches covered.">        for (int iBlock = 0; iBlock &lt; out.blockRows; ++iBlock) {</span>
<span class="fc" id="L678">            final int iHeight = out.blockHeight(iBlock);</span>
<span class="fc" id="L679">            int qBlock = blockStartColumn;</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">            for (int jBlock = 0; jBlock &lt; out.blockColumns; ++jBlock) {</span>
<span class="fc" id="L681">                final int jWidth = out.blockWidth(jBlock);</span>

                // handle one block of the output matrix
<span class="fc" id="L684">                final int      outIndex = iBlock * out.blockColumns + jBlock;</span>
<span class="fc" id="L685">                final T[] outBlock = out.blocks[outIndex];</span>
<span class="fc" id="L686">                final int      index    = pBlock * blockColumns + qBlock;</span>
<span class="fc" id="L687">                final int      width    = blockWidth(qBlock);</span>

<span class="fc" id="L689">                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;</span>
<span class="fc" id="L690">                final int widthExcess  = jWidth + columnsShift - BLOCK_SIZE;</span>
<span class="fc bfc" id="L691" title="All 2 branches covered.">                if (heightExcess &gt; 0) {</span>
                    // the submatrix block spans on two blocks rows from the original matrix
<span class="fc bfc" id="L693" title="All 2 branches covered.">                    if (widthExcess &gt; 0) {</span>
                        // the submatrix block spans on two blocks columns from the original matrix
<span class="fc" id="L695">                        final int width2 = blockWidth(qBlock + 1);</span>
<span class="fc" id="L696">                        copyBlockPart(blocks[index], width,</span>
                                      rowsShift, BLOCK_SIZE,
                                      columnsShift, BLOCK_SIZE,
                                      outBlock, jWidth, 0, 0);
<span class="fc" id="L700">                        copyBlockPart(blocks[index + 1], width2,</span>
                                      rowsShift, BLOCK_SIZE,
                                      0, widthExcess,
                                      outBlock, jWidth, 0, jWidth - widthExcess);
<span class="fc" id="L704">                        copyBlockPart(blocks[index + blockColumns], width,</span>
                                      0, heightExcess,
                                      columnsShift, BLOCK_SIZE,
                                      outBlock, jWidth, iHeight - heightExcess, 0);
<span class="fc" id="L708">                        copyBlockPart(blocks[index + blockColumns + 1], width2,</span>
                                      0, heightExcess,
                                      0, widthExcess,
                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);
<span class="fc" id="L712">                    } else {</span>
                        // the submatrix block spans on one block column from the original matrix
<span class="fc" id="L714">                        copyBlockPart(blocks[index], width,</span>
                                      rowsShift, BLOCK_SIZE,
                                      columnsShift, jWidth + columnsShift,
                                      outBlock, jWidth, 0, 0);
<span class="fc" id="L718">                        copyBlockPart(blocks[index + blockColumns], width,</span>
                                      0, heightExcess,
                                      columnsShift, jWidth + columnsShift,
                                      outBlock, jWidth, iHeight - heightExcess, 0);
                    }
                } else {
                    // the submatrix block spans on one block row from the original matrix
<span class="fc bfc" id="L725" title="All 2 branches covered.">                    if (widthExcess &gt; 0) {</span>
                        // the submatrix block spans on two blocks columns from the original matrix
<span class="fc" id="L727">                        final int width2 = blockWidth(qBlock + 1);</span>
<span class="fc" id="L728">                        copyBlockPart(blocks[index], width,</span>
                                      rowsShift, iHeight + rowsShift,
                                      columnsShift, BLOCK_SIZE,
                                      outBlock, jWidth, 0, 0);
<span class="fc" id="L732">                        copyBlockPart(blocks[index + 1], width2,</span>
                                      rowsShift, iHeight + rowsShift,
                                      0, widthExcess,
                                      outBlock, jWidth, 0, jWidth - widthExcess);
<span class="fc" id="L736">                    } else {</span>
                        // the submatrix block spans on one block column from the original matrix
<span class="fc" id="L738">                        copyBlockPart(blocks[index], width,</span>
                                      rowsShift, iHeight + rowsShift,
                                      columnsShift, jWidth + columnsShift,
                                      outBlock, jWidth, 0, 0);
                    }
               }
<span class="fc" id="L744">                ++qBlock;</span>
            }
<span class="fc" id="L746">            ++pBlock;</span>
        }

<span class="fc" id="L749">        return out;</span>
    }

    /**
     * Copy a part of a block into another one
     * &lt;p&gt;This method can be called only when the specified part fits in both
     * blocks, no verification is done here.&lt;/p&gt;
     * @param srcBlock source block
     * @param srcWidth source block width ({@link #BLOCK_SIZE} or smaller)
     * @param srcStartRow start row in the source block
     * @param srcEndRow end row (exclusive) in the source block
     * @param srcStartColumn start column in the source block
     * @param srcEndColumn end column (exclusive) in the source block
     * @param dstBlock destination block
     * @param dstWidth destination block width ({@link #BLOCK_SIZE} or smaller)
     * @param dstStartRow start row in the destination block
     * @param dstStartColumn start column in the destination block
     */
    private void copyBlockPart(final T[] srcBlock, final int srcWidth,
                               final int srcStartRow, final int srcEndRow,
                               final int srcStartColumn, final int srcEndColumn,
                               final T[] dstBlock, final int dstWidth,
                               final int dstStartRow, final int dstStartColumn) {
<span class="fc" id="L772">        final int length = srcEndColumn - srcStartColumn;</span>
<span class="fc" id="L773">        int srcPos = srcStartRow * srcWidth + srcStartColumn;</span>
<span class="fc" id="L774">        int dstPos = dstStartRow * dstWidth + dstStartColumn;</span>
<span class="fc bfc" id="L775" title="All 2 branches covered.">        for (int srcRow = srcStartRow; srcRow &lt; srcEndRow; ++srcRow) {</span>
<span class="fc" id="L776">            System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);</span>
<span class="fc" id="L777">            srcPos += srcWidth;</span>
<span class="fc" id="L778">            dstPos += dstWidth;</span>
        }
<span class="fc" id="L780">    }</span>

    /** {@inheritDoc} */
    @Override
    public void setSubMatrix(final T[][] subMatrix, final int row,
                             final int column)
        throws DimensionMismatchException, OutOfRangeException,
        NoDataException, NullArgumentException {
        // safety checks
<span class="fc" id="L789">        MathUtils.checkNotNull(subMatrix);</span>
<span class="fc" id="L790">        final int refLength = subMatrix[0].length;</span>
<span class="fc bfc" id="L791" title="All 2 branches covered.">        if (refLength == 0) {</span>
<span class="fc" id="L792">            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);</span>
        }
<span class="fc" id="L794">        final int endRow    = row + subMatrix.length - 1;</span>
<span class="fc" id="L795">        final int endColumn = column + refLength - 1;</span>
<span class="fc" id="L796">        checkSubMatrixIndex(row, endRow, column, endColumn);</span>
<span class="fc bfc" id="L797" title="All 2 branches covered.">        for (final T[] subRow : subMatrix) {</span>
<span class="fc bfc" id="L798" title="All 2 branches covered.">            if (subRow.length != refLength) {</span>
<span class="fc" id="L799">                throw new DimensionMismatchException(refLength, subRow.length);</span>
            }
        }

        // compute blocks bounds
<span class="fc" id="L804">        final int blockStartRow    = row / BLOCK_SIZE;</span>
<span class="fc" id="L805">        final int blockEndRow      = (endRow + BLOCK_SIZE) / BLOCK_SIZE;</span>
<span class="fc" id="L806">        final int blockStartColumn = column / BLOCK_SIZE;</span>
<span class="fc" id="L807">        final int blockEndColumn   = (endColumn + BLOCK_SIZE) / BLOCK_SIZE;</span>

        // perform copy block-wise, to ensure good cache behavior
<span class="fc bfc" id="L810" title="All 2 branches covered.">        for (int iBlock = blockStartRow; iBlock &lt; blockEndRow; ++iBlock) {</span>
<span class="fc" id="L811">            final int iHeight  = blockHeight(iBlock);</span>
<span class="fc" id="L812">            final int firstRow = iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L813">            final int iStart   = FastMath.max(row,    firstRow);</span>
<span class="fc" id="L814">            final int iEnd     = FastMath.min(endRow + 1, firstRow + iHeight);</span>

<span class="fc bfc" id="L816" title="All 2 branches covered.">            for (int jBlock = blockStartColumn; jBlock &lt; blockEndColumn; ++jBlock) {</span>
<span class="fc" id="L817">                final int jWidth      = blockWidth(jBlock);</span>
<span class="fc" id="L818">                final int firstColumn = jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L819">                final int jStart      = FastMath.max(column,    firstColumn);</span>
<span class="fc" id="L820">                final int jEnd        = FastMath.min(endColumn + 1, firstColumn + jWidth);</span>
<span class="fc" id="L821">                final int jLength     = jEnd - jStart;</span>

                // handle one block, row by row
<span class="fc" id="L824">                final T[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc bfc" id="L825" title="All 2 branches covered.">                for (int i = iStart; i &lt; iEnd; ++i) {</span>
<span class="fc" id="L826">                    System.arraycopy(subMatrix[i - row], jStart - column,</span>
                                     block, (i - firstRow) * jWidth + (jStart - firstColumn),
                                     jLength);
                }

            }
        }
<span class="fc" id="L833">    }</span>

    /** {@inheritDoc} */
    @Override
    public FieldMatrix&lt;T&gt; getRowMatrix(final int row)
        throws OutOfRangeException {
<span class="fc" id="L839">        checkRowIndex(row);</span>
<span class="fc" id="L840">        final BlockFieldMatrix&lt;T&gt; out = new BlockFieldMatrix&lt;T&gt;(getField(), 1, columns);</span>

        // perform copy block-wise, to ensure good cache behavior
<span class="fc" id="L843">        final int iBlock  = row / BLOCK_SIZE;</span>
<span class="fc" id="L844">        final int iRow    = row - iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L845">        int outBlockIndex = 0;</span>
<span class="fc" id="L846">        int outIndex      = 0;</span>
<span class="fc" id="L847">        T[] outBlock = out.blocks[outBlockIndex];</span>
<span class="fc bfc" id="L848" title="All 2 branches covered.">        for (int jBlock = 0; jBlock &lt; blockColumns; ++jBlock) {</span>
<span class="fc" id="L849">            final int jWidth     = blockWidth(jBlock);</span>
<span class="fc" id="L850">            final T[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc" id="L851">            final int available  = outBlock.length - outIndex;</span>
<span class="fc bfc" id="L852" title="All 2 branches covered.">            if (jWidth &gt; available) {</span>
<span class="fc" id="L853">                System.arraycopy(block, iRow * jWidth, outBlock, outIndex, available);</span>
<span class="fc" id="L854">                outBlock = out.blocks[++outBlockIndex];</span>
<span class="fc" id="L855">                System.arraycopy(block, iRow * jWidth, outBlock, 0, jWidth - available);</span>
<span class="fc" id="L856">                outIndex = jWidth - available;</span>
            } else {
<span class="fc" id="L858">                System.arraycopy(block, iRow * jWidth, outBlock, outIndex, jWidth);</span>
<span class="fc" id="L859">                outIndex += jWidth;</span>
            }
        }

<span class="fc" id="L863">        return out;</span>
    }

    /** {@inheritDoc} */
    @Override
    public void setRowMatrix(final int row, final FieldMatrix&lt;T&gt; matrix)
        throws MatrixDimensionMismatchException, OutOfRangeException {
        try {
<span class="fc" id="L871">            setRowMatrix(row, (BlockFieldMatrix&lt;T&gt;) matrix);</span>
<span class="nc" id="L872">        } catch (ClassCastException cce) {</span>
<span class="nc" id="L873">            super.setRowMatrix(row, matrix);</span>
<span class="fc" id="L874">        }</span>
<span class="fc" id="L875">    }</span>

    /**
     * Sets the entries in row number &lt;code&gt;row&lt;/code&gt;
     * as a row matrix.  Row indices start at 0.
     *
     * @param row the row to be set
     * @param matrix row matrix (must have one row and the same number of columns
     * as the instance)
     * @throws MatrixDimensionMismatchException if the matrix dimensions do
     * not match one instance row.
     * @throws OutOfRangeException if the specified row index is invalid.
     */
    public void setRowMatrix(final int row, final BlockFieldMatrix&lt;T&gt; matrix)
        throws MatrixDimensionMismatchException, OutOfRangeException {
<span class="fc" id="L890">        checkRowIndex(row);</span>
<span class="fc" id="L891">        final int nCols = getColumnDimension();</span>
<span class="fc bfc" id="L892" title="All 2 branches covered.">        if ((matrix.getRowDimension() != 1) ||</span>
<span class="pc bpc" id="L893" title="1 of 2 branches missed.">            (matrix.getColumnDimension() != nCols)) {</span>
<span class="fc" id="L894">            throw new MatrixDimensionMismatchException(matrix.getRowDimension(),</span>
<span class="fc" id="L895">                                                       matrix.getColumnDimension(),</span>
                                                       1, nCols);
        }

        // perform copy block-wise, to ensure good cache behavior
<span class="fc" id="L900">        final int iBlock = row / BLOCK_SIZE;</span>
<span class="fc" id="L901">        final int iRow   = row - iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L902">        int mBlockIndex  = 0;</span>
<span class="fc" id="L903">        int mIndex       = 0;</span>
<span class="fc" id="L904">        T[] mBlock  = matrix.blocks[mBlockIndex];</span>
<span class="fc bfc" id="L905" title="All 2 branches covered.">        for (int jBlock = 0; jBlock &lt; blockColumns; ++jBlock) {</span>
<span class="fc" id="L906">            final int jWidth     = blockWidth(jBlock);</span>
<span class="fc" id="L907">            final T[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc" id="L908">            final int available  = mBlock.length - mIndex;</span>
<span class="fc bfc" id="L909" title="All 2 branches covered.">            if (jWidth &gt; available) {</span>
<span class="fc" id="L910">                System.arraycopy(mBlock, mIndex, block, iRow * jWidth, available);</span>
<span class="fc" id="L911">                mBlock = matrix.blocks[++mBlockIndex];</span>
<span class="fc" id="L912">                System.arraycopy(mBlock, 0, block, iRow * jWidth, jWidth - available);</span>
<span class="fc" id="L913">                mIndex = jWidth - available;</span>
            } else {
<span class="fc" id="L915">                System.arraycopy(mBlock, mIndex, block, iRow * jWidth, jWidth);</span>
<span class="fc" id="L916">                mIndex += jWidth;</span>
           }
        }
<span class="fc" id="L919">    }</span>

    /** {@inheritDoc} */
    @Override
    public FieldMatrix&lt;T&gt; getColumnMatrix(final int column)
        throws OutOfRangeException {
<span class="fc" id="L925">        checkColumnIndex(column);</span>
<span class="fc" id="L926">        final BlockFieldMatrix&lt;T&gt; out = new BlockFieldMatrix&lt;T&gt;(getField(), rows, 1);</span>

        // perform copy block-wise, to ensure good cache behavior
<span class="fc" id="L929">        final int jBlock  = column / BLOCK_SIZE;</span>
<span class="fc" id="L930">        final int jColumn = column - jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L931">        final int jWidth  = blockWidth(jBlock);</span>
<span class="fc" id="L932">        int outBlockIndex = 0;</span>
<span class="fc" id="L933">        int outIndex      = 0;</span>
<span class="fc" id="L934">        T[] outBlock = out.blocks[outBlockIndex];</span>
<span class="fc bfc" id="L935" title="All 2 branches covered.">        for (int iBlock = 0; iBlock &lt; blockRows; ++iBlock) {</span>
<span class="fc" id="L936">            final int iHeight = blockHeight(iBlock);</span>
<span class="fc" id="L937">            final T[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc bfc" id="L938" title="All 2 branches covered.">            for (int i = 0; i &lt; iHeight; ++i) {</span>
<span class="fc bfc" id="L939" title="All 2 branches covered.">                if (outIndex &gt;= outBlock.length) {</span>
<span class="fc" id="L940">                    outBlock = out.blocks[++outBlockIndex];</span>
<span class="fc" id="L941">                    outIndex = 0;</span>
                }
<span class="fc" id="L943">                outBlock[outIndex++] = block[i * jWidth + jColumn];</span>
            }
        }

<span class="fc" id="L947">        return out;</span>
    }

    /** {@inheritDoc} */
    @Override
    public void setColumnMatrix(final int column, final FieldMatrix&lt;T&gt; matrix)
        throws MatrixDimensionMismatchException, OutOfRangeException {
        try {
<span class="fc" id="L955">            setColumnMatrix(column, (BlockFieldMatrix&lt;T&gt;) matrix);</span>
<span class="nc" id="L956">        } catch (ClassCastException cce) {</span>
<span class="nc" id="L957">            super.setColumnMatrix(column, matrix);</span>
<span class="fc" id="L958">        }</span>
<span class="fc" id="L959">    }</span>

    /**
     * Sets the entries in column number {@code column}
     * as a column matrix.  Column indices start at 0.
     *
     * @param column Column to be set.
     * @param matrix Column matrix (must have one column and the same number of rows
     * as the instance).
     * @throws MatrixDimensionMismatchException if the matrix dimensions do
     * not match one instance column.
     * @throws OutOfRangeException if the specified column index is invalid.
     */
    void setColumnMatrix(final int column, final BlockFieldMatrix&lt;T&gt; matrix)
        throws MatrixDimensionMismatchException, OutOfRangeException {
<span class="fc" id="L974">        checkColumnIndex(column);</span>
<span class="fc" id="L975">        final int nRows = getRowDimension();</span>
<span class="pc bpc" id="L976" title="1 of 2 branches missed.">        if ((matrix.getRowDimension() != nRows) ||</span>
<span class="fc bfc" id="L977" title="All 2 branches covered.">            (matrix.getColumnDimension() != 1)) {</span>
<span class="fc" id="L978">            throw new MatrixDimensionMismatchException(matrix.getRowDimension(),</span>
<span class="fc" id="L979">                                                       matrix.getColumnDimension(),</span>
                                                       nRows, 1);
        }

        // perform copy block-wise, to ensure good cache behavior
<span class="fc" id="L984">        final int jBlock  = column / BLOCK_SIZE;</span>
<span class="fc" id="L985">        final int jColumn = column - jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L986">        final int jWidth  = blockWidth(jBlock);</span>
<span class="fc" id="L987">        int mBlockIndex = 0;</span>
<span class="fc" id="L988">        int mIndex      = 0;</span>
<span class="fc" id="L989">        T[] mBlock = matrix.blocks[mBlockIndex];</span>
<span class="fc bfc" id="L990" title="All 2 branches covered.">        for (int iBlock = 0; iBlock &lt; blockRows; ++iBlock) {</span>
<span class="fc" id="L991">            final int iHeight = blockHeight(iBlock);</span>
<span class="fc" id="L992">            final T[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc bfc" id="L993" title="All 2 branches covered.">            for (int i = 0; i &lt; iHeight; ++i) {</span>
<span class="fc bfc" id="L994" title="All 2 branches covered.">                if (mIndex &gt;= mBlock.length) {</span>
<span class="fc" id="L995">                    mBlock = matrix.blocks[++mBlockIndex];</span>
<span class="fc" id="L996">                    mIndex = 0;</span>
                }
<span class="fc" id="L998">                block[i * jWidth + jColumn] = mBlock[mIndex++];</span>
            }
        }
<span class="fc" id="L1001">    }</span>

    /** {@inheritDoc} */
    @Override
    public FieldVector&lt;T&gt; getRowVector(final int row)
        throws OutOfRangeException {
<span class="fc" id="L1007">        checkRowIndex(row);</span>
<span class="fc" id="L1008">        final T[] outData = MathArrays.buildArray(getField(), columns);</span>

        // perform copy block-wise, to ensure good cache behavior
<span class="fc" id="L1011">        final int iBlock  = row / BLOCK_SIZE;</span>
<span class="fc" id="L1012">        final int iRow    = row - iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1013">        int outIndex      = 0;</span>
<span class="fc bfc" id="L1014" title="All 2 branches covered.">        for (int jBlock = 0; jBlock &lt; blockColumns; ++jBlock) {</span>
<span class="fc" id="L1015">            final int jWidth     = blockWidth(jBlock);</span>
<span class="fc" id="L1016">            final T[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc" id="L1017">            System.arraycopy(block, iRow * jWidth, outData, outIndex, jWidth);</span>
<span class="fc" id="L1018">            outIndex += jWidth;</span>
        }

<span class="fc" id="L1021">        return new ArrayFieldVector&lt;T&gt;(getField(), outData, false);</span>
    }

    /** {@inheritDoc} */
    @Override
    public void setRowVector(final int row, final FieldVector&lt;T&gt; vector)
        throws MatrixDimensionMismatchException, OutOfRangeException {
        try {
<span class="fc" id="L1029">            setRow(row, ((ArrayFieldVector&lt;T&gt;) vector).getDataRef());</span>
<span class="nc" id="L1030">        } catch (ClassCastException cce) {</span>
<span class="nc" id="L1031">            super.setRowVector(row, vector);</span>
<span class="fc" id="L1032">        }</span>
<span class="fc" id="L1033">    }</span>

    /** {@inheritDoc} */
    @Override
    public FieldVector&lt;T&gt; getColumnVector(final int column)
        throws OutOfRangeException {
<span class="fc" id="L1039">        checkColumnIndex(column);</span>
<span class="fc" id="L1040">        final T[] outData = MathArrays.buildArray(getField(), rows);</span>

        // perform copy block-wise, to ensure good cache behavior
<span class="fc" id="L1043">        final int jBlock  = column / BLOCK_SIZE;</span>
<span class="fc" id="L1044">        final int jColumn = column - jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1045">        final int jWidth  = blockWidth(jBlock);</span>
<span class="fc" id="L1046">        int outIndex      = 0;</span>
<span class="fc bfc" id="L1047" title="All 2 branches covered.">        for (int iBlock = 0; iBlock &lt; blockRows; ++iBlock) {</span>
<span class="fc" id="L1048">            final int iHeight = blockHeight(iBlock);</span>
<span class="fc" id="L1049">            final T[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc bfc" id="L1050" title="All 2 branches covered.">            for (int i = 0; i &lt; iHeight; ++i) {</span>
<span class="fc" id="L1051">                outData[outIndex++] = block[i * jWidth + jColumn];</span>
            }
        }

<span class="fc" id="L1055">        return new ArrayFieldVector&lt;T&gt;(getField(), outData, false);</span>
    }

    /** {@inheritDoc} */
    @Override
    public void setColumnVector(final int column, final FieldVector&lt;T&gt; vector)
        throws OutOfRangeException, MatrixDimensionMismatchException {
        try {
<span class="fc" id="L1063">            setColumn(column, ((ArrayFieldVector&lt;T&gt;) vector).getDataRef());</span>
<span class="nc" id="L1064">        } catch (ClassCastException cce) {</span>
<span class="nc" id="L1065">            super.setColumnVector(column, vector);</span>
<span class="fc" id="L1066">        }</span>
<span class="fc" id="L1067">    }</span>

    /** {@inheritDoc} */
    @Override
    public T[] getRow(final int row) throws OutOfRangeException {
<span class="fc" id="L1072">        checkRowIndex(row);</span>
<span class="fc" id="L1073">        final T[] out = MathArrays.buildArray(getField(), columns);</span>

        // perform copy block-wise, to ensure good cache behavior
<span class="fc" id="L1076">        final int iBlock  = row / BLOCK_SIZE;</span>
<span class="fc" id="L1077">        final int iRow    = row - iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1078">        int outIndex      = 0;</span>
<span class="fc bfc" id="L1079" title="All 2 branches covered.">        for (int jBlock = 0; jBlock &lt; blockColumns; ++jBlock) {</span>
<span class="fc" id="L1080">            final int jWidth     = blockWidth(jBlock);</span>
<span class="fc" id="L1081">            final T[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc" id="L1082">            System.arraycopy(block, iRow * jWidth, out, outIndex, jWidth);</span>
<span class="fc" id="L1083">            outIndex += jWidth;</span>
        }

<span class="fc" id="L1086">        return out;</span>
    }

    /** {@inheritDoc} */
    @Override
    public void setRow(final int row, final T[] array)
        throws OutOfRangeException, MatrixDimensionMismatchException {
<span class="fc" id="L1093">        checkRowIndex(row);</span>
<span class="fc" id="L1094">        final int nCols = getColumnDimension();</span>
<span class="fc bfc" id="L1095" title="All 2 branches covered.">        if (array.length != nCols) {</span>
<span class="fc" id="L1096">            throw new MatrixDimensionMismatchException(1, array.length, 1, nCols);</span>
        }

        // perform copy block-wise, to ensure good cache behavior
<span class="fc" id="L1100">        final int iBlock  = row / BLOCK_SIZE;</span>
<span class="fc" id="L1101">        final int iRow    = row - iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1102">        int outIndex      = 0;</span>
<span class="fc bfc" id="L1103" title="All 2 branches covered.">        for (int jBlock = 0; jBlock &lt; blockColumns; ++jBlock) {</span>
<span class="fc" id="L1104">            final int jWidth     = blockWidth(jBlock);</span>
<span class="fc" id="L1105">            final T[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc" id="L1106">            System.arraycopy(array, outIndex, block, iRow * jWidth, jWidth);</span>
<span class="fc" id="L1107">            outIndex += jWidth;</span>
        }
<span class="fc" id="L1109">    }</span>

    /** {@inheritDoc} */
    @Override
    public T[] getColumn(final int column) throws OutOfRangeException {
<span class="fc" id="L1114">        checkColumnIndex(column);</span>
<span class="fc" id="L1115">        final T[] out = MathArrays.buildArray(getField(), rows);</span>

        // perform copy block-wise, to ensure good cache behavior
<span class="fc" id="L1118">        final int jBlock  = column / BLOCK_SIZE;</span>
<span class="fc" id="L1119">        final int jColumn = column - jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1120">        final int jWidth  = blockWidth(jBlock);</span>
<span class="fc" id="L1121">        int outIndex      = 0;</span>
<span class="fc bfc" id="L1122" title="All 2 branches covered.">        for (int iBlock = 0; iBlock &lt; blockRows; ++iBlock) {</span>
<span class="fc" id="L1123">            final int iHeight = blockHeight(iBlock);</span>
<span class="fc" id="L1124">            final T[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc bfc" id="L1125" title="All 2 branches covered.">            for (int i = 0; i &lt; iHeight; ++i) {</span>
<span class="fc" id="L1126">                out[outIndex++] = block[i * jWidth + jColumn];</span>
            }
        }

<span class="fc" id="L1130">        return out;</span>
    }

    /** {@inheritDoc} */
    @Override
    public void setColumn(final int column, final T[] array)
        throws MatrixDimensionMismatchException, OutOfRangeException {
<span class="fc" id="L1137">        checkColumnIndex(column);</span>
<span class="fc" id="L1138">        final int nRows = getRowDimension();</span>
<span class="fc bfc" id="L1139" title="All 2 branches covered.">        if (array.length != nRows) {</span>
<span class="fc" id="L1140">            throw new MatrixDimensionMismatchException(array.length, 1, nRows, 1);</span>
        }

        // perform copy block-wise, to ensure good cache behavior
<span class="fc" id="L1144">        final int jBlock  = column / BLOCK_SIZE;</span>
<span class="fc" id="L1145">        final int jColumn = column - jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1146">        final int jWidth  = blockWidth(jBlock);</span>
<span class="fc" id="L1147">        int outIndex      = 0;</span>
<span class="fc bfc" id="L1148" title="All 2 branches covered.">        for (int iBlock = 0; iBlock &lt; blockRows; ++iBlock) {</span>
<span class="fc" id="L1149">            final int iHeight = blockHeight(iBlock);</span>
<span class="fc" id="L1150">            final T[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc bfc" id="L1151" title="All 2 branches covered.">            for (int i = 0; i &lt; iHeight; ++i) {</span>
<span class="fc" id="L1152">                block[i * jWidth + jColumn] = array[outIndex++];</span>
            }
        }
<span class="fc" id="L1155">    }</span>

    /** {@inheritDoc} */
    @Override
    public T getEntry(final int row, final int column)
        throws OutOfRangeException {
<span class="fc" id="L1161">        checkRowIndex(row);</span>
<span class="fc" id="L1162">        checkColumnIndex(column);</span>

<span class="fc" id="L1164">        final int iBlock = row    / BLOCK_SIZE;</span>
<span class="fc" id="L1165">        final int jBlock = column / BLOCK_SIZE;</span>
<span class="fc" id="L1166">        final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +</span>
            (column - jBlock * BLOCK_SIZE);

<span class="fc" id="L1169">        return blocks[iBlock * blockColumns + jBlock][k];</span>
    }

    /** {@inheritDoc} */
    @Override
    public void setEntry(final int row, final int column, final T value)
        throws OutOfRangeException {
<span class="fc" id="L1176">        checkRowIndex(row);</span>
<span class="fc" id="L1177">        checkColumnIndex(column);</span>

<span class="fc" id="L1179">        final int iBlock = row    / BLOCK_SIZE;</span>
<span class="fc" id="L1180">        final int jBlock = column / BLOCK_SIZE;</span>
<span class="fc" id="L1181">        final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +</span>
            (column - jBlock * BLOCK_SIZE);

<span class="fc" id="L1184">        blocks[iBlock * blockColumns + jBlock][k] = value;</span>
<span class="fc" id="L1185">    }</span>

    /** {@inheritDoc} */
    @Override
    public void addToEntry(final int row, final int column, final T increment)
        throws OutOfRangeException {
<span class="nc" id="L1191">        checkRowIndex(row);</span>
<span class="nc" id="L1192">        checkColumnIndex(column);</span>

<span class="nc" id="L1194">        final int iBlock = row    / BLOCK_SIZE;</span>
<span class="nc" id="L1195">        final int jBlock = column / BLOCK_SIZE;</span>
<span class="nc" id="L1196">        final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +</span>
            (column - jBlock * BLOCK_SIZE);
<span class="nc" id="L1198">        final T[] blockIJ = blocks[iBlock * blockColumns + jBlock];</span>

<span class="nc" id="L1200">        blockIJ[k] = blockIJ[k].add(increment);</span>
<span class="nc" id="L1201">    }</span>

    /** {@inheritDoc} */
    @Override
    public void multiplyEntry(final int row, final int column, final T factor)
        throws OutOfRangeException {
<span class="nc" id="L1207">        checkRowIndex(row);</span>
<span class="nc" id="L1208">        checkColumnIndex(column);</span>

<span class="nc" id="L1210">        final int iBlock = row    / BLOCK_SIZE;</span>
<span class="nc" id="L1211">        final int jBlock = column / BLOCK_SIZE;</span>
<span class="nc" id="L1212">        final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +</span>
            (column - jBlock * BLOCK_SIZE);
<span class="nc" id="L1214">        final T[] blockIJ = blocks[iBlock * blockColumns + jBlock];</span>

<span class="nc" id="L1216">        blockIJ[k] = blockIJ[k].multiply(factor);</span>
<span class="nc" id="L1217">    }</span>

    /** {@inheritDoc} */
    @Override
    public FieldMatrix&lt;T&gt; transpose() {
<span class="fc" id="L1222">        final int nRows = getRowDimension();</span>
<span class="fc" id="L1223">        final int nCols = getColumnDimension();</span>
<span class="fc" id="L1224">        final BlockFieldMatrix&lt;T&gt; out = new BlockFieldMatrix&lt;T&gt;(getField(), nCols, nRows);</span>

        // perform transpose block-wise, to ensure good cache behavior
<span class="fc" id="L1227">        int blockIndex = 0;</span>
<span class="fc bfc" id="L1228" title="All 2 branches covered.">        for (int iBlock = 0; iBlock &lt; blockColumns; ++iBlock) {</span>
<span class="fc bfc" id="L1229" title="All 2 branches covered.">            for (int jBlock = 0; jBlock &lt; blockRows; ++jBlock) {</span>

                // transpose current block
<span class="fc" id="L1232">                final T[] outBlock = out.blocks[blockIndex];</span>
<span class="fc" id="L1233">                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];</span>
<span class="fc" id="L1234">                final int      pStart   = iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1235">                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);</span>
<span class="fc" id="L1236">                final int      qStart   = jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1237">                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);</span>
<span class="fc" id="L1238">                int k = 0;</span>
<span class="fc bfc" id="L1239" title="All 2 branches covered.">                for (int p = pStart; p &lt; pEnd; ++p) {</span>
<span class="fc" id="L1240">                    final int lInc = pEnd - pStart;</span>
<span class="fc" id="L1241">                    int l = p - pStart;</span>
<span class="fc bfc" id="L1242" title="All 2 branches covered.">                    for (int q = qStart; q &lt; qEnd; ++q) {</span>
<span class="fc" id="L1243">                        outBlock[k] = tBlock[l];</span>
<span class="fc" id="L1244">                        ++k;</span>
<span class="fc" id="L1245">                        l+= lInc;</span>
                    }
                }

                // go to next block
<span class="fc" id="L1250">                ++blockIndex;</span>

            }
        }

<span class="fc" id="L1255">        return out;</span>
    }

    /** {@inheritDoc} */
    @Override
    public int getRowDimension() {
<span class="fc" id="L1261">        return rows;</span>
    }

    /** {@inheritDoc} */
    @Override
    public int getColumnDimension() {
<span class="fc" id="L1267">        return columns;</span>
    }

    /** {@inheritDoc} */
    @Override
    public T[] operate(final T[] v) throws DimensionMismatchException {
<span class="fc bfc" id="L1273" title="All 2 branches covered.">        if (v.length != columns) {</span>
<span class="fc" id="L1274">            throw new DimensionMismatchException(v.length, columns);</span>
        }
<span class="fc" id="L1276">        final T[] out = MathArrays.buildArray(getField(), rows);</span>
<span class="fc" id="L1277">        final T zero = getField().getZero();</span>

        // perform multiplication block-wise, to ensure good cache behavior
<span class="fc bfc" id="L1280" title="All 2 branches covered.">        for (int iBlock = 0; iBlock &lt; blockRows; ++iBlock) {</span>
<span class="fc" id="L1281">            final int pStart = iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1282">            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);</span>
<span class="fc bfc" id="L1283" title="All 2 branches covered.">            for (int jBlock = 0; jBlock &lt; blockColumns; ++jBlock) {</span>
<span class="fc" id="L1284">                final T[] block  = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc" id="L1285">                final int      qStart = jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1286">                final int      qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);</span>
<span class="fc" id="L1287">                int k = 0;</span>
<span class="fc bfc" id="L1288" title="All 2 branches covered.">                for (int p = pStart; p &lt; pEnd; ++p) {</span>
<span class="fc" id="L1289">                    T sum = zero;</span>
<span class="fc" id="L1290">                    int q = qStart;</span>
<span class="fc bfc" id="L1291" title="All 2 branches covered.">                    while (q &lt; qEnd - 3) {</span>
<span class="fc" id="L1292">                        sum = sum.</span>
<span class="fc" id="L1293">                              add(block[k].multiply(v[q])).</span>
<span class="fc" id="L1294">                              add(block[k + 1].multiply(v[q + 1])).</span>
<span class="fc" id="L1295">                              add(block[k + 2].multiply(v[q + 2])).</span>
<span class="fc" id="L1296">                              add(block[k + 3].multiply(v[q + 3]));</span>
<span class="fc" id="L1297">                        k += 4;</span>
<span class="fc" id="L1298">                        q += 4;</span>
                    }
<span class="fc bfc" id="L1300" title="All 2 branches covered.">                    while (q &lt; qEnd) {</span>
<span class="fc" id="L1301">                        sum = sum.add(block[k++].multiply(v[q++]));</span>
                    }
<span class="fc" id="L1303">                    out[p] = out[p].add(sum);</span>
                }
            }
        }

<span class="fc" id="L1308">        return out;</span>
    }

    /** {@inheritDoc} */
    @Override
    public T[] preMultiply(final T[] v) throws DimensionMismatchException {

<span class="fc bfc" id="L1315" title="All 2 branches covered.">        if (v.length != rows) {</span>
<span class="fc" id="L1316">            throw new DimensionMismatchException(v.length, rows);</span>
        }
<span class="fc" id="L1318">        final T[] out = MathArrays.buildArray(getField(), columns);</span>
<span class="fc" id="L1319">        final T zero = getField().getZero();</span>

        // perform multiplication block-wise, to ensure good cache behavior
<span class="fc bfc" id="L1322" title="All 2 branches covered.">        for (int jBlock = 0; jBlock &lt; blockColumns; ++jBlock) {</span>
<span class="fc" id="L1323">            final int jWidth  = blockWidth(jBlock);</span>
<span class="fc" id="L1324">            final int jWidth2 = jWidth  + jWidth;</span>
<span class="fc" id="L1325">            final int jWidth3 = jWidth2 + jWidth;</span>
<span class="fc" id="L1326">            final int jWidth4 = jWidth3 + jWidth;</span>
<span class="fc" id="L1327">            final int qStart = jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1328">            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);</span>
<span class="fc bfc" id="L1329" title="All 2 branches covered.">            for (int iBlock = 0; iBlock &lt; blockRows; ++iBlock) {</span>
<span class="fc" id="L1330">                final T[] block  = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc" id="L1331">                final int      pStart = iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1332">                final int      pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);</span>
<span class="fc bfc" id="L1333" title="All 2 branches covered.">                for (int q = qStart; q &lt; qEnd; ++q) {</span>
<span class="fc" id="L1334">                    int k = q - qStart;</span>
<span class="fc" id="L1335">                    T sum = zero;</span>
<span class="fc" id="L1336">                    int p = pStart;</span>
<span class="fc bfc" id="L1337" title="All 2 branches covered.">                    while (p &lt; pEnd - 3) {</span>
<span class="fc" id="L1338">                        sum = sum.</span>
<span class="fc" id="L1339">                              add(block[k].multiply(v[p])).</span>
<span class="fc" id="L1340">                              add(block[k + jWidth].multiply(v[p + 1])).</span>
<span class="fc" id="L1341">                              add(block[k + jWidth2].multiply(v[p + 2])).</span>
<span class="fc" id="L1342">                              add(block[k + jWidth3].multiply(v[p + 3]));</span>
<span class="fc" id="L1343">                        k += jWidth4;</span>
<span class="fc" id="L1344">                        p += 4;</span>
                    }
<span class="fc bfc" id="L1346" title="All 2 branches covered.">                    while (p &lt; pEnd) {</span>
<span class="fc" id="L1347">                        sum = sum.add(block[k].multiply(v[p++]));</span>
<span class="fc" id="L1348">                        k += jWidth;</span>
                    }
<span class="fc" id="L1350">                    out[q] = out[q].add(sum);</span>
                }
            }
        }

<span class="fc" id="L1355">        return out;</span>
    }

    /** {@inheritDoc} */
    @Override
    public T walkInRowOrder(final FieldMatrixChangingVisitor&lt;T&gt; visitor) {
<span class="fc" id="L1361">        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);</span>
<span class="fc bfc" id="L1362" title="All 2 branches covered.">        for (int iBlock = 0; iBlock &lt; blockRows; ++iBlock) {</span>
<span class="fc" id="L1363">            final int pStart = iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1364">            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);</span>
<span class="fc bfc" id="L1365" title="All 2 branches covered.">            for (int p = pStart; p &lt; pEnd; ++p) {</span>
<span class="fc bfc" id="L1366" title="All 2 branches covered.">                for (int jBlock = 0; jBlock &lt; blockColumns; ++jBlock) {</span>
<span class="fc" id="L1367">                    final int jWidth = blockWidth(jBlock);</span>
<span class="fc" id="L1368">                    final int qStart = jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1369">                    final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);</span>
<span class="fc" id="L1370">                    final T[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc" id="L1371">                    int k = (p - pStart) * jWidth;</span>
<span class="fc bfc" id="L1372" title="All 2 branches covered.">                    for (int q = qStart; q &lt; qEnd; ++q) {</span>
<span class="fc" id="L1373">                        block[k] = visitor.visit(p, q, block[k]);</span>
<span class="fc" id="L1374">                        ++k;</span>
                    }
                }
             }
        }
<span class="fc" id="L1379">        return visitor.end();</span>
    }

    /** {@inheritDoc} */
    @Override
    public T walkInRowOrder(final FieldMatrixPreservingVisitor&lt;T&gt; visitor) {
<span class="fc" id="L1385">        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);</span>
<span class="fc bfc" id="L1386" title="All 2 branches covered.">        for (int iBlock = 0; iBlock &lt; blockRows; ++iBlock) {</span>
<span class="fc" id="L1387">            final int pStart = iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1388">            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);</span>
<span class="fc bfc" id="L1389" title="All 2 branches covered.">            for (int p = pStart; p &lt; pEnd; ++p) {</span>
<span class="fc bfc" id="L1390" title="All 2 branches covered.">                for (int jBlock = 0; jBlock &lt; blockColumns; ++jBlock) {</span>
<span class="fc" id="L1391">                    final int jWidth = blockWidth(jBlock);</span>
<span class="fc" id="L1392">                    final int qStart = jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1393">                    final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);</span>
<span class="fc" id="L1394">                    final T[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc" id="L1395">                    int k = (p - pStart) * jWidth;</span>
<span class="fc bfc" id="L1396" title="All 2 branches covered.">                    for (int q = qStart; q &lt; qEnd; ++q) {</span>
<span class="fc" id="L1397">                        visitor.visit(p, q, block[k]);</span>
<span class="fc" id="L1398">                        ++k;</span>
                    }
                }
             }
        }
<span class="fc" id="L1403">        return visitor.end();</span>
    }

    /** {@inheritDoc} */
    @Override
    public T walkInRowOrder(final FieldMatrixChangingVisitor&lt;T&gt; visitor,
                            final int startRow, final int endRow,
                            final int startColumn, final int endColumn)
        throws OutOfRangeException, NumberIsTooSmallException {
<span class="fc" id="L1412">        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);</span>
<span class="fc" id="L1413">        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);</span>
<span class="fc bfc" id="L1414" title="All 2 branches covered.">        for (int iBlock = startRow / BLOCK_SIZE; iBlock &lt; 1 + endRow / BLOCK_SIZE; ++iBlock) {</span>
<span class="fc" id="L1415">            final int p0     = iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1416">            final int pStart = FastMath.max(startRow, p0);</span>
<span class="fc" id="L1417">            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);</span>
<span class="fc bfc" id="L1418" title="All 2 branches covered.">            for (int p = pStart; p &lt; pEnd; ++p) {</span>
<span class="fc bfc" id="L1419" title="All 2 branches covered.">                for (int jBlock = startColumn / BLOCK_SIZE; jBlock &lt; 1 + endColumn / BLOCK_SIZE; ++jBlock) {</span>
<span class="fc" id="L1420">                    final int jWidth = blockWidth(jBlock);</span>
<span class="fc" id="L1421">                    final int q0     = jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1422">                    final int qStart = FastMath.max(startColumn, q0);</span>
<span class="fc" id="L1423">                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);</span>
<span class="fc" id="L1424">                    final T[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc" id="L1425">                    int k = (p - p0) * jWidth + qStart - q0;</span>
<span class="fc bfc" id="L1426" title="All 2 branches covered.">                    for (int q = qStart; q &lt; qEnd; ++q) {</span>
<span class="fc" id="L1427">                        block[k] = visitor.visit(p, q, block[k]);</span>
<span class="fc" id="L1428">                        ++k;</span>
                    }
                }
             }
        }
<span class="fc" id="L1433">        return visitor.end();</span>
    }

    /** {@inheritDoc} */
    @Override
    public T walkInRowOrder(final FieldMatrixPreservingVisitor&lt;T&gt; visitor,
                            final int startRow, final int endRow,
                            final int startColumn, final int endColumn)
        throws OutOfRangeException, NumberIsTooSmallException {
<span class="fc" id="L1442">        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);</span>
<span class="fc" id="L1443">        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);</span>
<span class="fc bfc" id="L1444" title="All 2 branches covered.">        for (int iBlock = startRow / BLOCK_SIZE; iBlock &lt; 1 + endRow / BLOCK_SIZE; ++iBlock) {</span>
<span class="fc" id="L1445">            final int p0     = iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1446">            final int pStart = FastMath.max(startRow, p0);</span>
<span class="fc" id="L1447">            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);</span>
<span class="fc bfc" id="L1448" title="All 2 branches covered.">            for (int p = pStart; p &lt; pEnd; ++p) {</span>
<span class="fc bfc" id="L1449" title="All 2 branches covered.">                for (int jBlock = startColumn / BLOCK_SIZE; jBlock &lt; 1 + endColumn / BLOCK_SIZE; ++jBlock) {</span>
<span class="fc" id="L1450">                    final int jWidth = blockWidth(jBlock);</span>
<span class="fc" id="L1451">                    final int q0     = jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1452">                    final int qStart = FastMath.max(startColumn, q0);</span>
<span class="fc" id="L1453">                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);</span>
<span class="fc" id="L1454">                    final T[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc" id="L1455">                    int k = (p - p0) * jWidth + qStart - q0;</span>
<span class="fc bfc" id="L1456" title="All 2 branches covered.">                    for (int q = qStart; q &lt; qEnd; ++q) {</span>
<span class="fc" id="L1457">                        visitor.visit(p, q, block[k]);</span>
<span class="fc" id="L1458">                        ++k;</span>
                    }
                }
             }
        }
<span class="fc" id="L1463">        return visitor.end();</span>
    }

    /** {@inheritDoc} */
    @Override
    public T walkInOptimizedOrder(final FieldMatrixChangingVisitor&lt;T&gt; visitor) {
<span class="fc" id="L1469">        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);</span>
<span class="fc" id="L1470">        int blockIndex = 0;</span>
<span class="fc bfc" id="L1471" title="All 2 branches covered.">        for (int iBlock = 0; iBlock &lt; blockRows; ++iBlock) {</span>
<span class="fc" id="L1472">            final int pStart = iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1473">            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);</span>
<span class="fc bfc" id="L1474" title="All 2 branches covered.">            for (int jBlock = 0; jBlock &lt; blockColumns; ++jBlock) {</span>
<span class="fc" id="L1475">                final int qStart = jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1476">                final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);</span>
<span class="fc" id="L1477">                final T[] block = blocks[blockIndex];</span>
<span class="fc" id="L1478">                int k = 0;</span>
<span class="fc bfc" id="L1479" title="All 2 branches covered.">                for (int p = pStart; p &lt; pEnd; ++p) {</span>
<span class="fc bfc" id="L1480" title="All 2 branches covered.">                    for (int q = qStart; q &lt; qEnd; ++q) {</span>
<span class="fc" id="L1481">                        block[k] = visitor.visit(p, q, block[k]);</span>
<span class="fc" id="L1482">                        ++k;</span>
                    }
                }
<span class="fc" id="L1485">                ++blockIndex;</span>
            }
        }
<span class="fc" id="L1488">        return visitor.end();</span>
    }

    /** {@inheritDoc} */
    @Override
    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor&lt;T&gt; visitor) {
<span class="fc" id="L1494">        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);</span>
<span class="fc" id="L1495">        int blockIndex = 0;</span>
<span class="fc bfc" id="L1496" title="All 2 branches covered.">        for (int iBlock = 0; iBlock &lt; blockRows; ++iBlock) {</span>
<span class="fc" id="L1497">            final int pStart = iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1498">            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);</span>
<span class="fc bfc" id="L1499" title="All 2 branches covered.">            for (int jBlock = 0; jBlock &lt; blockColumns; ++jBlock) {</span>
<span class="fc" id="L1500">                final int qStart = jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1501">                final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);</span>
<span class="fc" id="L1502">                final T[] block = blocks[blockIndex];</span>
<span class="fc" id="L1503">                int k = 0;</span>
<span class="fc bfc" id="L1504" title="All 2 branches covered.">                for (int p = pStart; p &lt; pEnd; ++p) {</span>
<span class="fc bfc" id="L1505" title="All 2 branches covered.">                    for (int q = qStart; q &lt; qEnd; ++q) {</span>
<span class="fc" id="L1506">                        visitor.visit(p, q, block[k]);</span>
<span class="fc" id="L1507">                        ++k;</span>
                    }
                }
<span class="fc" id="L1510">                ++blockIndex;</span>
            }
        }
<span class="fc" id="L1513">        return visitor.end();</span>
    }

    /** {@inheritDoc} */
    @Override
    public T walkInOptimizedOrder(final FieldMatrixChangingVisitor&lt;T&gt; visitor,
                                  final int startRow, final int endRow,
                                  final int startColumn, final int endColumn)
        throws OutOfRangeException, NumberIsTooSmallException {
<span class="fc" id="L1522">        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);</span>
<span class="fc" id="L1523">        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);</span>
<span class="fc bfc" id="L1524" title="All 2 branches covered.">        for (int iBlock = startRow / BLOCK_SIZE; iBlock &lt; 1 + endRow / BLOCK_SIZE; ++iBlock) {</span>
<span class="fc" id="L1525">            final int p0     = iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1526">            final int pStart = FastMath.max(startRow, p0);</span>
<span class="fc" id="L1527">            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);</span>
<span class="fc bfc" id="L1528" title="All 2 branches covered.">            for (int jBlock = startColumn / BLOCK_SIZE; jBlock &lt; 1 + endColumn / BLOCK_SIZE; ++jBlock) {</span>
<span class="fc" id="L1529">                final int jWidth = blockWidth(jBlock);</span>
<span class="fc" id="L1530">                final int q0     = jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1531">                final int qStart = FastMath.max(startColumn, q0);</span>
<span class="fc" id="L1532">                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);</span>
<span class="fc" id="L1533">                final T[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc bfc" id="L1534" title="All 2 branches covered.">                for (int p = pStart; p &lt; pEnd; ++p) {</span>
<span class="fc" id="L1535">                    int k = (p - p0) * jWidth + qStart - q0;</span>
<span class="fc bfc" id="L1536" title="All 2 branches covered.">                    for (int q = qStart; q &lt; qEnd; ++q) {</span>
<span class="fc" id="L1537">                        block[k] = visitor.visit(p, q, block[k]);</span>
<span class="fc" id="L1538">                        ++k;</span>
                    }
                }
            }
        }
<span class="fc" id="L1543">        return visitor.end();</span>
    }

    /** {@inheritDoc} */
    @Override
    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor&lt;T&gt; visitor,
                                  final int startRow, final int endRow,
                                  final int startColumn, final int endColumn)
        throws OutOfRangeException, NumberIsTooSmallException {
<span class="fc" id="L1552">        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);</span>
<span class="fc" id="L1553">        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);</span>
<span class="fc bfc" id="L1554" title="All 2 branches covered.">        for (int iBlock = startRow / BLOCK_SIZE; iBlock &lt; 1 + endRow / BLOCK_SIZE; ++iBlock) {</span>
<span class="fc" id="L1555">            final int p0     = iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1556">            final int pStart = FastMath.max(startRow, p0);</span>
<span class="fc" id="L1557">            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);</span>
<span class="fc bfc" id="L1558" title="All 2 branches covered.">            for (int jBlock = startColumn / BLOCK_SIZE; jBlock &lt; 1 + endColumn / BLOCK_SIZE; ++jBlock) {</span>
<span class="fc" id="L1559">                final int jWidth = blockWidth(jBlock);</span>
<span class="fc" id="L1560">                final int q0     = jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1561">                final int qStart = FastMath.max(startColumn, q0);</span>
<span class="fc" id="L1562">                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);</span>
<span class="fc" id="L1563">                final T[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc bfc" id="L1564" title="All 2 branches covered.">                for (int p = pStart; p &lt; pEnd; ++p) {</span>
<span class="fc" id="L1565">                    int k = (p - p0) * jWidth + qStart - q0;</span>
<span class="fc bfc" id="L1566" title="All 2 branches covered.">                    for (int q = qStart; q &lt; qEnd; ++q) {</span>
<span class="fc" id="L1567">                        visitor.visit(p, q, block[k]);</span>
<span class="fc" id="L1568">                        ++k;</span>
                    }
                }
            }
        }
<span class="fc" id="L1573">        return visitor.end();</span>
    }

    /**
     * Get the height of a block.
     * @param blockRow row index (in block sense) of the block
     * @return height (number of rows) of the block
     */
    private int blockHeight(final int blockRow) {
<span class="fc bfc" id="L1582" title="All 2 branches covered.">        return (blockRow == blockRows - 1) ? rows - blockRow * BLOCK_SIZE : BLOCK_SIZE;</span>
    }

    /**
     * Get the width of a block.
     * @param blockColumn column index (in block sense) of the block
     * @return width (number of columns) of the block
     */
    private int blockWidth(final int blockColumn) {
<span class="fc bfc" id="L1591" title="All 2 branches covered.">        return (blockColumn == blockColumns - 1) ? columns - blockColumn * BLOCK_SIZE : BLOCK_SIZE;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>