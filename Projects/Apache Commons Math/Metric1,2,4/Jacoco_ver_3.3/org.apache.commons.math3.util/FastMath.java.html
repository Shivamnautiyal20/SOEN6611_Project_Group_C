<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FastMath.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Math</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math3.util</a> &gt; <span class="el_source">FastMath.java</span></div><h1>FastMath.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.math3.util;

import java.io.PrintStream;

/**
 * Faster, more accurate, portable alternative to {@link Math} and
 * {@link StrictMath} for large scale computation.
 * &lt;p&gt;
 * FastMath is a drop-in replacement for both Math and StrictMath. This
 * means that for any method in Math (say {@code Math.sin(x)} or
 * {@code Math.cbrt(y)}), user can directly change the class and use the
 * methods as is (using {@code FastMath.sin(x)} or {@code FastMath.cbrt(y)}
 * in the previous example).
 * &lt;/p&gt;
 * &lt;p&gt;
 * FastMath speed is achieved by relying heavily on optimizing compilers
 * to native code present in many JVMs today and use of large tables.
 * The larger tables are lazily initialised on first use, so that the setup
 * time does not penalise methods that don't need them.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Note that FastMath is
 * extensively used inside Apache Commons Math, so by calling some algorithms,
 * the overhead when the the tables need to be intialised will occur
 * regardless of the end-user calling FastMath methods directly or not.
 * Performance figures for a specific JVM and hardware can be evaluated by
 * running the FastMathTestPerformance tests in the test directory of the source
 * distribution.
 * &lt;/p&gt;
 * &lt;p&gt;
 * FastMath accuracy should be mostly independent of the JVM as it relies only
 * on IEEE-754 basic operations and on embedded tables. Almost all operations
 * are accurate to about 0.5 ulp throughout the domain range. This statement,
 * of course is only a rough global observed behavior, it is &lt;em&gt;not&lt;/em&gt; a
 * guarantee for &lt;em&gt;every&lt;/em&gt; double numbers input (see William Kahan's &lt;a
 * href=&quot;http://en.wikipedia.org/wiki/Rounding#The_table-maker.27s_dilemma&quot;&gt;Table
 * Maker's Dilemma&lt;/a&gt;).
 * &lt;/p&gt;
 * &lt;p&gt;
 * FastMath additionally implements the following methods not found in Math/StrictMath:
 * &lt;ul&gt;
 * &lt;li&gt;{@link #asinh(double)}&lt;/li&gt;
 * &lt;li&gt;{@link #acosh(double)}&lt;/li&gt;
 * &lt;li&gt;{@link #atanh(double)}&lt;/li&gt;
 * &lt;/ul&gt;
 * The following methods are found in Math/StrictMath since 1.6 only, they are provided
 * by FastMath even in 1.5 Java virtual machines
 * &lt;ul&gt;
 * &lt;li&gt;{@link #copySign(double, double)}&lt;/li&gt;
 * &lt;li&gt;{@link #getExponent(double)}&lt;/li&gt;
 * &lt;li&gt;{@link #nextAfter(double,double)}&lt;/li&gt;
 * &lt;li&gt;{@link #nextUp(double)}&lt;/li&gt;
 * &lt;li&gt;{@link #scalb(double, int)}&lt;/li&gt;
 * &lt;li&gt;{@link #copySign(float, float)}&lt;/li&gt;
 * &lt;li&gt;{@link #getExponent(float)}&lt;/li&gt;
 * &lt;li&gt;{@link #nextAfter(float,double)}&lt;/li&gt;
 * &lt;li&gt;{@link #nextUp(float)}&lt;/li&gt;
 * &lt;li&gt;{@link #scalb(float, int)}&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/p&gt;
 * @version $Id$
 * @since 2.2
 */
public class FastMath {
    /** Archimede's constant PI, ratio of circle circumference to diameter. */
    public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;

    /** Napier's constant e, base of the natural logarithm. */
    public static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8;

    /** Index of exp(0) in the array of integer exponentials. */
    static final int EXP_INT_TABLE_MAX_INDEX = 750;
    /** Length of the array of integer exponentials. */
    static final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2;
    /** Logarithm table length. */
    static final int LN_MANT_LEN = 1024;
    /** Exponential fractions table length. */
    static final int EXP_FRAC_TABLE_LEN = 1025; // 0, 1/1024, ... 1024/1024

    /** StrictMath.log(Double.MAX_VALUE): {@value} */
<span class="fc" id="L97">    private static final double LOG_MAX_VALUE = StrictMath.log(Double.MAX_VALUE);</span>

    /** Indicator for tables initialization.
     * &lt;p&gt;
     * This compile-time constant should be set to true only if one explicitly
     * wants to compute the tables at class loading time instead of using the
     * already computed ones provided as literal arrays below.
     * &lt;/p&gt;
     */
    private static final boolean RECOMPUTE_TABLES_AT_RUNTIME = false;

    /** log(2) (high bits). */
    private static final double LN_2_A = 0.693147063255310059;

    /** log(2) (low bits). */
    private static final double LN_2_B = 1.17304635250823482e-7;

    /** Coefficients for log, when input 0.99 &lt; x &lt; 1.01. */
<span class="fc" id="L115">    private static final double LN_QUICK_COEF[][] = {</span>
        {1.0, 5.669184079525E-24},
        {-0.25, -0.25},
        {0.3333333134651184, 1.986821492305628E-8},
        {-0.25, -6.663542893624021E-14},
        {0.19999998807907104, 1.1921056801463227E-8},
        {-0.1666666567325592, -7.800414592973399E-9},
        {0.1428571343421936, 5.650007086920087E-9},
        {-0.12502530217170715, -7.44321345601866E-11},
        {0.11113807559013367, 9.219544613762692E-9},
    };

    /** Coefficients for log in the range of 1.0 &lt; x &lt; 1.0 + 2^-10. */
<span class="fc" id="L128">    private static final double LN_HI_PREC_COEF[][] = {</span>
        {1.0, -6.032174644509064E-23},
        {-0.25, -0.25},
        {0.3333333134651184, 1.9868161777724352E-8},
        {-0.2499999701976776, -2.957007209750105E-8},
        {0.19999954104423523, 1.5830993332061267E-10},
        {-0.16624879837036133, -2.6033824355191673E-8}
    };

    /** Sine, Cosine, Tangent tables are for 0, 1/8, 2/8, ... 13/8 = PI/2 approx. */
    private static final int SINE_TABLE_LEN = 14;

    /** Sine table (high bits). */
<span class="fc" id="L141">    private static final double SINE_TABLE_A[] =</span>
        {
        +0.0d,
        +0.1246747374534607d,
        +0.24740394949913025d,
        +0.366272509098053d,
        +0.4794255495071411d,
        +0.5850973129272461d,
        +0.6816387176513672d,
        +0.7675435543060303d,
        +0.8414709568023682d,
        +0.902267575263977d,
        +0.9489846229553223d,
        +0.9808930158615112d,
        +0.9974949359893799d,
        +0.9985313415527344d,
    };

    /** Sine table (low bits). */
<span class="fc" id="L160">    private static final double SINE_TABLE_B[] =</span>
        {
        +0.0d,
        -4.068233003401932E-9d,
        +9.755392680573412E-9d,
        +1.9987994582857286E-8d,
        -1.0902938113007961E-8d,
        -3.9986783938944604E-8d,
        +4.23719669792332E-8d,
        -5.207000323380292E-8d,
        +2.800552834259E-8d,
        +1.883511811213715E-8d,
        -3.5997360512765566E-9d,
        +4.116164446561962E-8d,
        +5.0614674548127384E-8d,
        -1.0129027912496858E-9d,
    };

    /** Cosine table (high bits). */
<span class="fc" id="L179">    private static final double COSINE_TABLE_A[] =</span>
        {
        +1.0d,
        +0.9921976327896118d,
        +0.9689123630523682d,
        +0.9305076599121094d,
        +0.8775825500488281d,
        +0.8109631538391113d,
        +0.7316888570785522d,
        +0.6409968137741089d,
        +0.5403022766113281d,
        +0.4311765432357788d,
        +0.3153223395347595d,
        +0.19454771280288696d,
        +0.07073719799518585d,
        -0.05417713522911072d,
    };

    /** Cosine table (low bits). */
<span class="fc" id="L198">    private static final double COSINE_TABLE_B[] =</span>
        {
        +0.0d,
        +3.4439717236742845E-8d,
        +5.865827662008209E-8d,
        -3.7999795083850525E-8d,
        +1.184154459111628E-8d,
        -3.43338934259355E-8d,
        +1.1795268640216787E-8d,
        +4.438921624363781E-8d,
        +2.925681159240093E-8d,
        -2.6437112632041807E-8d,
        +2.2860509143963117E-8d,
        -4.813899778443457E-9d,
        +3.6725170580355583E-9d,
        +2.0217439756338078E-10d,
    };


    /** Tangent table, used by atan() (high bits). */
<span class="fc" id="L218">    private static final double TANGENT_TABLE_A[] =</span>
        {
        +0.0d,
        +0.1256551444530487d,
        +0.25534194707870483d,
        +0.3936265707015991d,
        +0.5463024377822876d,
        +0.7214844226837158d,
        +0.9315965175628662d,
        +1.1974215507507324d,
        +1.5574076175689697d,
        +2.092571258544922d,
        +3.0095696449279785d,
        +5.041914939880371d,
        +14.101419448852539d,
        -18.430862426757812d,
    };

    /** Tangent table, used by atan() (low bits). */
<span class="fc" id="L237">    private static final double TANGENT_TABLE_B[] =</span>
        {
        +0.0d,
        -7.877917738262007E-9d,
        -2.5857668567479893E-8d,
        +5.2240336371356666E-9d,
        +5.206150291559893E-8d,
        +1.8307188599677033E-8d,
        -5.7618793749770706E-8d,
        +7.848361555046424E-8d,
        +1.0708593250394448E-7d,
        +1.7827257129423813E-8d,
        +2.893485277253286E-8d,
        +3.1660099222737955E-7d,
        +4.983191803254889E-7d,
        -3.356118100840571E-7d,
    };

    /** Bits of 1/(2*pi), need for reducePayneHanek(). */
<span class="fc" id="L256">    private static final long RECIP_2PI[] = new long[] {</span>
        (0x28be60dbL &lt;&lt; 32) | 0x9391054aL,
        (0x7f09d5f4L &lt;&lt; 32) | 0x7d4d3770L,
        (0x36d8a566L &lt;&lt; 32) | 0x4f10e410L,
        (0x7f9458eaL &lt;&lt; 32) | 0xf7aef158L,
        (0x6dc91b8eL &lt;&lt; 32) | 0x909374b8L,
        (0x01924bbaL &lt;&lt; 32) | 0x82746487L,
        (0x3f877ac7L &lt;&lt; 32) | 0x2c4a69cfL,
        (0xba208d7dL &lt;&lt; 32) | 0x4baed121L,
        (0x3a671c09L &lt;&lt; 32) | 0xad17df90L,
        (0x4e64758eL &lt;&lt; 32) | 0x60d4ce7dL,
        (0x272117e2L &lt;&lt; 32) | 0xef7e4a0eL,
        (0xc7fe25ffL &lt;&lt; 32) | 0xf7816603L,
        (0xfbcbc462L &lt;&lt; 32) | 0xd6829b47L,
        (0xdb4d9fb3L &lt;&lt; 32) | 0xc9f2c26dL,
        (0xd3d18fd9L &lt;&lt; 32) | 0xa797fa8bL,
        (0x5d49eeb1L &lt;&lt; 32) | 0xfaf97c5eL,
        (0xcf41ce7dL &lt;&lt; 32) | 0xe294a4baL,
         0x9afed7ecL &lt;&lt; 32  };

    /** Bits of pi/4, need for reducePayneHanek(). */
<span class="fc" id="L277">    private static final long PI_O_4_BITS[] = new long[] {</span>
        (0xc90fdaa2L &lt;&lt; 32) | 0x2168c234L,
        (0xc4c6628bL &lt;&lt; 32) | 0x80dc1cd1L };

    /** Eighths.
     * This is used by sinQ, because its faster to do a table lookup than
     * a multiply in this time-critical routine
     */
<span class="fc" id="L285">    private static final double EIGHTHS[] = {0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0, 1.125, 1.25, 1.375, 1.5, 1.625};</span>

    /** Table of 2^((n+2)/3) */
<span class="fc" id="L288">    private static final double CBRTTWO[] = { 0.6299605249474366,</span>
                                            0.7937005259840998,
                                            1.0,
                                            1.2599210498948732,
                                            1.5874010519681994 };

    /*
     *  There are 52 bits in the mantissa of a double.
     *  For additional precision, the code splits double numbers into two parts,
     *  by clearing the low order 30 bits if possible, and then performs the arithmetic
     *  on each half separately.
     */

    /**
     * 0x40000000 - used to split a double into two parts, both with the low order bits cleared.
     * Equivalent to 2^30.
     */
    private static final long HEX_40000000 = 0x40000000L; // 1073741824L

    /** Mask used to clear low order 30 bits */
    private static final long MASK_30BITS = -1L - (HEX_40000000 -1); // 0xFFFFFFFFC0000000L;

    /** Mask used to clear the non-sign part of an int. */
    private static final int MASK_NON_SIGN_INT = 0x7fffffff;

    /** Mask used to clear the non-sign part of a long. */
    private static final long MASK_NON_SIGN_LONG = 0x7fffffffffffffffl;

    /** 2^52 - double numbers this large must be integral (no fraction) or NaN or Infinite */
    private static final double TWO_POWER_52 = 4503599627370496.0;
    /** 2^53 - double numbers this large must be even. */
    private static final double TWO_POWER_53 = 2 * TWO_POWER_52;

    /** Constant: {@value}. */
    private static final double F_1_3 = 1d / 3d;
    /** Constant: {@value}. */
    private static final double F_1_5 = 1d / 5d;
    /** Constant: {@value}. */
    private static final double F_1_7 = 1d / 7d;
    /** Constant: {@value}. */
    private static final double F_1_9 = 1d / 9d;
    /** Constant: {@value}. */
    private static final double F_1_11 = 1d / 11d;
    /** Constant: {@value}. */
    private static final double F_1_13 = 1d / 13d;
    /** Constant: {@value}. */
    private static final double F_1_15 = 1d / 15d;
    /** Constant: {@value}. */
    private static final double F_1_17 = 1d / 17d;
    /** Constant: {@value}. */
    private static final double F_3_4 = 3d / 4d;
    /** Constant: {@value}. */
    private static final double F_15_16 = 15d / 16d;
    /** Constant: {@value}. */
    private static final double F_13_14 = 13d / 14d;
    /** Constant: {@value}. */
    private static final double F_11_12 = 11d / 12d;
    /** Constant: {@value}. */
    private static final double F_9_10 = 9d / 10d;
    /** Constant: {@value}. */
    private static final double F_7_8 = 7d / 8d;
    /** Constant: {@value}. */
    private static final double F_5_6 = 5d / 6d;
    /** Constant: {@value}. */
    private static final double F_1_2 = 1d / 2d;
    /** Constant: {@value}. */
    private static final double F_1_4 = 1d / 4d;

    /**
     * Private Constructor
     */
    private FastMath() {}

    // Generic helper methods

    /**
     * Get the high order bits from the mantissa.
     * Equivalent to adding and subtracting HEX_40000 but also works for very large numbers
     *
     * @param d the value to split
     * @return the high order part of the mantissa
     */
    private static double doubleHighPart(double d) {
<span class="fc bfc" id="L371" title="All 4 branches covered.">        if (d &gt; -Precision.SAFE_MIN &amp;&amp; d &lt; Precision.SAFE_MIN){</span>
<span class="fc" id="L372">            return d; // These are un-normalised - don't try to convert</span>
        }
<span class="fc" id="L374">        long xl = Double.doubleToRawLongBits(d); // can take raw bits because just gonna convert it back</span>
<span class="fc" id="L375">        xl &amp;= MASK_30BITS; // Drop low order bits</span>
<span class="fc" id="L376">        return Double.longBitsToDouble(xl);</span>
    }

    /** Compute the square root of a number.
     * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; this implementation currently delegates to {@link Math#sqrt}
     * @param a number on which evaluation is done
     * @return square root of a
     */
    public static double sqrt(final double a) {
<span class="fc" id="L385">        return Math.sqrt(a);</span>
    }

    /** Compute the hyperbolic cosine of a number.
     * @param x number on which evaluation is done
     * @return hyperbolic cosine of x
     */
    public static double cosh(double x) {
<span class="fc bfc" id="L393" title="All 2 branches covered.">      if (x != x) {</span>
<span class="fc" id="L394">          return x;</span>
      }

      // cosh[z] = (exp(z) + exp(-z))/2

      // for numbers with magnitude 20 or so,
      // exp(-z) can be ignored in comparison with exp(z)

<span class="fc bfc" id="L402" title="All 2 branches covered.">      if (x &gt; 20) {</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">          if (x &gt;= LOG_MAX_VALUE) {</span>
              // Avoid overflow (MATH-905).
<span class="fc" id="L405">              final double t = exp(0.5 * x);</span>
<span class="fc" id="L406">              return (0.5 * t) * t;</span>
          } else {
<span class="fc" id="L408">              return 0.5 * exp(x);</span>
          }
<span class="fc bfc" id="L410" title="All 2 branches covered.">      } else if (x &lt; -20) {</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">          if (x &lt;= -LOG_MAX_VALUE) {</span>
              // Avoid overflow (MATH-905).
<span class="fc" id="L413">              final double t = exp(-0.5 * x);</span>
<span class="fc" id="L414">              return (0.5 * t) * t;</span>
          } else {
<span class="fc" id="L416">              return 0.5 * exp(-x);</span>
          }
      }

<span class="fc" id="L420">      final double hiPrec[] = new double[2];</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">      if (x &lt; 0.0) {</span>
<span class="fc" id="L422">          x = -x;</span>
      }
<span class="fc" id="L424">      exp(x, 0.0, hiPrec);</span>

<span class="fc" id="L426">      double ya = hiPrec[0] + hiPrec[1];</span>
<span class="fc" id="L427">      double yb = -(ya - hiPrec[0] - hiPrec[1]);</span>

<span class="fc" id="L429">      double temp = ya * HEX_40000000;</span>
<span class="fc" id="L430">      double yaa = ya + temp - temp;</span>
<span class="fc" id="L431">      double yab = ya - yaa;</span>

      // recip = 1/y
<span class="fc" id="L434">      double recip = 1.0/ya;</span>
<span class="fc" id="L435">      temp = recip * HEX_40000000;</span>
<span class="fc" id="L436">      double recipa = recip + temp - temp;</span>
<span class="fc" id="L437">      double recipb = recip - recipa;</span>

      // Correct for rounding in division
<span class="fc" id="L440">      recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;</span>
      // Account for yb
<span class="fc" id="L442">      recipb += -yb * recip * recip;</span>

      // y = y + 1/y
<span class="fc" id="L445">      temp = ya + recipa;</span>
<span class="fc" id="L446">      yb += -(temp - ya - recipa);</span>
<span class="fc" id="L447">      ya = temp;</span>
<span class="fc" id="L448">      temp = ya + recipb;</span>
<span class="fc" id="L449">      yb += -(temp - ya - recipb);</span>
<span class="fc" id="L450">      ya = temp;</span>

<span class="fc" id="L452">      double result = ya + yb;</span>
<span class="fc" id="L453">      result *= 0.5;</span>
<span class="fc" id="L454">      return result;</span>
    }

    /** Compute the hyperbolic sine of a number.
     * @param x number on which evaluation is done
     * @return hyperbolic sine of x
     */
    public static double sinh(double x) {
<span class="fc" id="L462">      boolean negate = false;</span>
<span class="fc bfc" id="L463" title="All 2 branches covered.">      if (x != x) {</span>
<span class="fc" id="L464">          return x;</span>
      }

      // sinh[z] = (exp(z) - exp(-z) / 2

      // for values of z larger than about 20,
      // exp(-z) can be ignored in comparison with exp(z)

<span class="fc bfc" id="L472" title="All 2 branches covered.">      if (x &gt; 20) {</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">          if (x &gt;= LOG_MAX_VALUE) {</span>
              // Avoid overflow (MATH-905).
<span class="fc" id="L475">              final double t = exp(0.5 * x);</span>
<span class="fc" id="L476">              return (0.5 * t) * t;</span>
          } else {
<span class="fc" id="L478">              return 0.5 * exp(x);</span>
          }
<span class="fc bfc" id="L480" title="All 2 branches covered.">      } else if (x &lt; -20) {</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">          if (x &lt;= -LOG_MAX_VALUE) {</span>
              // Avoid overflow (MATH-905).
<span class="fc" id="L483">              final double t = exp(-0.5 * x);</span>
<span class="fc" id="L484">              return (-0.5 * t) * t;</span>
          } else {
<span class="fc" id="L486">              return -0.5 * exp(-x);</span>
          }
      }

<span class="fc bfc" id="L490" title="All 2 branches covered.">      if (x == 0) {</span>
<span class="fc" id="L491">          return x;</span>
      }

<span class="fc bfc" id="L494" title="All 2 branches covered.">      if (x &lt; 0.0) {</span>
<span class="fc" id="L495">          x = -x;</span>
<span class="fc" id="L496">          negate = true;</span>
      }

      double result;

<span class="fc bfc" id="L501" title="All 2 branches covered.">      if (x &gt; 0.25) {</span>
<span class="fc" id="L502">          double hiPrec[] = new double[2];</span>
<span class="fc" id="L503">          exp(x, 0.0, hiPrec);</span>

<span class="fc" id="L505">          double ya = hiPrec[0] + hiPrec[1];</span>
<span class="fc" id="L506">          double yb = -(ya - hiPrec[0] - hiPrec[1]);</span>

<span class="fc" id="L508">          double temp = ya * HEX_40000000;</span>
<span class="fc" id="L509">          double yaa = ya + temp - temp;</span>
<span class="fc" id="L510">          double yab = ya - yaa;</span>

          // recip = 1/y
<span class="fc" id="L513">          double recip = 1.0/ya;</span>
<span class="fc" id="L514">          temp = recip * HEX_40000000;</span>
<span class="fc" id="L515">          double recipa = recip + temp - temp;</span>
<span class="fc" id="L516">          double recipb = recip - recipa;</span>

          // Correct for rounding in division
<span class="fc" id="L519">          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;</span>
          // Account for yb
<span class="fc" id="L521">          recipb += -yb * recip * recip;</span>

<span class="fc" id="L523">          recipa = -recipa;</span>
<span class="fc" id="L524">          recipb = -recipb;</span>

          // y = y + 1/y
<span class="fc" id="L527">          temp = ya + recipa;</span>
<span class="fc" id="L528">          yb += -(temp - ya - recipa);</span>
<span class="fc" id="L529">          ya = temp;</span>
<span class="fc" id="L530">          temp = ya + recipb;</span>
<span class="fc" id="L531">          yb += -(temp - ya - recipb);</span>
<span class="fc" id="L532">          ya = temp;</span>

<span class="fc" id="L534">          result = ya + yb;</span>
<span class="fc" id="L535">          result *= 0.5;</span>
<span class="fc" id="L536">      }</span>
      else {
<span class="fc" id="L538">          double hiPrec[] = new double[2];</span>
<span class="fc" id="L539">          expm1(x, hiPrec);</span>

<span class="fc" id="L541">          double ya = hiPrec[0] + hiPrec[1];</span>
<span class="fc" id="L542">          double yb = -(ya - hiPrec[0] - hiPrec[1]);</span>

          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */
<span class="fc" id="L545">          double denom = 1.0 + ya;</span>
<span class="fc" id="L546">          double denomr = 1.0 / denom;</span>
<span class="fc" id="L547">          double denomb = -(denom - 1.0 - ya) + yb;</span>
<span class="fc" id="L548">          double ratio = ya * denomr;</span>
<span class="fc" id="L549">          double temp = ratio * HEX_40000000;</span>
<span class="fc" id="L550">          double ra = ratio + temp - temp;</span>
<span class="fc" id="L551">          double rb = ratio - ra;</span>

<span class="fc" id="L553">          temp = denom * HEX_40000000;</span>
<span class="fc" id="L554">          double za = denom + temp - temp;</span>
<span class="fc" id="L555">          double zb = denom - za;</span>

<span class="fc" id="L557">          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;</span>

          // Adjust for yb
<span class="fc" id="L560">          rb += yb*denomr;                        // numerator</span>
<span class="fc" id="L561">          rb += -ya * denomb * denomr * denomr;   // denominator</span>

          // y = y - 1/y
<span class="fc" id="L564">          temp = ya + ra;</span>
<span class="fc" id="L565">          yb += -(temp - ya - ra);</span>
<span class="fc" id="L566">          ya = temp;</span>
<span class="fc" id="L567">          temp = ya + rb;</span>
<span class="fc" id="L568">          yb += -(temp - ya - rb);</span>
<span class="fc" id="L569">          ya = temp;</span>

<span class="fc" id="L571">          result = ya + yb;</span>
<span class="fc" id="L572">          result *= 0.5;</span>
      }

<span class="fc bfc" id="L575" title="All 2 branches covered.">      if (negate) {</span>
<span class="fc" id="L576">          result = -result;</span>
      }

<span class="fc" id="L579">      return result;</span>
    }

    /** Compute the hyperbolic tangent of a number.
     * @param x number on which evaluation is done
     * @return hyperbolic tangent of x
     */
    public static double tanh(double x) {
<span class="fc" id="L587">      boolean negate = false;</span>

<span class="fc bfc" id="L589" title="All 2 branches covered.">      if (x != x) {</span>
<span class="fc" id="L590">          return x;</span>
      }

      // tanh[z] = sinh[z] / cosh[z]
      // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))
      // = (exp(2x) - 1) / (exp(2x) + 1)

      // for magnitude &gt; 20, sinh[z] == cosh[z] in double precision

<span class="fc bfc" id="L599" title="All 2 branches covered.">      if (x &gt; 20.0) {</span>
<span class="fc" id="L600">          return 1.0;</span>
      }

<span class="fc bfc" id="L603" title="All 2 branches covered.">      if (x &lt; -20) {</span>
<span class="fc" id="L604">          return -1.0;</span>
      }

<span class="fc bfc" id="L607" title="All 2 branches covered.">      if (x == 0) {</span>
<span class="fc" id="L608">          return x;</span>
      }

<span class="fc bfc" id="L611" title="All 2 branches covered.">      if (x &lt; 0.0) {</span>
<span class="fc" id="L612">          x = -x;</span>
<span class="fc" id="L613">          negate = true;</span>
      }

      double result;
<span class="fc bfc" id="L617" title="All 2 branches covered.">      if (x &gt;= 0.5) {</span>
<span class="fc" id="L618">          double hiPrec[] = new double[2];</span>
          // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)
<span class="fc" id="L620">          exp(x*2.0, 0.0, hiPrec);</span>

<span class="fc" id="L622">          double ya = hiPrec[0] + hiPrec[1];</span>
<span class="fc" id="L623">          double yb = -(ya - hiPrec[0] - hiPrec[1]);</span>

          /* Numerator */
<span class="fc" id="L626">          double na = -1.0 + ya;</span>
<span class="fc" id="L627">          double nb = -(na + 1.0 - ya);</span>
<span class="fc" id="L628">          double temp = na + yb;</span>
<span class="fc" id="L629">          nb += -(temp - na - yb);</span>
<span class="fc" id="L630">          na = temp;</span>

          /* Denominator */
<span class="fc" id="L633">          double da = 1.0 + ya;</span>
<span class="fc" id="L634">          double db = -(da - 1.0 - ya);</span>
<span class="fc" id="L635">          temp = da + yb;</span>
<span class="fc" id="L636">          db += -(temp - da - yb);</span>
<span class="fc" id="L637">          da = temp;</span>

<span class="fc" id="L639">          temp = da * HEX_40000000;</span>
<span class="fc" id="L640">          double daa = da + temp - temp;</span>
<span class="fc" id="L641">          double dab = da - daa;</span>

          // ratio = na/da
<span class="fc" id="L644">          double ratio = na/da;</span>
<span class="fc" id="L645">          temp = ratio * HEX_40000000;</span>
<span class="fc" id="L646">          double ratioa = ratio + temp - temp;</span>
<span class="fc" id="L647">          double ratiob = ratio - ratioa;</span>

          // Correct for rounding in division
<span class="fc" id="L650">          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;</span>

          // Account for nb
<span class="fc" id="L653">          ratiob += nb / da;</span>
          // Account for db
<span class="fc" id="L655">          ratiob += -db * na / da / da;</span>

<span class="fc" id="L657">          result = ratioa + ratiob;</span>
<span class="fc" id="L658">      }</span>
      else {
<span class="fc" id="L660">          double hiPrec[] = new double[2];</span>
          // tanh(x) = expm1(2x) / (expm1(2x) + 2)
<span class="fc" id="L662">          expm1(x*2.0, hiPrec);</span>

<span class="fc" id="L664">          double ya = hiPrec[0] + hiPrec[1];</span>
<span class="fc" id="L665">          double yb = -(ya - hiPrec[0] - hiPrec[1]);</span>

          /* Numerator */
<span class="fc" id="L668">          double na = ya;</span>
<span class="fc" id="L669">          double nb = yb;</span>

          /* Denominator */
<span class="fc" id="L672">          double da = 2.0 + ya;</span>
<span class="fc" id="L673">          double db = -(da - 2.0 - ya);</span>
<span class="fc" id="L674">          double temp = da + yb;</span>
<span class="fc" id="L675">          db += -(temp - da - yb);</span>
<span class="fc" id="L676">          da = temp;</span>

<span class="fc" id="L678">          temp = da * HEX_40000000;</span>
<span class="fc" id="L679">          double daa = da + temp - temp;</span>
<span class="fc" id="L680">          double dab = da - daa;</span>

          // ratio = na/da
<span class="fc" id="L683">          double ratio = na/da;</span>
<span class="fc" id="L684">          temp = ratio * HEX_40000000;</span>
<span class="fc" id="L685">          double ratioa = ratio + temp - temp;</span>
<span class="fc" id="L686">          double ratiob = ratio - ratioa;</span>

          // Correct for rounding in division
<span class="fc" id="L689">          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;</span>

          // Account for nb
<span class="fc" id="L692">          ratiob += nb / da;</span>
          // Account for db
<span class="fc" id="L694">          ratiob += -db * na / da / da;</span>

<span class="fc" id="L696">          result = ratioa + ratiob;</span>
      }

<span class="fc bfc" id="L699" title="All 2 branches covered.">      if (negate) {</span>
<span class="fc" id="L700">          result = -result;</span>
      }

<span class="fc" id="L703">      return result;</span>
    }

    /** Compute the inverse hyperbolic cosine of a number.
     * @param a number on which evaluation is done
     * @return inverse hyperbolic cosine of a
     */
    public static double acosh(final double a) {
<span class="fc" id="L711">        return FastMath.log(a + FastMath.sqrt(a * a - 1));</span>
    }

    /** Compute the inverse hyperbolic sine of a number.
     * @param a number on which evaluation is done
     * @return inverse hyperbolic sine of a
     */
    public static double asinh(double a) {
<span class="fc" id="L719">        boolean negative = false;</span>
<span class="fc bfc" id="L720" title="All 2 branches covered.">        if (a &lt; 0) {</span>
<span class="fc" id="L721">            negative = true;</span>
<span class="fc" id="L722">            a = -a;</span>
        }

        double absAsinh;
<span class="fc bfc" id="L726" title="All 2 branches covered.">        if (a &gt; 0.167) {</span>
<span class="fc" id="L727">            absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a);</span>
        } else {
<span class="fc" id="L729">            final double a2 = a * a;</span>
<span class="fc bfc" id="L730" title="All 2 branches covered.">            if (a &gt; 0.097) {</span>
<span class="fc" id="L731">                absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);</span>
<span class="fc bfc" id="L732" title="All 2 branches covered.">            } else if (a &gt; 0.036) {</span>
<span class="fc" id="L733">                absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);</span>
<span class="fc bfc" id="L734" title="All 2 branches covered.">            } else if (a &gt; 0.0036) {</span>
<span class="fc" id="L735">                absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);</span>
            } else {
<span class="fc" id="L737">                absAsinh = a * (1 - a2 * (F_1_3 - a2 * F_1_5 * F_3_4) * F_1_2);</span>
            }
        }

<span class="fc bfc" id="L741" title="All 2 branches covered.">        return negative ? -absAsinh : absAsinh;</span>
    }

    /** Compute the inverse hyperbolic tangent of a number.
     * @param a number on which evaluation is done
     * @return inverse hyperbolic tangent of a
     */
    public static double atanh(double a) {
<span class="fc" id="L749">        boolean negative = false;</span>
<span class="fc bfc" id="L750" title="All 2 branches covered.">        if (a &lt; 0) {</span>
<span class="fc" id="L751">            negative = true;</span>
<span class="fc" id="L752">            a = -a;</span>
        }

        double absAtanh;
<span class="fc bfc" id="L756" title="All 2 branches covered.">        if (a &gt; 0.15) {</span>
<span class="fc" id="L757">            absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));</span>
        } else {
<span class="fc" id="L759">            final double a2 = a * a;</span>
<span class="fc bfc" id="L760" title="All 2 branches covered.">            if (a &gt; 0.087) {</span>
<span class="fc" id="L761">                absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17))))))));</span>
<span class="fc bfc" id="L762" title="All 2 branches covered.">            } else if (a &gt; 0.031) {</span>
<span class="fc" id="L763">                absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13))))));</span>
<span class="fc bfc" id="L764" title="All 2 branches covered.">            } else if (a &gt; 0.003) {</span>
<span class="fc" id="L765">                absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9))));</span>
            } else {
<span class="fc" id="L767">                absAtanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5));</span>
            }
        }

<span class="fc bfc" id="L771" title="All 2 branches covered.">        return negative ? -absAtanh : absAtanh;</span>
    }

    /** Compute the signum of a number.
     * The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise
     * @param a number on which evaluation is done
     * @return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a
     */
    public static double signum(final double a) {
<span class="fc bfc" id="L780" title="All 4 branches covered.">        return (a &lt; 0.0) ? -1.0 : ((a &gt; 0.0) ? 1.0 : a); // return +0.0/-0.0/NaN depending on a</span>
    }

    /** Compute the signum of a number.
     * The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise
     * @param a number on which evaluation is done
     * @return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a
     */
    public static float signum(final float a) {
<span class="fc bfc" id="L789" title="All 4 branches covered.">        return (a &lt; 0.0f) ? -1.0f : ((a &gt; 0.0f) ? 1.0f : a); // return +0.0/-0.0/NaN depending on a</span>
    }

    /** Compute next number towards positive infinity.
     * @param a number to which neighbor should be computed
     * @return neighbor of a towards positive infinity
     */
    public static double nextUp(final double a) {
<span class="fc" id="L797">        return nextAfter(a, Double.POSITIVE_INFINITY);</span>
    }

    /** Compute next number towards positive infinity.
     * @param a number to which neighbor should be computed
     * @return neighbor of a towards positive infinity
     */
    public static float nextUp(final float a) {
<span class="fc" id="L805">        return nextAfter(a, Float.POSITIVE_INFINITY);</span>
    }

    /** Returns a pseudo-random number between 0.0 and 1.0.
     * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; this implementation currently delegates to {@link Math#random}
     * @return a random number between 0.0 and 1.0
     */
    public static double random() {
<span class="fc" id="L813">        return Math.random();</span>
    }

    /**
     * Exponential function.
     *
     * Computes exp(x), function result is nearly rounded.   It will be correctly
     * rounded to the theoretical value for 99.9% of input values, otherwise it will
     * have a 1 UPL error.
     *
     * Method:
     *    Lookup intVal = exp(int(x))
     *    Lookup fracVal = exp(int(x-int(x) / 1024.0) * 1024.0 );
     *    Compute z as the exponential of the remaining bits by a polynomial minus one
     *    exp(x) = intVal * fracVal * (1 + z)
     *
     * Accuracy:
     *    Calculation is done with 63 bits of precision, so result should be correctly
     *    rounded for 99.9% of input values, with less than 1 ULP error otherwise.
     *
     * @param x   a double
     * @return double e&lt;sup&gt;x&lt;/sup&gt;
     */
    public static double exp(double x) {
<span class="fc" id="L837">        return exp(x, 0.0, null);</span>
    }

    /**
     * Internal helper method for exponential function.
     * @param x original argument of the exponential function
     * @param extra extra bits of precision on input (To Be Confirmed)
     * @param hiPrec extra bits of precision on output (To Be Confirmed)
     * @return exp(x)
     */
    private static double exp(double x, double extra, double[] hiPrec) {
        double intPartA;
        double intPartB;
        int intVal;

        /* Lookup exp(floor(x)).
         * intPartA will have the upper 22 bits, intPartB will have the lower
         * 52 bits.
         */
<span class="fc bfc" id="L856" title="All 2 branches covered.">        if (x &lt; 0.0) {</span>
<span class="fc" id="L857">            intVal = (int) -x;</span>

<span class="fc bfc" id="L859" title="All 2 branches covered.">            if (intVal &gt; 746) {</span>
<span class="fc bfc" id="L860" title="All 2 branches covered.">                if (hiPrec != null) {</span>
<span class="fc" id="L861">                    hiPrec[0] = 0.0;</span>
<span class="fc" id="L862">                    hiPrec[1] = 0.0;</span>
                }
<span class="fc" id="L864">                return 0.0;</span>
            }

<span class="fc bfc" id="L867" title="All 2 branches covered.">            if (intVal &gt; 709) {</span>
                /* This will produce a subnormal output */
<span class="fc" id="L869">                final double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0;</span>
<span class="pc bpc" id="L870" title="1 of 2 branches missed.">                if (hiPrec != null) {</span>
<span class="nc" id="L871">                    hiPrec[0] /= 285040095144011776.0;</span>
<span class="nc" id="L872">                    hiPrec[1] /= 285040095144011776.0;</span>
                }
<span class="fc" id="L874">                return result;</span>
            }

<span class="fc bfc" id="L877" title="All 2 branches covered.">            if (intVal == 709) {</span>
                /* exp(1.494140625) is nearly a machine number... */
<span class="fc" id="L879">                final double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620;</span>
<span class="pc bpc" id="L880" title="1 of 2 branches missed.">                if (hiPrec != null) {</span>
<span class="nc" id="L881">                    hiPrec[0] /= 4.455505956692756620;</span>
<span class="nc" id="L882">                    hiPrec[1] /= 4.455505956692756620;</span>
                }
<span class="fc" id="L884">                return result;</span>
            }

<span class="fc" id="L887">            intVal++;</span>

<span class="fc" id="L889">            intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-intVal];</span>
<span class="fc" id="L890">            intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-intVal];</span>

<span class="fc" id="L892">            intVal = -intVal;</span>
        } else {
<span class="fc" id="L894">            intVal = (int) x;</span>

<span class="fc bfc" id="L896" title="All 2 branches covered.">            if (intVal &gt; 709) {</span>
<span class="fc bfc" id="L897" title="All 2 branches covered.">                if (hiPrec != null) {</span>
<span class="fc" id="L898">                    hiPrec[0] = Double.POSITIVE_INFINITY;</span>
<span class="fc" id="L899">                    hiPrec[1] = 0.0;</span>
                }
<span class="fc" id="L901">                return Double.POSITIVE_INFINITY;</span>
            }

<span class="fc" id="L904">            intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal];</span>
<span class="fc" id="L905">            intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal];</span>
        }

        /* Get the fractional part of x, find the greatest multiple of 2^-10 less than
         * x and look up the exp function of it.
         * fracPartA will have the upper 22 bits, fracPartB the lower 52 bits.
         */
<span class="fc" id="L912">        final int intFrac = (int) ((x - intVal) * 1024.0);</span>
<span class="fc" id="L913">        final double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac];</span>
<span class="fc" id="L914">        final double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];</span>

        /* epsilon is the difference in x from the nearest multiple of 2^-10.  It
         * has a value in the range 0 &lt;= epsilon &lt; 2^-10.
         * Do the subtraction from x as the last step to avoid possible loss of percison.
         */
<span class="fc" id="L920">        final double epsilon = x - (intVal + intFrac / 1024.0);</span>

        /* Compute z = exp(epsilon) - 1.0 via a minimax polynomial.  z has
       full double precision (52 bits).  Since z &lt; 2^-10, we will have
       62 bits of precision when combined with the contant 1.  This will be
       used in the last addition below to get proper rounding. */

        /* Remez generated polynomial.  Converges on the interval [0, 2^-10], error
       is less than 0.5 ULP */
<span class="fc" id="L929">        double z = 0.04168701738764507;</span>
<span class="fc" id="L930">        z = z * epsilon + 0.1666666505023083;</span>
<span class="fc" id="L931">        z = z * epsilon + 0.5000000000042687;</span>
<span class="fc" id="L932">        z = z * epsilon + 1.0;</span>
<span class="fc" id="L933">        z = z * epsilon + -3.940510424527919E-20;</span>

        /* Compute (intPartA+intPartB) * (fracPartA+fracPartB) by binomial
       expansion.
       tempA is exact since intPartA and intPartB only have 22 bits each.
       tempB will have 52 bits of precision.
         */
<span class="fc" id="L940">        double tempA = intPartA * fracPartA;</span>
<span class="fc" id="L941">        double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;</span>

        /* Compute the result.  (1+z)(tempA+tempB).  Order of operations is
       important.  For accuracy add by increasing size.  tempA is exact and
       much larger than the others.  If there are extra bits specified from the
       pow() function, use them. */
<span class="fc" id="L947">        final double tempC = tempB + tempA;</span>
        final double result;
<span class="fc bfc" id="L949" title="All 2 branches covered.">        if (extra != 0.0) {</span>
<span class="fc" id="L950">            result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA;</span>
        } else {
<span class="fc" id="L952">            result = tempC*z + tempB + tempA;</span>
        }

<span class="fc bfc" id="L955" title="All 2 branches covered.">        if (hiPrec != null) {</span>
            // If requesting high precision
<span class="fc" id="L957">            hiPrec[0] = tempA;</span>
<span class="fc" id="L958">            hiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB;</span>
        }

<span class="fc" id="L961">        return result;</span>
    }

    /** Compute exp(x) - 1
     * @param x number to compute shifted exponential
     * @return exp(x) - 1
     */
    public static double expm1(double x) {
<span class="fc" id="L969">      return expm1(x, null);</span>
    }

    /** Internal helper method for expm1
     * @param x number to compute shifted exponential
     * @param hiPrecOut receive high precision result for -1.0 &lt; x &lt; 1.0
     * @return exp(x) - 1
     */
    private static double expm1(double x, double hiPrecOut[]) {
<span class="fc bfc" id="L978" title="All 4 branches covered.">        if (x != x || x == 0.0) { // NaN or zero</span>
<span class="fc" id="L979">            return x;</span>
        }

<span class="fc bfc" id="L982" title="All 4 branches covered.">        if (x &lt;= -1.0 || x &gt;= 1.0) {</span>
            // If not between +/- 1.0
            //return exp(x) - 1.0;
<span class="fc" id="L985">            double hiPrec[] = new double[2];</span>
<span class="fc" id="L986">            exp(x, 0.0, hiPrec);</span>
<span class="fc bfc" id="L987" title="All 2 branches covered.">            if (x &gt; 0.0) {</span>
<span class="fc" id="L988">                return -1.0 + hiPrec[0] + hiPrec[1];</span>
            } else {
<span class="fc" id="L990">                final double ra = -1.0 + hiPrec[0];</span>
<span class="fc" id="L991">                double rb = -(ra + 1.0 - hiPrec[0]);</span>
<span class="fc" id="L992">                rb += hiPrec[1];</span>
<span class="fc" id="L993">                return ra + rb;</span>
            }
        }

        double baseA;
        double baseB;
        double epsilon;
<span class="fc" id="L1000">        boolean negative = false;</span>

<span class="fc bfc" id="L1002" title="All 2 branches covered.">        if (x &lt; 0.0) {</span>
<span class="fc" id="L1003">            x = -x;</span>
<span class="fc" id="L1004">            negative = true;</span>
        }

        {
<span class="fc" id="L1008">            int intFrac = (int) (x * 1024.0);</span>
<span class="fc" id="L1009">            double tempA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac] - 1.0;</span>
<span class="fc" id="L1010">            double tempB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];</span>

<span class="fc" id="L1012">            double temp = tempA + tempB;</span>
<span class="fc" id="L1013">            tempB = -(temp - tempA - tempB);</span>
<span class="fc" id="L1014">            tempA = temp;</span>

<span class="fc" id="L1016">            temp = tempA * HEX_40000000;</span>
<span class="fc" id="L1017">            baseA = tempA + temp - temp;</span>
<span class="fc" id="L1018">            baseB = tempB + (tempA - baseA);</span>

<span class="fc" id="L1020">            epsilon = x - intFrac/1024.0;</span>
        }


        /* Compute expm1(epsilon) */
<span class="fc" id="L1025">        double zb = 0.008336750013465571;</span>
<span class="fc" id="L1026">        zb = zb * epsilon + 0.041666663879186654;</span>
<span class="fc" id="L1027">        zb = zb * epsilon + 0.16666666666745392;</span>
<span class="fc" id="L1028">        zb = zb * epsilon + 0.49999999999999994;</span>
<span class="fc" id="L1029">        zb *= epsilon;</span>
<span class="fc" id="L1030">        zb *= epsilon;</span>

<span class="fc" id="L1032">        double za = epsilon;</span>
<span class="fc" id="L1033">        double temp = za + zb;</span>
<span class="fc" id="L1034">        zb = -(temp - za - zb);</span>
<span class="fc" id="L1035">        za = temp;</span>

<span class="fc" id="L1037">        temp = za * HEX_40000000;</span>
<span class="fc" id="L1038">        temp = za + temp - temp;</span>
<span class="fc" id="L1039">        zb += za - temp;</span>
<span class="fc" id="L1040">        za = temp;</span>

        /* Combine the parts.   expm1(a+b) = expm1(a) + expm1(b) + expm1(a)*expm1(b) */
<span class="fc" id="L1043">        double ya = za * baseA;</span>
        //double yb = za*baseB + zb*baseA + zb*baseB;
<span class="fc" id="L1045">        temp = ya + za * baseB;</span>
<span class="fc" id="L1046">        double yb = -(temp - ya - za * baseB);</span>
<span class="fc" id="L1047">        ya = temp;</span>

<span class="fc" id="L1049">        temp = ya + zb * baseA;</span>
<span class="fc" id="L1050">        yb += -(temp - ya - zb * baseA);</span>
<span class="fc" id="L1051">        ya = temp;</span>

<span class="fc" id="L1053">        temp = ya + zb * baseB;</span>
<span class="fc" id="L1054">        yb += -(temp - ya - zb*baseB);</span>
<span class="fc" id="L1055">        ya = temp;</span>

        //ya = ya + za + baseA;
        //yb = yb + zb + baseB;
<span class="fc" id="L1059">        temp = ya + baseA;</span>
<span class="fc" id="L1060">        yb += -(temp - baseA - ya);</span>
<span class="fc" id="L1061">        ya = temp;</span>

<span class="fc" id="L1063">        temp = ya + za;</span>
        //yb += (ya &gt; za) ? -(temp - ya - za) : -(temp - za - ya);
<span class="fc" id="L1065">        yb += -(temp - ya - za);</span>
<span class="fc" id="L1066">        ya = temp;</span>

<span class="fc" id="L1068">        temp = ya + baseB;</span>
        //yb += (ya &gt; baseB) ? -(temp - ya - baseB) : -(temp - baseB - ya);
<span class="fc" id="L1070">        yb += -(temp - ya - baseB);</span>
<span class="fc" id="L1071">        ya = temp;</span>

<span class="fc" id="L1073">        temp = ya + zb;</span>
        //yb += (ya &gt; zb) ? -(temp - ya - zb) : -(temp - zb - ya);
<span class="fc" id="L1075">        yb += -(temp - ya - zb);</span>
<span class="fc" id="L1076">        ya = temp;</span>

<span class="fc bfc" id="L1078" title="All 2 branches covered.">        if (negative) {</span>
            /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */
<span class="fc" id="L1080">            double denom = 1.0 + ya;</span>
<span class="fc" id="L1081">            double denomr = 1.0 / denom;</span>
<span class="fc" id="L1082">            double denomb = -(denom - 1.0 - ya) + yb;</span>
<span class="fc" id="L1083">            double ratio = ya * denomr;</span>
<span class="fc" id="L1084">            temp = ratio * HEX_40000000;</span>
<span class="fc" id="L1085">            final double ra = ratio + temp - temp;</span>
<span class="fc" id="L1086">            double rb = ratio - ra;</span>

<span class="fc" id="L1088">            temp = denom * HEX_40000000;</span>
<span class="fc" id="L1089">            za = denom + temp - temp;</span>
<span class="fc" id="L1090">            zb = denom - za;</span>

<span class="fc" id="L1092">            rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;</span>

            // f(x) = x/1+x
            // Compute f'(x)
            // Product rule:  d(uv) = du*v + u*dv
            // Chain rule:  d(f(g(x)) = f'(g(x))*f(g'(x))
            // d(1/x) = -1/(x*x)
            // d(1/1+x) = -1/( (1+x)^2) *  1 =  -1/((1+x)*(1+x))
            // d(x/1+x) = -x/((1+x)(1+x)) + 1/1+x = 1 / ((1+x)(1+x))

            // Adjust for yb
<span class="fc" id="L1103">            rb += yb * denomr;                      // numerator</span>
<span class="fc" id="L1104">            rb += -ya * denomb * denomr * denomr;   // denominator</span>

            // negate
<span class="fc" id="L1107">            ya = -ra;</span>
<span class="fc" id="L1108">            yb = -rb;</span>
        }

<span class="fc bfc" id="L1111" title="All 2 branches covered.">        if (hiPrecOut != null) {</span>
<span class="fc" id="L1112">            hiPrecOut[0] = ya;</span>
<span class="fc" id="L1113">            hiPrecOut[1] = yb;</span>
        }

<span class="fc" id="L1116">        return ya + yb;</span>
    }

    /**
     * Natural logarithm.
     *
     * @param x   a double
     * @return log(x)
     */
    public static double log(final double x) {
<span class="fc" id="L1126">        return log(x, null);</span>
    }

    /**
     * Internal helper method for natural logarithm function.
     * @param x original argument of the natural logarithm function
     * @param hiPrec extra bits of precision on output (To Be Confirmed)
     * @return log(x)
     */
    private static double log(final double x, final double[] hiPrec) {
<span class="fc bfc" id="L1136" title="All 2 branches covered.">        if (x==0) { // Handle special case of +0/-0</span>
<span class="fc" id="L1137">            return Double.NEGATIVE_INFINITY;</span>
        }
<span class="fc" id="L1139">        long bits = Double.doubleToRawLongBits(x);</span>

        /* Handle special cases of negative input, and NaN */
<span class="pc bpc" id="L1142" title="1 of 6 branches missed.">        if (((bits &amp; 0x8000000000000000L) != 0 || x != x) &amp;&amp; x != 0.0) {</span>
<span class="fc bfc" id="L1143" title="All 2 branches covered.">            if (hiPrec != null) {</span>
<span class="fc" id="L1144">                hiPrec[0] = Double.NaN;</span>
            }

<span class="fc" id="L1147">            return Double.NaN;</span>
        }

        /* Handle special cases of Positive infinity. */
<span class="fc bfc" id="L1151" title="All 2 branches covered.">        if (x == Double.POSITIVE_INFINITY) {</span>
<span class="fc bfc" id="L1152" title="All 2 branches covered.">            if (hiPrec != null) {</span>
<span class="fc" id="L1153">                hiPrec[0] = Double.POSITIVE_INFINITY;</span>
            }

<span class="fc" id="L1156">            return Double.POSITIVE_INFINITY;</span>
        }

        /* Extract the exponent */
<span class="fc" id="L1160">        int exp = (int)(bits &gt;&gt; 52)-1023;</span>

<span class="fc bfc" id="L1162" title="All 2 branches covered.">        if ((bits &amp; 0x7ff0000000000000L) == 0) {</span>
            // Subnormal!
<span class="pc bpc" id="L1164" title="1 of 2 branches missed.">            if (x == 0) {</span>
                // Zero
<span class="nc bnc" id="L1166" title="All 2 branches missed.">                if (hiPrec != null) {</span>
<span class="nc" id="L1167">                    hiPrec[0] = Double.NEGATIVE_INFINITY;</span>
                }

<span class="nc" id="L1170">                return Double.NEGATIVE_INFINITY;</span>
            }

            /* Normalize the subnormal number. */
<span class="fc" id="L1174">            bits &lt;&lt;= 1;</span>
<span class="fc bfc" id="L1175" title="All 2 branches covered.">            while ( (bits &amp; 0x0010000000000000L) == 0) {</span>
<span class="fc" id="L1176">                --exp;</span>
<span class="fc" id="L1177">                bits &lt;&lt;= 1;</span>
            }
        }


<span class="fc bfc" id="L1182" title="All 10 branches covered.">        if ((exp == -1 || exp == 0) &amp;&amp; x &lt; 1.01 &amp;&amp; x &gt; 0.99 &amp;&amp; hiPrec == null) {</span>
            /* The normal method doesn't work well in the range [0.99, 1.01], so call do a straight
           polynomial expansion in higer precision. */

            /* Compute x - 1.0 and split it */
<span class="fc" id="L1187">            double xa = x - 1.0;</span>
<span class="fc" id="L1188">            double xb = xa - x + 1.0;</span>
<span class="fc" id="L1189">            double tmp = xa * HEX_40000000;</span>
<span class="fc" id="L1190">            double aa = xa + tmp - tmp;</span>
<span class="fc" id="L1191">            double ab = xa - aa;</span>
<span class="fc" id="L1192">            xa = aa;</span>
<span class="fc" id="L1193">            xb = ab;</span>

<span class="fc" id="L1195">            final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1];</span>
<span class="fc" id="L1196">            double ya = lnCoef_last[0];</span>
<span class="fc" id="L1197">            double yb = lnCoef_last[1];</span>

<span class="fc bfc" id="L1199" title="All 2 branches covered.">            for (int i = LN_QUICK_COEF.length - 2; i &gt;= 0; i--) {</span>
                /* Multiply a = y * x */
<span class="fc" id="L1201">                aa = ya * xa;</span>
<span class="fc" id="L1202">                ab = ya * xb + yb * xa + yb * xb;</span>
                /* split, so now y = a */
<span class="fc" id="L1204">                tmp = aa * HEX_40000000;</span>
<span class="fc" id="L1205">                ya = aa + tmp - tmp;</span>
<span class="fc" id="L1206">                yb = aa - ya + ab;</span>

                /* Add  a = y + lnQuickCoef */
<span class="fc" id="L1209">                final double[] lnCoef_i = LN_QUICK_COEF[i];</span>
<span class="fc" id="L1210">                aa = ya + lnCoef_i[0];</span>
<span class="fc" id="L1211">                ab = yb + lnCoef_i[1];</span>
                /* Split y = a */
<span class="fc" id="L1213">                tmp = aa * HEX_40000000;</span>
<span class="fc" id="L1214">                ya = aa + tmp - tmp;</span>
<span class="fc" id="L1215">                yb = aa - ya + ab;</span>
            }

            /* Multiply a = y * x */
<span class="fc" id="L1219">            aa = ya * xa;</span>
<span class="fc" id="L1220">            ab = ya * xb + yb * xa + yb * xb;</span>
            /* split, so now y = a */
<span class="fc" id="L1222">            tmp = aa * HEX_40000000;</span>
<span class="fc" id="L1223">            ya = aa + tmp - tmp;</span>
<span class="fc" id="L1224">            yb = aa - ya + ab;</span>

<span class="fc" id="L1226">            return ya + yb;</span>
        }

        // lnm is a log of a number in the range of 1.0 - 2.0, so 0 &lt;= lnm &lt; ln(2)
<span class="fc" id="L1230">        final double[] lnm = lnMant.LN_MANT[(int)((bits &amp; 0x000ffc0000000000L) &gt;&gt; 42)];</span>

        /*
    double epsilon = x / Double.longBitsToDouble(bits &amp; 0xfffffc0000000000L);

    epsilon -= 1.0;
         */

        // y is the most significant 10 bits of the mantissa
        //double y = Double.longBitsToDouble(bits &amp; 0xfffffc0000000000L);
        //double epsilon = (x - y) / y;
<span class="fc" id="L1241">        final double epsilon = (bits &amp; 0x3ffffffffffL) / (TWO_POWER_52 + (bits &amp; 0x000ffc0000000000L));</span>

<span class="fc" id="L1243">        double lnza = 0.0;</span>
<span class="fc" id="L1244">        double lnzb = 0.0;</span>

<span class="fc bfc" id="L1246" title="All 2 branches covered.">        if (hiPrec != null) {</span>
            /* split epsilon -&gt; x */
<span class="fc" id="L1248">            double tmp = epsilon * HEX_40000000;</span>
<span class="fc" id="L1249">            double aa = epsilon + tmp - tmp;</span>
<span class="fc" id="L1250">            double ab = epsilon - aa;</span>
<span class="fc" id="L1251">            double xa = aa;</span>
<span class="fc" id="L1252">            double xb = ab;</span>

            /* Need a more accurate epsilon, so adjust the division. */
<span class="fc" id="L1255">            final double numer = bits &amp; 0x3ffffffffffL;</span>
<span class="fc" id="L1256">            final double denom = TWO_POWER_52 + (bits &amp; 0x000ffc0000000000L);</span>
<span class="fc" id="L1257">            aa = numer - xa*denom - xb * denom;</span>
<span class="fc" id="L1258">            xb += aa / denom;</span>

            /* Remez polynomial evaluation */
<span class="fc" id="L1261">            final double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1];</span>
<span class="fc" id="L1262">            double ya = lnCoef_last[0];</span>
<span class="fc" id="L1263">            double yb = lnCoef_last[1];</span>

<span class="fc bfc" id="L1265" title="All 2 branches covered.">            for (int i = LN_HI_PREC_COEF.length - 2; i &gt;= 0; i--) {</span>
                /* Multiply a = y * x */
<span class="fc" id="L1267">                aa = ya * xa;</span>
<span class="fc" id="L1268">                ab = ya * xb + yb * xa + yb * xb;</span>
                /* split, so now y = a */
<span class="fc" id="L1270">                tmp = aa * HEX_40000000;</span>
<span class="fc" id="L1271">                ya = aa + tmp - tmp;</span>
<span class="fc" id="L1272">                yb = aa - ya + ab;</span>

                /* Add  a = y + lnHiPrecCoef */
<span class="fc" id="L1275">                final double[] lnCoef_i = LN_HI_PREC_COEF[i];</span>
<span class="fc" id="L1276">                aa = ya + lnCoef_i[0];</span>
<span class="fc" id="L1277">                ab = yb + lnCoef_i[1];</span>
                /* Split y = a */
<span class="fc" id="L1279">                tmp = aa * HEX_40000000;</span>
<span class="fc" id="L1280">                ya = aa + tmp - tmp;</span>
<span class="fc" id="L1281">                yb = aa - ya + ab;</span>
            }

            /* Multiply a = y * x */
<span class="fc" id="L1285">            aa = ya * xa;</span>
<span class="fc" id="L1286">            ab = ya * xb + yb * xa + yb * xb;</span>

            /* split, so now lnz = a */
            /*
      tmp = aa * 1073741824.0;
      lnza = aa + tmp - tmp;
      lnzb = aa - lnza + ab;
             */
<span class="fc" id="L1294">            lnza = aa + ab;</span>
<span class="fc" id="L1295">            lnzb = -(lnza - aa - ab);</span>
<span class="fc" id="L1296">        } else {</span>
            /* High precision not required.  Eval Remez polynomial
         using standard double precision */
<span class="fc" id="L1299">            lnza = -0.16624882440418567;</span>
<span class="fc" id="L1300">            lnza = lnza * epsilon + 0.19999954120254515;</span>
<span class="fc" id="L1301">            lnza = lnza * epsilon + -0.2499999997677497;</span>
<span class="fc" id="L1302">            lnza = lnza * epsilon + 0.3333333333332802;</span>
<span class="fc" id="L1303">            lnza = lnza * epsilon + -0.5;</span>
<span class="fc" id="L1304">            lnza = lnza * epsilon + 1.0;</span>
<span class="fc" id="L1305">            lnza *= epsilon;</span>
        }

        /* Relative sizes:
         * lnzb     [0, 2.33E-10]
         * lnm[1]   [0, 1.17E-7]
         * ln2B*exp [0, 1.12E-4]
         * lnza      [0, 9.7E-4]
         * lnm[0]   [0, 0.692]
         * ln2A*exp [0, 709]
         */

        /* Compute the following sum:
         * lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;
         */

        //return lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;
<span class="fc" id="L1322">        double a = LN_2_A*exp;</span>
<span class="fc" id="L1323">        double b = 0.0;</span>
<span class="fc" id="L1324">        double c = a+lnm[0];</span>
<span class="fc" id="L1325">        double d = -(c-a-lnm[0]);</span>
<span class="fc" id="L1326">        a = c;</span>
<span class="fc" id="L1327">        b += d;</span>

<span class="fc" id="L1329">        c = a + lnza;</span>
<span class="fc" id="L1330">        d = -(c - a - lnza);</span>
<span class="fc" id="L1331">        a = c;</span>
<span class="fc" id="L1332">        b += d;</span>

<span class="fc" id="L1334">        c = a + LN_2_B*exp;</span>
<span class="fc" id="L1335">        d = -(c - a - LN_2_B*exp);</span>
<span class="fc" id="L1336">        a = c;</span>
<span class="fc" id="L1337">        b += d;</span>

<span class="fc" id="L1339">        c = a + lnm[1];</span>
<span class="fc" id="L1340">        d = -(c - a - lnm[1]);</span>
<span class="fc" id="L1341">        a = c;</span>
<span class="fc" id="L1342">        b += d;</span>

<span class="fc" id="L1344">        c = a + lnzb;</span>
<span class="fc" id="L1345">        d = -(c - a - lnzb);</span>
<span class="fc" id="L1346">        a = c;</span>
<span class="fc" id="L1347">        b += d;</span>

<span class="fc bfc" id="L1349" title="All 2 branches covered.">        if (hiPrec != null) {</span>
<span class="fc" id="L1350">            hiPrec[0] = a;</span>
<span class="fc" id="L1351">            hiPrec[1] = b;</span>
        }

<span class="fc" id="L1354">        return a + b;</span>
    }

    /**
     * Computes log(1 + x).
     *
     * @param x Number.
     * @return {@code log(1 + x)}.
     */
    public static double log1p(final double x) {
<span class="fc bfc" id="L1364" title="All 2 branches covered.">        if (x == -1) {</span>
<span class="fc" id="L1365">            return Double.NEGATIVE_INFINITY;</span>
        }

<span class="fc bfc" id="L1368" title="All 2 branches covered.">        if (x == Double.POSITIVE_INFINITY) {</span>
<span class="fc" id="L1369">            return Double.POSITIVE_INFINITY;</span>
        }

<span class="fc bfc" id="L1372" title="All 4 branches covered.">        if (x &gt; 1e-6 ||</span>
            x &lt; -1e-6) {
<span class="fc" id="L1374">            final double xpa = 1 + x;</span>
<span class="fc" id="L1375">            final double xpb = -(xpa - 1 - x);</span>

<span class="fc" id="L1377">            final double[] hiPrec = new double[2];</span>
<span class="fc" id="L1378">            final double lores = log(xpa, hiPrec);</span>
<span class="pc bpc" id="L1379" title="1 of 2 branches missed.">            if (Double.isInfinite(lores)) { // Don't allow this to be converted to NaN</span>
<span class="nc" id="L1380">                return lores;</span>
            }

            // Do a taylor series expansion around xpa:
            //   f(x+y) = f(x) + f'(x) y + f''(x)/2 y^2
<span class="fc" id="L1385">            final double fx1 = xpb / xpa;</span>
<span class="fc" id="L1386">            final double epsilon = 0.5 * fx1 + 1;</span>
<span class="fc" id="L1387">            return epsilon * fx1 + hiPrec[1] + hiPrec[0];</span>
        } else {
            // Value is small |x| &lt; 1e6, do a Taylor series centered on 1.
<span class="fc" id="L1390">            final double y = (x * F_1_3 - F_1_2) * x + 1;</span>
<span class="fc" id="L1391">            return y * x;</span>
        }
    }

    /** Compute the base 10 logarithm.
     * @param x a number
     * @return log10(x)
     */
    public static double log10(final double x) {
<span class="fc" id="L1400">        final double hiPrec[] = new double[2];</span>

<span class="fc" id="L1402">        final double lores = log(x, hiPrec);</span>
<span class="fc bfc" id="L1403" title="All 2 branches covered.">        if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN</span>
<span class="fc" id="L1404">            return lores;</span>
        }

<span class="fc" id="L1407">        final double tmp = hiPrec[0] * HEX_40000000;</span>
<span class="fc" id="L1408">        final double lna = hiPrec[0] + tmp - tmp;</span>
<span class="fc" id="L1409">        final double lnb = hiPrec[0] - lna + hiPrec[1];</span>

<span class="fc" id="L1411">        final double rln10a = 0.4342944622039795;</span>
<span class="fc" id="L1412">        final double rln10b = 1.9699272335463627E-8;</span>

<span class="fc" id="L1414">        return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna;</span>
    }

    /**
     * Computes the &lt;a href=&quot;http://mathworld.wolfram.com/Logarithm.html&quot;&gt;
     * logarithm&lt;/a&gt; in a given base.
     *
     * Returns {@code NaN} if either argument is negative.
     * If {@code base} is 0 and {@code x} is positive, 0 is returned.
     * If {@code base} is positive and {@code x} is 0,
     * {@code Double.NEGATIVE_INFINITY} is returned.
     * If both arguments are 0, the result is {@code NaN}.
     *
     * @param base Base of the logarithm, must be greater than 0.
     * @param x Argument, must be greater than 0.
     * @return the value of the logarithm, i.e. the number {@code y} such that
     * &lt;code&gt;base&lt;sup&gt;y&lt;/sup&gt; = x&lt;/code&gt;.
     * @since 1.2 (previously in {@code MathUtils}, moved as of version 3.0)
     */
    public static double log(double base, double x) {
<span class="fc" id="L1434">        return log(x) / log(base);</span>
    }

    /**
     * Power function.  Compute x^y.
     *
     * @param x   a double
     * @param y   a double
     * @return double
     */
    public static double pow(double x, double y) {
<span class="fc" id="L1445">        final double lns[] = new double[2];</span>

<span class="fc bfc" id="L1447" title="All 2 branches covered.">        if (y == 0.0) {</span>
<span class="fc" id="L1448">            return 1.0;</span>
        }

<span class="fc bfc" id="L1451" title="All 2 branches covered.">        if (x != x) { // X is NaN</span>
<span class="fc" id="L1452">            return x;</span>
        }


<span class="fc bfc" id="L1456" title="All 2 branches covered.">        if (x == 0) {</span>
<span class="fc" id="L1457">            long bits = Double.doubleToRawLongBits(x);</span>
<span class="fc bfc" id="L1458" title="All 2 branches covered.">            if ((bits &amp; 0x8000000000000000L) != 0) {</span>
                // -zero
<span class="fc" id="L1460">                long yi = (long) y;</span>

<span class="pc bpc" id="L1462" title="1 of 6 branches missed.">                if (y &lt; 0 &amp;&amp; y == yi &amp;&amp; (yi &amp; 1) == 1) {</span>
<span class="fc" id="L1463">                    return Double.NEGATIVE_INFINITY;</span>
                }

<span class="pc bpc" id="L1466" title="1 of 6 branches missed.">                if (y &gt; 0 &amp;&amp; y == yi &amp;&amp; (yi &amp; 1) == 1) {</span>
<span class="nc" id="L1467">                    return -0.0;</span>
                }
            }

<span class="fc bfc" id="L1471" title="All 2 branches covered.">            if (y &lt; 0) {</span>
<span class="fc" id="L1472">                return Double.POSITIVE_INFINITY;</span>
            }
<span class="fc bfc" id="L1474" title="All 2 branches covered.">            if (y &gt; 0) {</span>
<span class="fc" id="L1475">                return 0.0;</span>
            }

<span class="fc" id="L1478">            return Double.NaN;</span>
        }

<span class="fc bfc" id="L1481" title="All 2 branches covered.">        if (x == Double.POSITIVE_INFINITY) {</span>
<span class="fc bfc" id="L1482" title="All 2 branches covered.">            if (y != y) { // y is NaN</span>
<span class="fc" id="L1483">                return y;</span>
            }
<span class="fc bfc" id="L1485" title="All 2 branches covered.">            if (y &lt; 0.0) {</span>
<span class="fc" id="L1486">                return 0.0;</span>
            } else {
<span class="fc" id="L1488">                return Double.POSITIVE_INFINITY;</span>
            }
        }

<span class="fc bfc" id="L1492" title="All 2 branches covered.">        if (y == Double.POSITIVE_INFINITY) {</span>
<span class="fc bfc" id="L1493" title="All 2 branches covered.">            if (x * x == 1.0) {</span>
<span class="fc" id="L1494">                return Double.NaN;</span>
            }

<span class="fc bfc" id="L1497" title="All 2 branches covered.">            if (x * x &gt; 1.0) {</span>
<span class="fc" id="L1498">                return Double.POSITIVE_INFINITY;</span>
            } else {
<span class="fc" id="L1500">                return 0.0;</span>
            }
        }

<span class="fc bfc" id="L1504" title="All 2 branches covered.">        if (x == Double.NEGATIVE_INFINITY) {</span>
<span class="fc bfc" id="L1505" title="All 2 branches covered.">            if (y != y) { // y is NaN</span>
<span class="fc" id="L1506">                return y;</span>
            }

<span class="fc bfc" id="L1509" title="All 2 branches covered.">            if (y &lt; 0) {</span>
<span class="fc" id="L1510">                long yi = (long) y;</span>
<span class="fc bfc" id="L1511" title="All 4 branches covered.">                if (y == yi &amp;&amp; (yi &amp; 1) == 1) {</span>
<span class="fc" id="L1512">                    return -0.0;</span>
                }

<span class="fc" id="L1515">                return 0.0;</span>
            }

<span class="pc bpc" id="L1518" title="1 of 2 branches missed.">            if (y &gt; 0)  {</span>
<span class="fc" id="L1519">                long yi = (long) y;</span>
<span class="fc bfc" id="L1520" title="All 4 branches covered.">                if (y == yi &amp;&amp; (yi &amp; 1) == 1) {</span>
<span class="fc" id="L1521">                    return Double.NEGATIVE_INFINITY;</span>
                }

<span class="fc" id="L1524">                return Double.POSITIVE_INFINITY;</span>
            }
        }

<span class="fc bfc" id="L1528" title="All 2 branches covered.">        if (y == Double.NEGATIVE_INFINITY) {</span>

<span class="fc bfc" id="L1530" title="All 2 branches covered.">            if (x * x == 1.0) {</span>
<span class="fc" id="L1531">                return Double.NaN;</span>
            }

<span class="fc bfc" id="L1534" title="All 2 branches covered.">            if (x * x &lt; 1.0) {</span>
<span class="fc" id="L1535">                return Double.POSITIVE_INFINITY;</span>
            } else {
<span class="fc" id="L1537">                return 0.0;</span>
            }
        }

        /* Handle special case x&lt;0 */
<span class="fc bfc" id="L1542" title="All 2 branches covered.">        if (x &lt; 0) {</span>
            // y is an even integer in this case
<span class="fc bfc" id="L1544" title="All 4 branches covered.">            if (y &gt;= TWO_POWER_53 || y &lt;= -TWO_POWER_53) {</span>
<span class="fc" id="L1545">                return pow(-x, y);</span>
            }

<span class="fc bfc" id="L1548" title="All 2 branches covered.">            if (y == (long) y) {</span>
                // If y is an integer
<span class="fc bfc" id="L1550" title="All 2 branches covered.">                return ((long)y &amp; 1) == 0 ? pow(-x, y) : -pow(-x, y);</span>
            } else {
<span class="fc" id="L1552">                return Double.NaN;</span>
            }
        }

        /* Split y into ya and yb such that y = ya+yb */
        double ya;
        double yb;
<span class="fc bfc" id="L1559" title="All 4 branches covered.">        if (y &lt; 8e298 &amp;&amp; y &gt; -8e298) {</span>
<span class="fc" id="L1560">            double tmp1 = y * HEX_40000000;</span>
<span class="fc" id="L1561">            ya = y + tmp1 - tmp1;</span>
<span class="fc" id="L1562">            yb = y - ya;</span>
<span class="fc" id="L1563">        } else {</span>
<span class="fc" id="L1564">            double tmp1 = y * 9.31322574615478515625E-10;</span>
<span class="fc" id="L1565">            double tmp2 = tmp1 * 9.31322574615478515625E-10;</span>
<span class="fc" id="L1566">            ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;</span>
<span class="fc" id="L1567">            yb = y - ya;</span>
        }

        /* Compute ln(x) */
<span class="fc" id="L1571">        final double lores = log(x, lns);</span>
<span class="pc bpc" id="L1572" title="1 of 2 branches missed.">        if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN</span>
<span class="nc" id="L1573">            return lores;</span>
        }

<span class="fc" id="L1576">        double lna = lns[0];</span>
<span class="fc" id="L1577">        double lnb = lns[1];</span>

        /* resplit lns */
<span class="fc" id="L1580">        double tmp1 = lna * HEX_40000000;</span>
<span class="fc" id="L1581">        double tmp2 = lna + tmp1 - tmp1;</span>
<span class="fc" id="L1582">        lnb += lna - tmp2;</span>
<span class="fc" id="L1583">        lna = tmp2;</span>

        // y*ln(x) = (aa+ab)
<span class="fc" id="L1586">        final double aa = lna * ya;</span>
<span class="fc" id="L1587">        final double ab = lna * yb + lnb * ya + lnb * yb;</span>

<span class="fc" id="L1589">        lna = aa+ab;</span>
<span class="fc" id="L1590">        lnb = -(lna - aa - ab);</span>

<span class="fc" id="L1592">        double z = 1.0 / 120.0;</span>
<span class="fc" id="L1593">        z = z * lnb + (1.0 / 24.0);</span>
<span class="fc" id="L1594">        z = z * lnb + (1.0 / 6.0);</span>
<span class="fc" id="L1595">        z = z * lnb + 0.5;</span>
<span class="fc" id="L1596">        z = z * lnb + 1.0;</span>
<span class="fc" id="L1597">        z *= lnb;</span>

<span class="fc" id="L1599">        final double result = exp(lna, z, null);</span>
        //result = result + result * z;
<span class="fc" id="L1601">        return result;</span>
    }


    /**
     * Raise a double to an int power.
     *
     * @param d Number to raise.
     * @param e Exponent.
     * @return d&lt;sup&gt;e&lt;/sup&gt;
     * @since 3.1
     */
    public static double pow(double d, int e) {

<span class="fc bfc" id="L1615" title="All 2 branches covered.">        if (e == 0) {</span>
<span class="fc" id="L1616">            return 1.0;</span>
<span class="fc bfc" id="L1617" title="All 2 branches covered.">        } else if (e &lt; 0) {</span>
<span class="fc" id="L1618">            e = -e;</span>
<span class="fc" id="L1619">            d = 1.0 / d;</span>
        }

        // split d as two 26 bits numbers
        // beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties
<span class="fc" id="L1624">        final int splitFactor = 0x8000001;</span>
<span class="fc" id="L1625">        final double cd       = splitFactor * d;</span>
<span class="fc" id="L1626">        final double d1High   = cd - (cd - d);</span>
<span class="fc" id="L1627">        final double d1Low    = d - d1High;</span>

        // prepare result
<span class="fc" id="L1630">        double resultHigh = 1;</span>
<span class="fc" id="L1631">        double resultLow  = 0;</span>

        // d^(2p)
<span class="fc" id="L1634">        double d2p     = d;</span>
<span class="fc" id="L1635">        double d2pHigh = d1High;</span>
<span class="fc" id="L1636">        double d2pLow  = d1Low;</span>

<span class="fc bfc" id="L1638" title="All 2 branches covered.">        while (e != 0) {</span>

<span class="fc bfc" id="L1640" title="All 2 branches covered.">            if ((e &amp; 0x1) != 0) {</span>
                // accurate multiplication result = result * d^(2p) using Veltkamp TwoProduct algorithm
                // beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties
<span class="fc" id="L1643">                final double tmpHigh = resultHigh * d2p;</span>
<span class="fc" id="L1644">                final double cRH     = splitFactor * resultHigh;</span>
<span class="fc" id="L1645">                final double rHH     = cRH - (cRH - resultHigh);</span>
<span class="fc" id="L1646">                final double rHL     = resultHigh - rHH;</span>
<span class="fc" id="L1647">                final double tmpLow  = rHL * d2pLow - (((tmpHigh - rHH * d2pHigh) - rHL * d2pHigh) - rHH * d2pLow);</span>
<span class="fc" id="L1648">                resultHigh = tmpHigh;</span>
<span class="fc" id="L1649">                resultLow  = resultLow * d2p + tmpLow;</span>
            }

            // accurate squaring d^(2(p+1)) = d^(2p) * d^(2p) using Veltkamp TwoProduct algorithm
            // beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties
<span class="fc" id="L1654">            final double tmpHigh = d2pHigh * d2p;</span>
<span class="fc" id="L1655">            final double cD2pH   = splitFactor * d2pHigh;</span>
<span class="fc" id="L1656">            final double d2pHH   = cD2pH - (cD2pH - d2pHigh);</span>
<span class="fc" id="L1657">            final double d2pHL   = d2pHigh - d2pHH;</span>
<span class="fc" id="L1658">            final double tmpLow  = d2pHL * d2pLow - (((tmpHigh - d2pHH * d2pHigh) - d2pHL * d2pHigh) - d2pHH * d2pLow);</span>
<span class="fc" id="L1659">            final double cTmpH   = splitFactor * tmpHigh;</span>
<span class="fc" id="L1660">            d2pHigh = cTmpH - (cTmpH - tmpHigh);</span>
<span class="fc" id="L1661">            d2pLow  = d2pLow * d2p + tmpLow + (tmpHigh - d2pHigh);</span>
<span class="fc" id="L1662">            d2p     = d2pHigh + d2pLow;</span>

<span class="fc" id="L1664">            e &gt;&gt;= 1;</span>

<span class="fc" id="L1666">        }</span>

<span class="fc" id="L1668">        return resultHigh + resultLow;</span>

    }

    /**
     *  Computes sin(x) - x, where |x| &lt; 1/16.
     *  Use a Remez polynomial approximation.
     *  @param x a number smaller than 1/16
     *  @return sin(x) - x
     */
    private static double polySine(final double x)
    {
<span class="fc" id="L1680">        double x2 = x*x;</span>

<span class="fc" id="L1682">        double p = 2.7553817452272217E-6;</span>
<span class="fc" id="L1683">        p = p * x2 + -1.9841269659586505E-4;</span>
<span class="fc" id="L1684">        p = p * x2 + 0.008333333333329196;</span>
<span class="fc" id="L1685">        p = p * x2 + -0.16666666666666666;</span>
        //p *= x2;
        //p *= x;
<span class="fc" id="L1688">        p = p * x2 * x;</span>

<span class="fc" id="L1690">        return p;</span>
    }

    /**
     *  Computes cos(x) - 1, where |x| &lt; 1/16.
     *  Use a Remez polynomial approximation.
     *  @param x a number smaller than 1/16
     *  @return cos(x) - 1
     */
    private static double polyCosine(double x) {
<span class="fc" id="L1700">        double x2 = x*x;</span>

<span class="fc" id="L1702">        double p = 2.479773539153719E-5;</span>
<span class="fc" id="L1703">        p = p * x2 + -0.0013888888689039883;</span>
<span class="fc" id="L1704">        p = p * x2 + 0.041666666666621166;</span>
<span class="fc" id="L1705">        p = p * x2 + -0.49999999999999994;</span>
<span class="fc" id="L1706">        p *= x2;</span>

<span class="fc" id="L1708">        return p;</span>
    }

    /**
     *  Compute sine over the first quadrant (0 &lt; x &lt; pi/2).
     *  Use combination of table lookup and rational polynomial expansion.
     *  @param xa number from which sine is requested
     *  @param xb extra bits for x (may be 0.0)
     *  @return sin(xa + xb)
     */
    private static double sinQ(double xa, double xb) {
<span class="fc" id="L1719">        int idx = (int) ((xa * 8.0) + 0.5);</span>
<span class="fc" id="L1720">        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;</span>

        // Table lookups
<span class="fc" id="L1723">        final double sintA = SINE_TABLE_A[idx];</span>
<span class="fc" id="L1724">        final double sintB = SINE_TABLE_B[idx];</span>
<span class="fc" id="L1725">        final double costA = COSINE_TABLE_A[idx];</span>
<span class="fc" id="L1726">        final double costB = COSINE_TABLE_B[idx];</span>

        // Polynomial eval of sin(epsilon), cos(epsilon)
<span class="fc" id="L1729">        double sinEpsA = epsilon;</span>
<span class="fc" id="L1730">        double sinEpsB = polySine(epsilon);</span>
<span class="fc" id="L1731">        final double cosEpsA = 1.0;</span>
<span class="fc" id="L1732">        final double cosEpsB = polyCosine(epsilon);</span>

        // Split epsilon   xa + xb = x
<span class="fc" id="L1735">        final double temp = sinEpsA * HEX_40000000;</span>
<span class="fc" id="L1736">        double temp2 = (sinEpsA + temp) - temp;</span>
<span class="fc" id="L1737">        sinEpsB +=  sinEpsA - temp2;</span>
<span class="fc" id="L1738">        sinEpsA = temp2;</span>

        /* Compute sin(x) by angle addition formula */
        double result;

        /* Compute the following sum:
         *
         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +
         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;
         *
         * Ranges of elements
         *
         * xxxtA   0            PI/2
         * xxxtB   -1.5e-9      1.5e-9
         * sinEpsA -0.0625      0.0625
         * sinEpsB -6e-11       6e-11
         * cosEpsA  1.0
         * cosEpsB  0           -0.0625
         *
         */

        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +
        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;

        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;
        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;
<span class="fc" id="L1764">        double a = 0;</span>
<span class="fc" id="L1765">        double b = 0;</span>

<span class="fc" id="L1767">        double t = sintA;</span>
<span class="fc" id="L1768">        double c = a + t;</span>
<span class="fc" id="L1769">        double d = -(c - a - t);</span>
<span class="fc" id="L1770">        a = c;</span>
<span class="fc" id="L1771">        b += d;</span>

<span class="fc" id="L1773">        t = costA * sinEpsA;</span>
<span class="fc" id="L1774">        c = a + t;</span>
<span class="fc" id="L1775">        d = -(c - a - t);</span>
<span class="fc" id="L1776">        a = c;</span>
<span class="fc" id="L1777">        b += d;</span>

<span class="fc" id="L1779">        b = b + sintA * cosEpsB + costA * sinEpsB;</span>
        /*
    t = sintA*cosEpsB;
    c = a + t;
    d = -(c - a - t);
    a = c;
    b = b + d;

    t = costA*sinEpsB;
    c = a + t;
    d = -(c - a - t);
    a = c;
    b = b + d;
         */

<span class="fc" id="L1794">        b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;</span>
        /*
    t = sintB;
    c = a + t;
    d = -(c - a - t);
    a = c;
    b = b + d;

    t = costB*sinEpsA;
    c = a + t;
    d = -(c - a - t);
    a = c;
    b = b + d;

    t = sintB*cosEpsB;
    c = a + t;
    d = -(c - a - t);
    a = c;
    b = b + d;

    t = costB*sinEpsB;
    c = a + t;
    d = -(c - a - t);
    a = c;
    b = b + d;
         */

<span class="fc bfc" id="L1821" title="All 2 branches covered.">        if (xb != 0.0) {</span>
<span class="fc" id="L1822">            t = ((costA + costB) * (cosEpsA + cosEpsB) -</span>
                 (sintA + sintB) * (sinEpsA + sinEpsB)) * xb;  // approximate cosine*xb
<span class="fc" id="L1824">            c = a + t;</span>
<span class="fc" id="L1825">            d = -(c - a - t);</span>
<span class="fc" id="L1826">            a = c;</span>
<span class="fc" id="L1827">            b += d;</span>
        }

<span class="fc" id="L1830">        result = a + b;</span>

<span class="fc" id="L1832">        return result;</span>
    }

    /**
     * Compute cosine in the first quadrant by subtracting input from PI/2 and
     * then calling sinQ.  This is more accurate as the input approaches PI/2.
     *  @param xa number from which cosine is requested
     *  @param xb extra bits for x (may be 0.0)
     *  @return cos(xa + xb)
     */
    private static double cosQ(double xa, double xb) {
<span class="fc" id="L1843">        final double pi2a = 1.5707963267948966;</span>
<span class="fc" id="L1844">        final double pi2b = 6.123233995736766E-17;</span>

<span class="fc" id="L1846">        final double a = pi2a - xa;</span>
<span class="fc" id="L1847">        double b = -(a - pi2a + xa);</span>
<span class="fc" id="L1848">        b += pi2b - xb;</span>

<span class="fc" id="L1850">        return sinQ(a, b);</span>
    }

    /**
     *  Compute tangent (or cotangent) over the first quadrant.   0 &lt; x &lt; pi/2
     *  Use combination of table lookup and rational polynomial expansion.
     *  @param xa number from which sine is requested
     *  @param xb extra bits for x (may be 0.0)
     *  @param cotanFlag if true, compute the cotangent instead of the tangent
     *  @return tan(xa+xb) (or cotangent, depending on cotanFlag)
     */
    private static double tanQ(double xa, double xb, boolean cotanFlag) {

<span class="fc" id="L1863">        int idx = (int) ((xa * 8.0) + 0.5);</span>
<span class="fc" id="L1864">        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;</span>

        // Table lookups
<span class="fc" id="L1867">        final double sintA = SINE_TABLE_A[idx];</span>
<span class="fc" id="L1868">        final double sintB = SINE_TABLE_B[idx];</span>
<span class="fc" id="L1869">        final double costA = COSINE_TABLE_A[idx];</span>
<span class="fc" id="L1870">        final double costB = COSINE_TABLE_B[idx];</span>

        // Polynomial eval of sin(epsilon), cos(epsilon)
<span class="fc" id="L1873">        double sinEpsA = epsilon;</span>
<span class="fc" id="L1874">        double sinEpsB = polySine(epsilon);</span>
<span class="fc" id="L1875">        final double cosEpsA = 1.0;</span>
<span class="fc" id="L1876">        final double cosEpsB = polyCosine(epsilon);</span>

        // Split epsilon   xa + xb = x
<span class="fc" id="L1879">        double temp = sinEpsA * HEX_40000000;</span>
<span class="fc" id="L1880">        double temp2 = (sinEpsA + temp) - temp;</span>
<span class="fc" id="L1881">        sinEpsB +=  sinEpsA - temp2;</span>
<span class="fc" id="L1882">        sinEpsA = temp2;</span>

        /* Compute sin(x) by angle addition formula */

        /* Compute the following sum:
         *
         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +
         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;
         *
         * Ranges of elements
         *
         * xxxtA   0            PI/2
         * xxxtB   -1.5e-9      1.5e-9
         * sinEpsA -0.0625      0.0625
         * sinEpsB -6e-11       6e-11
         * cosEpsA  1.0
         * cosEpsB  0           -0.0625
         *
         */

        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +
        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;

        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;
        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;
<span class="fc" id="L1907">        double a = 0;</span>
<span class="fc" id="L1908">        double b = 0;</span>

        // Compute sine
<span class="fc" id="L1911">        double t = sintA;</span>
<span class="fc" id="L1912">        double c = a + t;</span>
<span class="fc" id="L1913">        double d = -(c - a - t);</span>
<span class="fc" id="L1914">        a = c;</span>
<span class="fc" id="L1915">        b += d;</span>

<span class="fc" id="L1917">        t = costA*sinEpsA;</span>
<span class="fc" id="L1918">        c = a + t;</span>
<span class="fc" id="L1919">        d = -(c - a - t);</span>
<span class="fc" id="L1920">        a = c;</span>
<span class="fc" id="L1921">        b += d;</span>

<span class="fc" id="L1923">        b += sintA*cosEpsB + costA*sinEpsB;</span>
<span class="fc" id="L1924">        b += sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;</span>

<span class="fc" id="L1926">        double sina = a + b;</span>
<span class="fc" id="L1927">        double sinb = -(sina - a - b);</span>

        // Compute cosine

<span class="fc" id="L1931">        a = b = c = d = 0.0;</span>

<span class="fc" id="L1933">        t = costA*cosEpsA;</span>
<span class="fc" id="L1934">        c = a + t;</span>
<span class="fc" id="L1935">        d = -(c - a - t);</span>
<span class="fc" id="L1936">        a = c;</span>
<span class="fc" id="L1937">        b += d;</span>

<span class="fc" id="L1939">        t = -sintA*sinEpsA;</span>
<span class="fc" id="L1940">        c = a + t;</span>
<span class="fc" id="L1941">        d = -(c - a - t);</span>
<span class="fc" id="L1942">        a = c;</span>
<span class="fc" id="L1943">        b += d;</span>

<span class="fc" id="L1945">        b += costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;</span>
<span class="fc" id="L1946">        b -= sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB;</span>

<span class="fc" id="L1948">        double cosa = a + b;</span>
<span class="fc" id="L1949">        double cosb = -(cosa - a - b);</span>

<span class="fc bfc" id="L1951" title="All 2 branches covered.">        if (cotanFlag) {</span>
            double tmp;
<span class="fc" id="L1953">            tmp = cosa; cosa = sina; sina = tmp;</span>
<span class="fc" id="L1954">            tmp = cosb; cosb = sinb; sinb = tmp;</span>
        }


        /* estimate and correct, compute 1.0/(cosa+cosb) */
        /*
    double est = (sina+sinb)/(cosa+cosb);
    double err = (sina - cosa*est) + (sinb - cosb*est);
    est += err/(cosa+cosb);
    err = (sina - cosa*est) + (sinb - cosb*est);
         */

        // f(x) = 1/x,   f'(x) = -1/x^2

<span class="fc" id="L1968">        double est = sina/cosa;</span>

        /* Split the estimate to get more accurate read on division rounding */
<span class="fc" id="L1971">        temp = est * HEX_40000000;</span>
<span class="fc" id="L1972">        double esta = (est + temp) - temp;</span>
<span class="fc" id="L1973">        double estb =  est - esta;</span>

<span class="fc" id="L1975">        temp = cosa * HEX_40000000;</span>
<span class="fc" id="L1976">        double cosaa = (cosa + temp) - temp;</span>
<span class="fc" id="L1977">        double cosab =  cosa - cosaa;</span>

        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding
<span class="fc" id="L1980">        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding</span>
<span class="fc" id="L1981">        err += sinb/cosa;                     // Change in est due to sinb</span>
<span class="fc" id="L1982">        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb</span>

<span class="fc bfc" id="L1984" title="All 2 branches covered.">        if (xb != 0.0) {</span>
            // tan' = 1 + tan^2      cot' = -(1 + cot^2)
            // Approximate impact of xb
<span class="fc" id="L1987">            double xbadj = xb + est*est*xb;</span>
<span class="fc bfc" id="L1988" title="All 2 branches covered.">            if (cotanFlag) {</span>
<span class="fc" id="L1989">                xbadj = -xbadj;</span>
            }

<span class="fc" id="L1992">            err += xbadj;</span>
        }

<span class="fc" id="L1995">        return est+err;</span>
    }

    /** Reduce the input argument using the Payne and Hanek method.
     *  This is good for all inputs 0.0 &lt; x &lt; inf
     *  Output is remainder after dividing by PI/2
     *  The result array should contain 3 numbers.
     *  result[0] is the integer portion, so mod 4 this gives the quadrant.
     *  result[1] is the upper bits of the remainder
     *  result[2] is the lower bits of the remainder
     *
     * @param x number to reduce
     * @param result placeholder where to put the result
     */
    private static void reducePayneHanek(double x, double result[])
    {
        /* Convert input double to bits */
<span class="fc" id="L2012">        long inbits = Double.doubleToRawLongBits(x);</span>
<span class="fc" id="L2013">        int exponent = (int) ((inbits &gt;&gt; 52) &amp; 0x7ff) - 1023;</span>

        /* Convert to fixed point representation */
<span class="fc" id="L2016">        inbits &amp;= 0x000fffffffffffffL;</span>
<span class="fc" id="L2017">        inbits |= 0x0010000000000000L;</span>

        /* Normalize input to be between 0.5 and 1.0 */
<span class="fc" id="L2020">        exponent++;</span>
<span class="fc" id="L2021">        inbits &lt;&lt;= 11;</span>

        /* Based on the exponent, get a shifted copy of recip2pi */
        long shpi0;
        long shpiA;
        long shpiB;
<span class="fc" id="L2027">        int idx = exponent &gt;&gt; 6;</span>
<span class="fc" id="L2028">        int shift = exponent - (idx &lt;&lt; 6);</span>

<span class="fc bfc" id="L2030" title="All 2 branches covered.">        if (shift != 0) {</span>
<span class="pc bpc" id="L2031" title="1 of 2 branches missed.">            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] &lt;&lt; shift);</span>
<span class="fc" id="L2032">            shpi0 |= RECIP_2PI[idx] &gt;&gt;&gt; (64-shift);</span>
<span class="fc" id="L2033">            shpiA = (RECIP_2PI[idx] &lt;&lt; shift) | (RECIP_2PI[idx+1] &gt;&gt;&gt; (64-shift));</span>
<span class="fc" id="L2034">            shpiB = (RECIP_2PI[idx+1] &lt;&lt; shift) | (RECIP_2PI[idx+2] &gt;&gt;&gt; (64-shift));</span>
        } else {
<span class="pc bpc" id="L2036" title="1 of 2 branches missed.">            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];</span>
<span class="fc" id="L2037">            shpiA = RECIP_2PI[idx];</span>
<span class="fc" id="L2038">            shpiB = RECIP_2PI[idx+1];</span>
        }

        /* Multiply input by shpiA */
<span class="fc" id="L2042">        long a = inbits &gt;&gt;&gt; 32;</span>
<span class="fc" id="L2043">        long b = inbits &amp; 0xffffffffL;</span>

<span class="fc" id="L2045">        long c = shpiA &gt;&gt;&gt; 32;</span>
<span class="fc" id="L2046">        long d = shpiA &amp; 0xffffffffL;</span>

<span class="fc" id="L2048">        long ac = a * c;</span>
<span class="fc" id="L2049">        long bd = b * d;</span>
<span class="fc" id="L2050">        long bc = b * c;</span>
<span class="fc" id="L2051">        long ad = a * d;</span>

<span class="fc" id="L2053">        long prodB = bd + (ad &lt;&lt; 32);</span>
<span class="fc" id="L2054">        long prodA = ac + (ad &gt;&gt;&gt; 32);</span>

<span class="fc bfc" id="L2056" title="All 2 branches covered.">        boolean bita = (bd &amp; 0x8000000000000000L) != 0;</span>
<span class="fc bfc" id="L2057" title="All 2 branches covered.">        boolean bitb = (ad &amp; 0x80000000L ) != 0;</span>
<span class="fc bfc" id="L2058" title="All 2 branches covered.">        boolean bitsum = (prodB &amp; 0x8000000000000000L) != 0;</span>

        /* Carry */
<span class="pc bpc" id="L2061" title="2 of 10 branches missed.">        if ( (bita &amp;&amp; bitb) ||</span>
                ((bita || bitb) &amp;&amp; !bitsum) ) {
<span class="nc" id="L2063">            prodA++;</span>
        }

<span class="fc bfc" id="L2066" title="All 2 branches covered.">        bita = (prodB &amp; 0x8000000000000000L) != 0;</span>
<span class="fc bfc" id="L2067" title="All 2 branches covered.">        bitb = (bc &amp; 0x80000000L ) != 0;</span>

<span class="fc" id="L2069">        prodB += bc &lt;&lt; 32;</span>
<span class="fc" id="L2070">        prodA += bc &gt;&gt;&gt; 32;</span>

<span class="fc bfc" id="L2072" title="All 2 branches covered.">        bitsum = (prodB &amp; 0x8000000000000000L) != 0;</span>

        /* Carry */
<span class="fc bfc" id="L2075" title="All 10 branches covered.">        if ( (bita &amp;&amp; bitb) ||</span>
                ((bita || bitb) &amp;&amp; !bitsum) ) {
<span class="fc" id="L2077">            prodA++;</span>
        }

        /* Multiply input by shpiB */
<span class="fc" id="L2081">        c = shpiB &gt;&gt;&gt; 32;</span>
<span class="fc" id="L2082">        d = shpiB &amp; 0xffffffffL;</span>
<span class="fc" id="L2083">        ac = a * c;</span>
<span class="fc" id="L2084">        bc = b * c;</span>
<span class="fc" id="L2085">        ad = a * d;</span>

        /* Collect terms */
<span class="fc" id="L2088">        ac += (bc + ad) &gt;&gt;&gt; 32;</span>

<span class="fc bfc" id="L2090" title="All 2 branches covered.">        bita = (prodB &amp; 0x8000000000000000L) != 0;</span>
<span class="fc bfc" id="L2091" title="All 2 branches covered.">        bitb = (ac &amp; 0x8000000000000000L ) != 0;</span>
<span class="fc" id="L2092">        prodB += ac;</span>
<span class="fc bfc" id="L2093" title="All 2 branches covered.">        bitsum = (prodB &amp; 0x8000000000000000L) != 0;</span>
        /* Carry */
<span class="fc bfc" id="L2095" title="All 10 branches covered.">        if ( (bita &amp;&amp; bitb) ||</span>
                ((bita || bitb) &amp;&amp; !bitsum) ) {
<span class="fc" id="L2097">            prodA++;</span>
        }

        /* Multiply by shpi0 */
<span class="fc" id="L2101">        c = shpi0 &gt;&gt;&gt; 32;</span>
<span class="fc" id="L2102">        d = shpi0 &amp; 0xffffffffL;</span>

<span class="fc" id="L2104">        bd = b * d;</span>
<span class="fc" id="L2105">        bc = b * c;</span>
<span class="fc" id="L2106">        ad = a * d;</span>

<span class="fc" id="L2108">        prodA += bd + ((bc + ad) &lt;&lt; 32);</span>

        /*
         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of
         * PI/2, so use the following steps:
         * 1.) multiply by 4.
         * 2.) do a fixed point muliply by PI/4.
         * 3.) Convert to floating point.
         * 4.) Multiply by 2
         */

        /* This identifies the quadrant */
<span class="fc" id="L2120">        int intPart = (int)(prodA &gt;&gt;&gt; 62);</span>

        /* Multiply by 4 */
<span class="fc" id="L2123">        prodA &lt;&lt;= 2;</span>
<span class="fc" id="L2124">        prodA |= prodB &gt;&gt;&gt; 62;</span>
<span class="fc" id="L2125">        prodB &lt;&lt;= 2;</span>

        /* Multiply by PI/4 */
<span class="fc" id="L2128">        a = prodA &gt;&gt;&gt; 32;</span>
<span class="fc" id="L2129">        b = prodA &amp; 0xffffffffL;</span>

<span class="fc" id="L2131">        c = PI_O_4_BITS[0] &gt;&gt;&gt; 32;</span>
<span class="fc" id="L2132">        d = PI_O_4_BITS[0] &amp; 0xffffffffL;</span>

<span class="fc" id="L2134">        ac = a * c;</span>
<span class="fc" id="L2135">        bd = b * d;</span>
<span class="fc" id="L2136">        bc = b * c;</span>
<span class="fc" id="L2137">        ad = a * d;</span>

<span class="fc" id="L2139">        long prod2B = bd + (ad &lt;&lt; 32);</span>
<span class="fc" id="L2140">        long prod2A = ac + (ad &gt;&gt;&gt; 32);</span>

<span class="pc bpc" id="L2142" title="1 of 2 branches missed.">        bita = (bd &amp; 0x8000000000000000L) != 0;</span>
<span class="fc bfc" id="L2143" title="All 2 branches covered.">        bitb = (ad &amp; 0x80000000L ) != 0;</span>
<span class="fc bfc" id="L2144" title="All 2 branches covered.">        bitsum = (prod2B &amp; 0x8000000000000000L) != 0;</span>

        /* Carry */
<span class="pc bpc" id="L2147" title="5 of 10 branches missed.">        if ( (bita &amp;&amp; bitb) ||</span>
                ((bita || bitb) &amp;&amp; !bitsum) ) {
<span class="nc" id="L2149">            prod2A++;</span>
        }

<span class="fc bfc" id="L2152" title="All 2 branches covered.">        bita = (prod2B &amp; 0x8000000000000000L) != 0;</span>
<span class="fc bfc" id="L2153" title="All 2 branches covered.">        bitb = (bc &amp; 0x80000000L ) != 0;</span>

<span class="fc" id="L2155">        prod2B += bc &lt;&lt; 32;</span>
<span class="fc" id="L2156">        prod2A += bc &gt;&gt;&gt; 32;</span>

<span class="fc bfc" id="L2158" title="All 2 branches covered.">        bitsum = (prod2B &amp; 0x8000000000000000L) != 0;</span>

        /* Carry */
<span class="fc bfc" id="L2161" title="All 10 branches covered.">        if ( (bita &amp;&amp; bitb) ||</span>
                ((bita || bitb) &amp;&amp; !bitsum) ) {
<span class="fc" id="L2163">            prod2A++;</span>
        }

        /* Multiply input by pio4bits[1] */
<span class="fc" id="L2167">        c = PI_O_4_BITS[1] &gt;&gt;&gt; 32;</span>
<span class="fc" id="L2168">        d = PI_O_4_BITS[1] &amp; 0xffffffffL;</span>
<span class="fc" id="L2169">        ac = a * c;</span>
<span class="fc" id="L2170">        bc = b * c;</span>
<span class="fc" id="L2171">        ad = a * d;</span>

        /* Collect terms */
<span class="fc" id="L2174">        ac += (bc + ad) &gt;&gt;&gt; 32;</span>

<span class="fc bfc" id="L2176" title="All 2 branches covered.">        bita = (prod2B &amp; 0x8000000000000000L) != 0;</span>
<span class="fc bfc" id="L2177" title="All 2 branches covered.">        bitb = (ac &amp; 0x8000000000000000L ) != 0;</span>
<span class="fc" id="L2178">        prod2B += ac;</span>
<span class="fc bfc" id="L2179" title="All 2 branches covered.">        bitsum = (prod2B &amp; 0x8000000000000000L) != 0;</span>
        /* Carry */
<span class="fc bfc" id="L2181" title="All 10 branches covered.">        if ( (bita &amp;&amp; bitb) ||</span>
                ((bita || bitb) &amp;&amp; !bitsum) ) {
<span class="fc" id="L2183">            prod2A++;</span>
        }

        /* Multiply inputB by pio4bits[0] */
<span class="fc" id="L2187">        a = prodB &gt;&gt;&gt; 32;</span>
<span class="fc" id="L2188">        b = prodB &amp; 0xffffffffL;</span>
<span class="fc" id="L2189">        c = PI_O_4_BITS[0] &gt;&gt;&gt; 32;</span>
<span class="fc" id="L2190">        d = PI_O_4_BITS[0] &amp; 0xffffffffL;</span>
<span class="fc" id="L2191">        ac = a * c;</span>
<span class="fc" id="L2192">        bc = b * c;</span>
<span class="fc" id="L2193">        ad = a * d;</span>

        /* Collect terms */
<span class="fc" id="L2196">        ac += (bc + ad) &gt;&gt;&gt; 32;</span>

<span class="fc bfc" id="L2198" title="All 2 branches covered.">        bita = (prod2B &amp; 0x8000000000000000L) != 0;</span>
<span class="fc bfc" id="L2199" title="All 2 branches covered.">        bitb = (ac &amp; 0x8000000000000000L ) != 0;</span>
<span class="fc" id="L2200">        prod2B += ac;</span>
<span class="fc bfc" id="L2201" title="All 2 branches covered.">        bitsum = (prod2B &amp; 0x8000000000000000L) != 0;</span>
        /* Carry */
<span class="fc bfc" id="L2203" title="All 10 branches covered.">        if ( (bita &amp;&amp; bitb) ||</span>
                ((bita || bitb) &amp;&amp; !bitsum) ) {
<span class="fc" id="L2205">            prod2A++;</span>
        }

        /* Convert to double */
<span class="fc" id="L2209">        double tmpA = (prod2A &gt;&gt;&gt; 12) / TWO_POWER_52;  // High order 52 bits</span>
<span class="fc" id="L2210">        double tmpB = (((prod2A &amp; 0xfffL) &lt;&lt; 40) + (prod2B &gt;&gt;&gt; 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits</span>

<span class="fc" id="L2212">        double sumA = tmpA + tmpB;</span>
<span class="fc" id="L2213">        double sumB = -(sumA - tmpA - tmpB);</span>

        /* Multiply by PI/2 and return */
<span class="fc" id="L2216">        result[0] = intPart;</span>
<span class="fc" id="L2217">        result[1] = sumA * 2.0;</span>
<span class="fc" id="L2218">        result[2] = sumB * 2.0;</span>
<span class="fc" id="L2219">    }</span>

    /**
     * Sine function.
     *
     * @param x Argument.
     * @return sin(x)
     */
    public static double sin(double x) {
<span class="fc" id="L2228">        boolean negative = false;</span>
<span class="fc" id="L2229">        int quadrant = 0;</span>
        double xa;
<span class="fc" id="L2231">        double xb = 0.0;</span>

        /* Take absolute value of the input */
<span class="fc" id="L2234">        xa = x;</span>
<span class="fc bfc" id="L2235" title="All 2 branches covered.">        if (x &lt; 0) {</span>
<span class="fc" id="L2236">            negative = true;</span>
<span class="fc" id="L2237">            xa = -xa;</span>
        }

        /* Check for zero and negative zero */
<span class="fc bfc" id="L2241" title="All 2 branches covered.">        if (xa == 0.0) {</span>
<span class="fc" id="L2242">            long bits = Double.doubleToRawLongBits(x);</span>
<span class="fc bfc" id="L2243" title="All 2 branches covered.">            if (bits &lt; 0) {</span>
<span class="fc" id="L2244">                return -0.0;</span>
            }
<span class="fc" id="L2246">            return 0.0;</span>
        }

<span class="fc bfc" id="L2249" title="All 4 branches covered.">        if (xa != xa || xa == Double.POSITIVE_INFINITY) {</span>
<span class="fc" id="L2250">            return Double.NaN;</span>
        }

        /* Perform any argument reduction */
<span class="fc bfc" id="L2254" title="All 2 branches covered.">        if (xa &gt; 3294198.0) {</span>
            // PI * (2**20)
            // Argument too big for CodyWaite reduction.  Must use
            // PayneHanek.
<span class="fc" id="L2258">            double reduceResults[] = new double[3];</span>
<span class="fc" id="L2259">            reducePayneHanek(xa, reduceResults);</span>
<span class="fc" id="L2260">            quadrant = ((int) reduceResults[0]) &amp; 3;</span>
<span class="fc" id="L2261">            xa = reduceResults[1];</span>
<span class="fc" id="L2262">            xb = reduceResults[2];</span>
<span class="fc bfc" id="L2263" title="All 2 branches covered.">        } else if (xa &gt; 1.5707963267948966) {</span>
<span class="fc" id="L2264">            final CodyWaite cw = new CodyWaite(xa);</span>
<span class="fc" id="L2265">            quadrant = cw.getK() &amp; 3;</span>
<span class="fc" id="L2266">            xa = cw.getRemA();</span>
<span class="fc" id="L2267">            xb = cw.getRemB();</span>
        }

<span class="fc bfc" id="L2270" title="All 2 branches covered.">        if (negative) {</span>
<span class="fc" id="L2271">            quadrant ^= 2;  // Flip bit 1</span>
        }

<span class="pc bpc" id="L2274" title="1 of 5 branches missed.">        switch (quadrant) {</span>
            case 0:
<span class="fc" id="L2276">                return sinQ(xa, xb);</span>
            case 1:
<span class="fc" id="L2278">                return cosQ(xa, xb);</span>
            case 2:
<span class="fc" id="L2280">                return -sinQ(xa, xb);</span>
            case 3:
<span class="fc" id="L2282">                return -cosQ(xa, xb);</span>
            default:
<span class="nc" id="L2284">                return Double.NaN;</span>
        }
    }

    /**
     * Cosine function.
     *
     * @param x Argument.
     * @return cos(x)
     */
    public static double cos(double x) {
<span class="fc" id="L2295">        int quadrant = 0;</span>

        /* Take absolute value of the input */
<span class="fc" id="L2298">        double xa = x;</span>
<span class="fc bfc" id="L2299" title="All 2 branches covered.">        if (x &lt; 0) {</span>
<span class="fc" id="L2300">            xa = -xa;</span>
        }

<span class="fc bfc" id="L2303" title="All 4 branches covered.">        if (xa != xa || xa == Double.POSITIVE_INFINITY) {</span>
<span class="fc" id="L2304">            return Double.NaN;</span>
        }

        /* Perform any argument reduction */
<span class="fc" id="L2308">        double xb = 0;</span>
<span class="fc bfc" id="L2309" title="All 2 branches covered.">        if (xa &gt; 3294198.0) {</span>
            // PI * (2**20)
            // Argument too big for CodyWaite reduction.  Must use
            // PayneHanek.
<span class="fc" id="L2313">            double reduceResults[] = new double[3];</span>
<span class="fc" id="L2314">            reducePayneHanek(xa, reduceResults);</span>
<span class="fc" id="L2315">            quadrant = ((int) reduceResults[0]) &amp; 3;</span>
<span class="fc" id="L2316">            xa = reduceResults[1];</span>
<span class="fc" id="L2317">            xb = reduceResults[2];</span>
<span class="fc bfc" id="L2318" title="All 2 branches covered.">        } else if (xa &gt; 1.5707963267948966) {</span>
<span class="fc" id="L2319">            final CodyWaite cw = new CodyWaite(xa);</span>
<span class="fc" id="L2320">            quadrant = cw.getK() &amp; 3;</span>
<span class="fc" id="L2321">            xa = cw.getRemA();</span>
<span class="fc" id="L2322">            xb = cw.getRemB();</span>
        }

        //if (negative)
        //  quadrant = (quadrant + 2) % 4;

<span class="pc bpc" id="L2328" title="1 of 5 branches missed.">        switch (quadrant) {</span>
            case 0:
<span class="fc" id="L2330">                return cosQ(xa, xb);</span>
            case 1:
<span class="fc" id="L2332">                return -sinQ(xa, xb);</span>
            case 2:
<span class="fc" id="L2334">                return -cosQ(xa, xb);</span>
            case 3:
<span class="fc" id="L2336">                return sinQ(xa, xb);</span>
            default:
<span class="nc" id="L2338">                return Double.NaN;</span>
        }
    }

    /**
     * Tangent function.
     *
     * @param x Argument.
     * @return tan(x)
     */
    public static double tan(double x) {
<span class="fc" id="L2349">        boolean negative = false;</span>
<span class="fc" id="L2350">        int quadrant = 0;</span>

        /* Take absolute value of the input */
<span class="fc" id="L2353">        double xa = x;</span>
<span class="fc bfc" id="L2354" title="All 2 branches covered.">        if (x &lt; 0) {</span>
<span class="fc" id="L2355">            negative = true;</span>
<span class="fc" id="L2356">            xa = -xa;</span>
        }

        /* Check for zero and negative zero */
<span class="fc bfc" id="L2360" title="All 2 branches covered.">        if (xa == 0.0) {</span>
<span class="fc" id="L2361">            long bits = Double.doubleToRawLongBits(x);</span>
<span class="fc bfc" id="L2362" title="All 2 branches covered.">            if (bits &lt; 0) {</span>
<span class="fc" id="L2363">                return -0.0;</span>
            }
<span class="fc" id="L2365">            return 0.0;</span>
        }

<span class="fc bfc" id="L2368" title="All 4 branches covered.">        if (xa != xa || xa == Double.POSITIVE_INFINITY) {</span>
<span class="fc" id="L2369">            return Double.NaN;</span>
        }

        /* Perform any argument reduction */
<span class="fc" id="L2373">        double xb = 0;</span>
<span class="fc bfc" id="L2374" title="All 2 branches covered.">        if (xa &gt; 3294198.0) {</span>
            // PI * (2**20)
            // Argument too big for CodyWaite reduction.  Must use
            // PayneHanek.
<span class="fc" id="L2378">            double reduceResults[] = new double[3];</span>
<span class="fc" id="L2379">            reducePayneHanek(xa, reduceResults);</span>
<span class="fc" id="L2380">            quadrant = ((int) reduceResults[0]) &amp; 3;</span>
<span class="fc" id="L2381">            xa = reduceResults[1];</span>
<span class="fc" id="L2382">            xb = reduceResults[2];</span>
<span class="fc bfc" id="L2383" title="All 2 branches covered.">        } else if (xa &gt; 1.5707963267948966) {</span>
<span class="fc" id="L2384">            final CodyWaite cw = new CodyWaite(xa);</span>
<span class="fc" id="L2385">            quadrant = cw.getK() &amp; 3;</span>
<span class="fc" id="L2386">            xa = cw.getRemA();</span>
<span class="fc" id="L2387">            xb = cw.getRemB();</span>
        }

<span class="fc bfc" id="L2390" title="All 2 branches covered.">        if (xa &gt; 1.5) {</span>
            // Accuracy suffers between 1.5 and PI/2
<span class="fc" id="L2392">            final double pi2a = 1.5707963267948966;</span>
<span class="fc" id="L2393">            final double pi2b = 6.123233995736766E-17;</span>

<span class="fc" id="L2395">            final double a = pi2a - xa;</span>
<span class="fc" id="L2396">            double b = -(a - pi2a + xa);</span>
<span class="fc" id="L2397">            b += pi2b - xb;</span>

<span class="fc" id="L2399">            xa = a + b;</span>
<span class="fc" id="L2400">            xb = -(xa - a - b);</span>
<span class="fc" id="L2401">            quadrant ^= 1;</span>
<span class="fc" id="L2402">            negative ^= true;</span>
        }

        double result;
<span class="fc bfc" id="L2406" title="All 2 branches covered.">        if ((quadrant &amp; 1) == 0) {</span>
<span class="fc" id="L2407">            result = tanQ(xa, xb, false);</span>
        } else {
<span class="fc" id="L2409">            result = -tanQ(xa, xb, true);</span>
        }

<span class="fc bfc" id="L2412" title="All 2 branches covered.">        if (negative) {</span>
<span class="fc" id="L2413">            result = -result;</span>
        }

<span class="fc" id="L2416">        return result;</span>
    }

    /**
     * Arctangent function
     *  @param x a number
     *  @return atan(x)
     */
    public static double atan(double x) {
<span class="fc" id="L2425">        return atan(x, 0.0, false);</span>
    }

    /** Internal helper function to compute arctangent.
     * @param xa number from which arctangent is requested
     * @param xb extra bits for x (may be 0.0)
     * @param leftPlane if true, result angle must be put in the left half plane
     * @return atan(xa + xb) (or angle shifted by {@code PI} if leftPlane is true)
     */
    private static double atan(double xa, double xb, boolean leftPlane) {
<span class="fc bfc" id="L2435" title="All 2 branches covered.">        if (xa == 0.0) { // Matches +/- 0.0; return correct sign</span>
<span class="fc bfc" id="L2436" title="All 2 branches covered.">            return leftPlane ? copySign(Math.PI, xa) : xa;</span>
        }

        final boolean negate;
<span class="fc bfc" id="L2440" title="All 2 branches covered.">        if (xa &lt; 0) {</span>
            // negative
<span class="fc" id="L2442">            xa = -xa;</span>
<span class="fc" id="L2443">            xb = -xb;</span>
<span class="fc" id="L2444">            negate = true;</span>
        } else {
<span class="fc" id="L2446">            negate = false;</span>
        }

<span class="fc bfc" id="L2449" title="All 2 branches covered.">        if (xa &gt; 1.633123935319537E16) { // Very large input</span>
<span class="fc bfc" id="L2450" title="All 2 branches covered.">            return (negate ^ leftPlane) ? (-Math.PI * F_1_2) : (Math.PI * F_1_2);</span>
        }

        /* Estimate the closest tabulated arctan value, compute eps = xa-tangentTable */
        final int idx;
<span class="fc bfc" id="L2455" title="All 2 branches covered.">        if (xa &lt; 1) {</span>
<span class="fc" id="L2456">            idx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5);</span>
        } else {
<span class="fc" id="L2458">            final double oneOverXa = 1 / xa;</span>
<span class="fc" id="L2459">            idx = (int) (-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07);</span>
        }

<span class="fc" id="L2462">        final double ttA = TANGENT_TABLE_A[idx];</span>
<span class="fc" id="L2463">        final double ttB = TANGENT_TABLE_B[idx];</span>

<span class="fc" id="L2465">        double epsA = xa - ttA;</span>
<span class="fc" id="L2466">        double epsB = -(epsA - xa + ttA);</span>
<span class="fc" id="L2467">        epsB += xb - ttB;</span>

<span class="fc" id="L2469">        double temp = epsA + epsB;</span>
<span class="fc" id="L2470">        epsB = -(temp - epsA - epsB);</span>
<span class="fc" id="L2471">        epsA = temp;</span>

        /* Compute eps = eps / (1.0 + xa*tangent) */
<span class="fc" id="L2474">        temp = xa * HEX_40000000;</span>
<span class="fc" id="L2475">        double ya = xa + temp - temp;</span>
<span class="fc" id="L2476">        double yb = xb + xa - ya;</span>
<span class="fc" id="L2477">        xa = ya;</span>
<span class="fc" id="L2478">        xb += yb;</span>

        //if (idx &gt; 8 || idx == 0)
<span class="fc bfc" id="L2481" title="All 2 branches covered.">        if (idx == 0) {</span>
            /* If the slope of the arctan is gentle enough (&lt; 0.45), this approximation will suffice */
            //double denom = 1.0 / (1.0 + xa*tangentTableA[idx] + xb*tangentTableA[idx] + xa*tangentTableB[idx] + xb*tangentTableB[idx]);
<span class="fc" id="L2484">            final double denom = 1d / (1d + (xa + xb) * (ttA + ttB));</span>
            //double denom = 1.0 / (1.0 + xa*tangentTableA[idx]);
<span class="fc" id="L2486">            ya = epsA * denom;</span>
<span class="fc" id="L2487">            yb = epsB * denom;</span>
<span class="fc" id="L2488">        } else {</span>
<span class="fc" id="L2489">            double temp2 = xa * ttA;</span>
<span class="fc" id="L2490">            double za = 1d + temp2;</span>
<span class="fc" id="L2491">            double zb = -(za - 1d - temp2);</span>
<span class="fc" id="L2492">            temp2 = xb * ttA + xa * ttB;</span>
<span class="fc" id="L2493">            temp = za + temp2;</span>
<span class="fc" id="L2494">            zb += -(temp - za - temp2);</span>
<span class="fc" id="L2495">            za = temp;</span>

<span class="fc" id="L2497">            zb += xb * ttB;</span>
<span class="fc" id="L2498">            ya = epsA / za;</span>

<span class="fc" id="L2500">            temp = ya * HEX_40000000;</span>
<span class="fc" id="L2501">            final double yaa = (ya + temp) - temp;</span>
<span class="fc" id="L2502">            final double yab = ya - yaa;</span>

<span class="fc" id="L2504">            temp = za * HEX_40000000;</span>
<span class="fc" id="L2505">            final double zaa = (za + temp) - temp;</span>
<span class="fc" id="L2506">            final double zab = za - zaa;</span>

            /* Correct for rounding in division */
<span class="fc" id="L2509">            yb = (epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab) / za;</span>

<span class="fc" id="L2511">            yb += -epsA * zb / za / za;</span>
<span class="fc" id="L2512">            yb += epsB / za;</span>
        }


<span class="fc" id="L2516">        epsA = ya;</span>
<span class="fc" id="L2517">        epsB = yb;</span>

        /* Evaluate polynomial */
<span class="fc" id="L2520">        final double epsA2 = epsA * epsA;</span>

        /*
    yb = -0.09001346640161823;
    yb = yb * epsA2 + 0.11110718400605211;
    yb = yb * epsA2 + -0.1428571349122913;
    yb = yb * epsA2 + 0.19999999999273194;
    yb = yb * epsA2 + -0.33333333333333093;
    yb = yb * epsA2 * epsA;
         */

<span class="fc" id="L2531">        yb = 0.07490822288864472;</span>
<span class="fc" id="L2532">        yb = yb * epsA2 - 0.09088450866185192;</span>
<span class="fc" id="L2533">        yb = yb * epsA2 + 0.11111095942313305;</span>
<span class="fc" id="L2534">        yb = yb * epsA2 - 0.1428571423679182;</span>
<span class="fc" id="L2535">        yb = yb * epsA2 + 0.19999999999923582;</span>
<span class="fc" id="L2536">        yb = yb * epsA2 - 0.33333333333333287;</span>
<span class="fc" id="L2537">        yb = yb * epsA2 * epsA;</span>


<span class="fc" id="L2540">        ya = epsA;</span>

<span class="fc" id="L2542">        temp = ya + yb;</span>
<span class="fc" id="L2543">        yb = -(temp - ya - yb);</span>
<span class="fc" id="L2544">        ya = temp;</span>

        /* Add in effect of epsB.   atan'(x) = 1/(1+x^2) */
<span class="fc" id="L2547">        yb += epsB / (1d + epsA * epsA);</span>

<span class="fc" id="L2549">        final double eighths = EIGHTHS[idx];</span>

        //result = yb + eighths[idx] + ya;
<span class="fc" id="L2552">        double za = eighths + ya;</span>
<span class="fc" id="L2553">        double zb = -(za - eighths - ya);</span>
<span class="fc" id="L2554">        temp = za + yb;</span>
<span class="fc" id="L2555">        zb += -(temp - za - yb);</span>
<span class="fc" id="L2556">        za = temp;</span>

<span class="fc" id="L2558">        double result = za + zb;</span>

<span class="fc bfc" id="L2560" title="All 2 branches covered.">        if (leftPlane) {</span>
            // Result is in the left plane
<span class="fc" id="L2562">            final double resultb = -(result - za - zb);</span>
<span class="fc" id="L2563">            final double pia = 1.5707963267948966 * 2;</span>
<span class="fc" id="L2564">            final double pib = 6.123233995736766E-17 * 2;</span>

<span class="fc" id="L2566">            za = pia - result;</span>
<span class="fc" id="L2567">            zb = -(za - pia + result);</span>
<span class="fc" id="L2568">            zb += pib - resultb;</span>

<span class="fc" id="L2570">            result = za + zb;</span>
        }


<span class="fc bfc" id="L2574" title="All 2 branches covered.">        if (negate ^ leftPlane) {</span>
<span class="fc" id="L2575">            result = -result;</span>
        }

<span class="fc" id="L2578">        return result;</span>
    }

    /**
     * Two arguments arctangent function
     * @param y ordinate
     * @param x abscissa
     * @return phase angle of point (x,y) between {@code -PI} and {@code PI}
     */
    public static double atan2(double y, double x) {
<span class="fc bfc" id="L2588" title="All 4 branches covered.">        if (x != x || y != y) {</span>
<span class="fc" id="L2589">            return Double.NaN;</span>
        }

<span class="fc bfc" id="L2592" title="All 2 branches covered.">        if (y == 0) {</span>
<span class="fc" id="L2593">            final double result = x * y;</span>
<span class="fc" id="L2594">            final double invx = 1d / x;</span>
<span class="fc" id="L2595">            final double invy = 1d / y;</span>

<span class="fc bfc" id="L2597" title="All 2 branches covered.">            if (invx == 0) { // X is infinite</span>
<span class="fc bfc" id="L2598" title="All 2 branches covered.">                if (x &gt; 0) {</span>
<span class="fc" id="L2599">                    return y; // return +/- 0.0</span>
                } else {
<span class="fc" id="L2601">                    return copySign(Math.PI, y);</span>
                }
            }

<span class="fc bfc" id="L2605" title="All 4 branches covered.">            if (x &lt; 0 || invx &lt; 0) {</span>
<span class="pc bpc" id="L2606" title="1 of 4 branches missed.">                if (y &lt; 0 || invy &lt; 0) {</span>
<span class="fc" id="L2607">                    return -Math.PI;</span>
                } else {
<span class="fc" id="L2609">                    return Math.PI;</span>
                }
            } else {
<span class="fc" id="L2612">                return result;</span>
            }
        }

        // y cannot now be zero

<span class="fc bfc" id="L2618" title="All 2 branches covered.">        if (y == Double.POSITIVE_INFINITY) {</span>
<span class="fc bfc" id="L2619" title="All 2 branches covered.">            if (x == Double.POSITIVE_INFINITY) {</span>
<span class="fc" id="L2620">                return Math.PI * F_1_4;</span>
            }

<span class="fc bfc" id="L2623" title="All 2 branches covered.">            if (x == Double.NEGATIVE_INFINITY) {</span>
<span class="fc" id="L2624">                return Math.PI * F_3_4;</span>
            }

<span class="fc" id="L2627">            return Math.PI * F_1_2;</span>
        }

<span class="fc bfc" id="L2630" title="All 2 branches covered.">        if (y == Double.NEGATIVE_INFINITY) {</span>
<span class="fc bfc" id="L2631" title="All 2 branches covered.">            if (x == Double.POSITIVE_INFINITY) {</span>
<span class="fc" id="L2632">                return -Math.PI * F_1_4;</span>
            }

<span class="fc bfc" id="L2635" title="All 2 branches covered.">            if (x == Double.NEGATIVE_INFINITY) {</span>
<span class="fc" id="L2636">                return -Math.PI * F_3_4;</span>
            }

<span class="fc" id="L2639">            return -Math.PI * F_1_2;</span>
        }

<span class="fc bfc" id="L2642" title="All 2 branches covered.">        if (x == Double.POSITIVE_INFINITY) {</span>
<span class="pc bpc" id="L2643" title="1 of 4 branches missed.">            if (y &gt; 0 || 1 / y &gt; 0) {</span>
<span class="fc" id="L2644">                return 0d;</span>
            }

<span class="pc bpc" id="L2647" title="3 of 4 branches missed.">            if (y &lt; 0 || 1 / y &lt; 0) {</span>
<span class="fc" id="L2648">                return -0d;</span>
            }
        }

<span class="fc bfc" id="L2652" title="All 2 branches covered.">        if (x == Double.NEGATIVE_INFINITY)</span>
        {
<span class="pc bpc" id="L2654" title="1 of 4 branches missed.">            if (y &gt; 0.0 || 1 / y &gt; 0.0) {</span>
<span class="fc" id="L2655">                return Math.PI;</span>
            }

<span class="pc bpc" id="L2658" title="3 of 4 branches missed.">            if (y &lt; 0 || 1 / y &lt; 0) {</span>
<span class="fc" id="L2659">                return -Math.PI;</span>
            }
        }

        // Neither y nor x can be infinite or NAN here

<span class="fc bfc" id="L2665" title="All 2 branches covered.">        if (x == 0) {</span>
<span class="pc bpc" id="L2666" title="1 of 4 branches missed.">            if (y &gt; 0 || 1 / y &gt; 0) {</span>
<span class="fc" id="L2667">                return Math.PI * F_1_2;</span>
            }

<span class="pc bpc" id="L2670" title="3 of 4 branches missed.">            if (y &lt; 0 || 1 / y &lt; 0) {</span>
<span class="fc" id="L2671">                return -Math.PI * F_1_2;</span>
            }
        }

        // Compute ratio r = y/x
<span class="fc" id="L2676">        final double r = y / x;</span>
<span class="fc bfc" id="L2677" title="All 2 branches covered.">        if (Double.isInfinite(r)) { // bypass calculations that can create NaN</span>
<span class="fc bfc" id="L2678" title="All 2 branches covered.">            return atan(r, 0, x &lt; 0);</span>
        }

<span class="fc" id="L2681">        double ra = doubleHighPart(r);</span>
<span class="fc" id="L2682">        double rb = r - ra;</span>

        // Split x
<span class="fc" id="L2685">        final double xa = doubleHighPart(x);</span>
<span class="fc" id="L2686">        final double xb = x - xa;</span>

<span class="fc" id="L2688">        rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;</span>

<span class="fc" id="L2690">        final double temp = ra + rb;</span>
<span class="fc" id="L2691">        rb = -(temp - ra - rb);</span>
<span class="fc" id="L2692">        ra = temp;</span>

<span class="fc bfc" id="L2694" title="All 2 branches covered.">        if (ra == 0) { // Fix up the sign so atan works correctly</span>
<span class="fc" id="L2695">            ra = copySign(0d, y);</span>
        }

        // Call atan
<span class="fc bfc" id="L2699" title="All 2 branches covered.">        final double result = atan(ra, rb, x &lt; 0);</span>

<span class="fc" id="L2701">        return result;</span>
    }

    /** Compute the arc sine of a number.
     * @param x number on which evaluation is done
     * @return arc sine of x
     */
    public static double asin(double x) {
<span class="fc bfc" id="L2709" title="All 2 branches covered.">      if (x != x) {</span>
<span class="fc" id="L2710">          return Double.NaN;</span>
      }

<span class="fc bfc" id="L2713" title="All 4 branches covered.">      if (x &gt; 1.0 || x &lt; -1.0) {</span>
<span class="fc" id="L2714">          return Double.NaN;</span>
      }

<span class="fc bfc" id="L2717" title="All 2 branches covered.">      if (x == 1.0) {</span>
<span class="fc" id="L2718">          return Math.PI/2.0;</span>
      }

<span class="fc bfc" id="L2721" title="All 2 branches covered.">      if (x == -1.0) {</span>
<span class="fc" id="L2722">          return -Math.PI/2.0;</span>
      }

<span class="fc bfc" id="L2725" title="All 2 branches covered.">      if (x == 0.0) { // Matches +/- 0.0; return correct sign</span>
<span class="fc" id="L2726">          return x;</span>
      }

      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */

      /* Split x */
<span class="fc" id="L2732">      double temp = x * HEX_40000000;</span>
<span class="fc" id="L2733">      final double xa = x + temp - temp;</span>
<span class="fc" id="L2734">      final double xb = x - xa;</span>

      /* Square it */
<span class="fc" id="L2737">      double ya = xa*xa;</span>
<span class="fc" id="L2738">      double yb = xa*xb*2.0 + xb*xb;</span>

      /* Subtract from 1 */
<span class="fc" id="L2741">      ya = -ya;</span>
<span class="fc" id="L2742">      yb = -yb;</span>

<span class="fc" id="L2744">      double za = 1.0 + ya;</span>
<span class="fc" id="L2745">      double zb = -(za - 1.0 - ya);</span>

<span class="fc" id="L2747">      temp = za + yb;</span>
<span class="fc" id="L2748">      zb += -(temp - za - yb);</span>
<span class="fc" id="L2749">      za = temp;</span>

      /* Square root */
      double y;
<span class="fc" id="L2753">      y = sqrt(za);</span>
<span class="fc" id="L2754">      temp = y * HEX_40000000;</span>
<span class="fc" id="L2755">      ya = y + temp - temp;</span>
<span class="fc" id="L2756">      yb = y - ya;</span>

      /* Extend precision of sqrt */
<span class="fc" id="L2759">      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);</span>

      /* Contribution of zb to sqrt */
<span class="fc" id="L2762">      double dx = zb / (2.0*y);</span>

      // Compute ratio r = x/y
<span class="fc" id="L2765">      double r = x/y;</span>
<span class="fc" id="L2766">      temp = r * HEX_40000000;</span>
<span class="fc" id="L2767">      double ra = r + temp - temp;</span>
<span class="fc" id="L2768">      double rb = r - ra;</span>

<span class="fc" id="L2770">      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division</span>
<span class="fc" id="L2771">      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.</span>

<span class="fc" id="L2773">      temp = ra + rb;</span>
<span class="fc" id="L2774">      rb = -(temp - ra - rb);</span>
<span class="fc" id="L2775">      ra = temp;</span>

<span class="fc" id="L2777">      return atan(ra, rb, false);</span>
    }

    /** Compute the arc cosine of a number.
     * @param x number on which evaluation is done
     * @return arc cosine of x
     */
    public static double acos(double x) {
<span class="fc bfc" id="L2785" title="All 2 branches covered.">      if (x != x) {</span>
<span class="fc" id="L2786">          return Double.NaN;</span>
      }

<span class="fc bfc" id="L2789" title="All 4 branches covered.">      if (x &gt; 1.0 || x &lt; -1.0) {</span>
<span class="fc" id="L2790">          return Double.NaN;</span>
      }

<span class="fc bfc" id="L2793" title="All 2 branches covered.">      if (x == -1.0) {</span>
<span class="fc" id="L2794">          return Math.PI;</span>
      }

<span class="fc bfc" id="L2797" title="All 2 branches covered.">      if (x == 1.0) {</span>
<span class="fc" id="L2798">          return 0.0;</span>
      }

<span class="fc bfc" id="L2801" title="All 2 branches covered.">      if (x == 0) {</span>
<span class="fc" id="L2802">          return Math.PI/2.0;</span>
      }

      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */

      /* Split x */
<span class="fc" id="L2808">      double temp = x * HEX_40000000;</span>
<span class="fc" id="L2809">      final double xa = x + temp - temp;</span>
<span class="fc" id="L2810">      final double xb = x - xa;</span>

      /* Square it */
<span class="fc" id="L2813">      double ya = xa*xa;</span>
<span class="fc" id="L2814">      double yb = xa*xb*2.0 + xb*xb;</span>

      /* Subtract from 1 */
<span class="fc" id="L2817">      ya = -ya;</span>
<span class="fc" id="L2818">      yb = -yb;</span>

<span class="fc" id="L2820">      double za = 1.0 + ya;</span>
<span class="fc" id="L2821">      double zb = -(za - 1.0 - ya);</span>

<span class="fc" id="L2823">      temp = za + yb;</span>
<span class="fc" id="L2824">      zb += -(temp - za - yb);</span>
<span class="fc" id="L2825">      za = temp;</span>

      /* Square root */
<span class="fc" id="L2828">      double y = sqrt(za);</span>
<span class="fc" id="L2829">      temp = y * HEX_40000000;</span>
<span class="fc" id="L2830">      ya = y + temp - temp;</span>
<span class="fc" id="L2831">      yb = y - ya;</span>

      /* Extend precision of sqrt */
<span class="fc" id="L2834">      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);</span>

      /* Contribution of zb to sqrt */
<span class="fc" id="L2837">      yb += zb / (2.0*y);</span>
<span class="fc" id="L2838">      y = ya+yb;</span>
<span class="fc" id="L2839">      yb = -(y - ya - yb);</span>

      // Compute ratio r = y/x
<span class="fc" id="L2842">      double r = y/x;</span>

      // Did r overflow?
<span class="fc bfc" id="L2845" title="All 2 branches covered.">      if (Double.isInfinite(r)) { // x is effectively zero</span>
<span class="fc" id="L2846">          return Math.PI/2; // so return the appropriate value</span>
      }

<span class="fc" id="L2849">      double ra = doubleHighPart(r);</span>
<span class="fc" id="L2850">      double rb = r - ra;</span>

<span class="fc" id="L2852">      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division</span>
<span class="fc" id="L2853">      rb += yb / x;  // Add in effect additional bits of sqrt.</span>

<span class="fc" id="L2855">      temp = ra + rb;</span>
<span class="fc" id="L2856">      rb = -(temp - ra - rb);</span>
<span class="fc" id="L2857">      ra = temp;</span>

<span class="fc bfc" id="L2859" title="All 2 branches covered.">      return atan(ra, rb, x&lt;0);</span>
    }

    /** Compute the cubic root of a number.
     * @param x number on which evaluation is done
     * @return cubic root of x
     */
    public static double cbrt(double x) {
      /* Convert input double to bits */
<span class="fc" id="L2868">      long inbits = Double.doubleToRawLongBits(x);</span>
<span class="fc" id="L2869">      int exponent = (int) ((inbits &gt;&gt; 52) &amp; 0x7ff) - 1023;</span>
<span class="fc" id="L2870">      boolean subnormal = false;</span>

<span class="fc bfc" id="L2872" title="All 2 branches covered.">      if (exponent == -1023) {</span>
<span class="fc bfc" id="L2873" title="All 2 branches covered.">          if (x == 0) {</span>
<span class="fc" id="L2874">              return x;</span>
          }

          /* Subnormal, so normalize */
<span class="fc" id="L2878">          subnormal = true;</span>
<span class="fc" id="L2879">          x *= 1.8014398509481984E16;  // 2^54</span>
<span class="fc" id="L2880">          inbits = Double.doubleToRawLongBits(x);</span>
<span class="fc" id="L2881">          exponent = (int) ((inbits &gt;&gt; 52) &amp; 0x7ff) - 1023;</span>
      }

<span class="fc bfc" id="L2884" title="All 2 branches covered.">      if (exponent == 1024) {</span>
          // Nan or infinity.  Don't care which.
<span class="fc" id="L2886">          return x;</span>
      }

      /* Divide the exponent by 3 */
<span class="fc" id="L2890">      int exp3 = exponent / 3;</span>

      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */
<span class="fc" id="L2893">      double p2 = Double.longBitsToDouble((inbits &amp; 0x8000000000000000L) |</span>
                                          (long)(((exp3 + 1023) &amp; 0x7ff)) &lt;&lt; 52);

      /* This will be a number between 1 and 2 */
<span class="fc" id="L2897">      final double mant = Double.longBitsToDouble((inbits &amp; 0x000fffffffffffffL) | 0x3ff0000000000000L);</span>

      /* Estimate the cube root of mant by polynomial */
<span class="fc" id="L2900">      double est = -0.010714690733195933;</span>
<span class="fc" id="L2901">      est = est * mant + 0.0875862700108075;</span>
<span class="fc" id="L2902">      est = est * mant + -0.3058015757857271;</span>
<span class="fc" id="L2903">      est = est * mant + 0.7249995199969751;</span>
<span class="fc" id="L2904">      est = est * mant + 0.5039018405998233;</span>

<span class="fc" id="L2906">      est *= CBRTTWO[exponent % 3 + 2];</span>

      // est should now be good to about 15 bits of precision.   Do 2 rounds of
      // Newton's method to get closer,  this should get us full double precision
      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.
<span class="fc" id="L2911">      final double xs = x / (p2*p2*p2);</span>
<span class="fc" id="L2912">      est += (xs - est*est*est) / (3*est*est);</span>
<span class="fc" id="L2913">      est += (xs - est*est*est) / (3*est*est);</span>

      // Do one round of Newton's method in extended precision to get the last bit right.
<span class="fc" id="L2916">      double temp = est * HEX_40000000;</span>
<span class="fc" id="L2917">      double ya = est + temp - temp;</span>
<span class="fc" id="L2918">      double yb = est - ya;</span>

<span class="fc" id="L2920">      double za = ya * ya;</span>
<span class="fc" id="L2921">      double zb = ya * yb * 2.0 + yb * yb;</span>
<span class="fc" id="L2922">      temp = za * HEX_40000000;</span>
<span class="fc" id="L2923">      double temp2 = za + temp - temp;</span>
<span class="fc" id="L2924">      zb += za - temp2;</span>
<span class="fc" id="L2925">      za = temp2;</span>

<span class="fc" id="L2927">      zb = za * yb + ya * zb + zb * yb;</span>
<span class="fc" id="L2928">      za *= ya;</span>

<span class="fc" id="L2930">      double na = xs - za;</span>
<span class="fc" id="L2931">      double nb = -(na - xs + za);</span>
<span class="fc" id="L2932">      nb -= zb;</span>

<span class="fc" id="L2934">      est += (na+nb)/(3*est*est);</span>

      /* Scale by a power of two, so this is exact. */
<span class="fc" id="L2937">      est *= p2;</span>

<span class="fc bfc" id="L2939" title="All 2 branches covered.">      if (subnormal) {</span>
<span class="fc" id="L2940">          est *= 3.814697265625E-6;  // 2^-18</span>
      }

<span class="fc" id="L2943">      return est;</span>
    }

    /**
     *  Convert degrees to radians, with error of less than 0.5 ULP
     *  @param x angle in degrees
     *  @return x converted into radians
     */
    public static double toRadians(double x)
    {
<span class="fc bfc" id="L2953" title="All 4 branches covered.">        if (Double.isInfinite(x) || x == 0.0) { // Matches +/- 0.0; return correct sign</span>
<span class="fc" id="L2954">            return x;</span>
        }

        // These are PI/180 split into high and low order bits
<span class="fc" id="L2958">        final double facta = 0.01745329052209854;</span>
<span class="fc" id="L2959">        final double factb = 1.997844754509471E-9;</span>

<span class="fc" id="L2961">        double xa = doubleHighPart(x);</span>
<span class="fc" id="L2962">        double xb = x - xa;</span>

<span class="fc" id="L2964">        double result = xb * factb + xb * facta + xa * factb + xa * facta;</span>
<span class="fc bfc" id="L2965" title="All 2 branches covered.">        if (result == 0) {</span>
<span class="fc" id="L2966">            result *= x; // ensure correct sign if calculation underflows</span>
        }
<span class="fc" id="L2968">        return result;</span>
    }

    /**
     *  Convert radians to degrees, with error of less than 0.5 ULP
     *  @param x angle in radians
     *  @return x converted into degrees
     */
    public static double toDegrees(double x)
    {
<span class="fc bfc" id="L2978" title="All 4 branches covered.">        if (Double.isInfinite(x) || x == 0.0) { // Matches +/- 0.0; return correct sign</span>
<span class="fc" id="L2979">            return x;</span>
        }

        // These are 180/PI split into high and low order bits
<span class="fc" id="L2983">        final double facta = 57.2957763671875;</span>
<span class="fc" id="L2984">        final double factb = 3.145894820876798E-6;</span>

<span class="fc" id="L2986">        double xa = doubleHighPart(x);</span>
<span class="fc" id="L2987">        double xb = x - xa;</span>

<span class="fc" id="L2989">        return xb * factb + xb * facta + xa * factb + xa * facta;</span>
    }

    /**
     * Absolute value.
     * @param x number from which absolute value is requested
     * @return abs(x)
     */
    public static int abs(final int x) {
<span class="fc" id="L2998">        final int i = x &gt;&gt;&gt; 31;</span>
<span class="fc" id="L2999">        return (x ^ (~i + 1)) + i;</span>
    }

    /**
     * Absolute value.
     * @param x number from which absolute value is requested
     * @return abs(x)
     */
    public static long abs(final long x) {
<span class="fc" id="L3008">        final long l = x &gt;&gt;&gt; 63;</span>
        // l is one if x negative zero else
        // ~l+1 is zero if x is positive, -1 if x is negative
        // x^(~l+1) is x is x is positive, ~x if x is negative
        // add around
<span class="fc" id="L3013">        return (x ^ (~l + 1)) + l;</span>
    }

    /**
     * Absolute value.
     * @param x number from which absolute value is requested
     * @return abs(x)
     */
    public static float abs(final float x) {
<span class="fc" id="L3022">        return Float.intBitsToFloat(MASK_NON_SIGN_INT &amp; Float.floatToRawIntBits(x));</span>
    }

    /**
     * Absolute value.
     * @param x number from which absolute value is requested
     * @return abs(x)
     */
    public static double abs(double x) {
<span class="fc" id="L3031">        return Double.longBitsToDouble(MASK_NON_SIGN_LONG &amp; Double.doubleToRawLongBits(x));</span>
    }

    /**
     * Compute least significant bit (Unit in Last Position) for a number.
     * @param x number from which ulp is requested
     * @return ulp(x)
     */
    public static double ulp(double x) {
<span class="fc bfc" id="L3040" title="All 2 branches covered.">        if (Double.isInfinite(x)) {</span>
<span class="fc" id="L3041">            return Double.POSITIVE_INFINITY;</span>
        }
<span class="fc" id="L3043">        return abs(x - Double.longBitsToDouble(Double.doubleToRawLongBits(x) ^ 1));</span>
    }

    /**
     * Compute least significant bit (Unit in Last Position) for a number.
     * @param x number from which ulp is requested
     * @return ulp(x)
     */
    public static float ulp(float x) {
<span class="fc bfc" id="L3052" title="All 2 branches covered.">        if (Float.isInfinite(x)) {</span>
<span class="fc" id="L3053">            return Float.POSITIVE_INFINITY;</span>
        }
<span class="fc" id="L3055">        return abs(x - Float.intBitsToFloat(Float.floatToIntBits(x) ^ 1));</span>
    }

    /**
     * Multiply a double number by a power of 2.
     * @param d number to multiply
     * @param n power of 2
     * @return d &amp;times; 2&lt;sup&gt;n&lt;/sup&gt;
     */
    public static double scalb(final double d, final int n) {

        // first simple and fast handling when 2^n can be represented using normal numbers
<span class="fc bfc" id="L3067" title="All 4 branches covered.">        if ((n &gt; -1023) &amp;&amp; (n &lt; 1024)) {</span>
<span class="fc" id="L3068">            return d * Double.longBitsToDouble(((long) (n + 1023)) &lt;&lt; 52);</span>
        }

        // handle special cases
<span class="fc bfc" id="L3072" title="All 6 branches covered.">        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {</span>
<span class="fc" id="L3073">            return d;</span>
        }
<span class="fc bfc" id="L3075" title="All 2 branches covered.">        if (n &lt; -2098) {</span>
<span class="fc bfc" id="L3076" title="All 2 branches covered.">            return (d &gt; 0) ? 0.0 : -0.0;</span>
        }
<span class="fc bfc" id="L3078" title="All 2 branches covered.">        if (n &gt; 2097) {</span>
<span class="fc bfc" id="L3079" title="All 2 branches covered.">            return (d &gt; 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;</span>
        }

        // decompose d
<span class="fc" id="L3083">        final long bits = Double.doubleToRawLongBits(d);</span>
<span class="fc" id="L3084">        final long sign = bits &amp; 0x8000000000000000L;</span>
<span class="fc" id="L3085">        int  exponent   = ((int) (bits &gt;&gt;&gt; 52)) &amp; 0x7ff;</span>
<span class="fc" id="L3086">        long mantissa   = bits &amp; 0x000fffffffffffffL;</span>

        // compute scaled exponent
<span class="fc" id="L3089">        int scaledExponent = exponent + n;</span>

<span class="fc bfc" id="L3091" title="All 2 branches covered.">        if (n &lt; 0) {</span>
            // we are really in the case n &lt;= -1023
<span class="fc bfc" id="L3093" title="All 2 branches covered.">            if (scaledExponent &gt; 0) {</span>
                // both the input and the result are normal numbers, we only adjust the exponent
<span class="fc" id="L3095">                return Double.longBitsToDouble(sign | (((long) scaledExponent) &lt;&lt; 52) | mantissa);</span>
<span class="pc bpc" id="L3096" title="1 of 2 branches missed.">            } else if (scaledExponent &gt; -53) {</span>
                // the input is a normal number and the result is a subnormal number

                // recover the hidden mantissa bit
<span class="fc" id="L3100">                mantissa |= 1L &lt;&lt; 52;</span>

                // scales down complete mantissa, hence losing least significant bits
<span class="fc" id="L3103">                final long mostSignificantLostBit = mantissa &amp; (1L &lt;&lt; (-scaledExponent));</span>
<span class="fc" id="L3104">                mantissa &gt;&gt;&gt;= 1 - scaledExponent;</span>
<span class="fc bfc" id="L3105" title="All 2 branches covered.">                if (mostSignificantLostBit != 0) {</span>
                    // we need to add 1 bit to round up the result
<span class="fc" id="L3107">                    mantissa++;</span>
                }
<span class="fc" id="L3109">                return Double.longBitsToDouble(sign | mantissa);</span>

            } else {
                // no need to compute the mantissa, the number scales down to 0
<span class="nc bnc" id="L3113" title="All 2 branches missed.">                return (sign == 0L) ? 0.0 : -0.0;</span>
            }
        } else {
            // we are really in the case n &gt;= 1024
<span class="fc bfc" id="L3117" title="All 2 branches covered.">            if (exponent == 0) {</span>

                // the input number is subnormal, normalize it
<span class="fc bfc" id="L3120" title="All 2 branches covered.">                while ((mantissa &gt;&gt;&gt; 52) != 1) {</span>
<span class="fc" id="L3121">                    mantissa &lt;&lt;= 1;</span>
<span class="fc" id="L3122">                    --scaledExponent;</span>
                }
<span class="fc" id="L3124">                ++scaledExponent;</span>
<span class="fc" id="L3125">                mantissa &amp;= 0x000fffffffffffffL;</span>

<span class="pc bpc" id="L3127" title="1 of 2 branches missed.">                if (scaledExponent &lt; 2047) {</span>
<span class="fc" id="L3128">                    return Double.longBitsToDouble(sign | (((long) scaledExponent) &lt;&lt; 52) | mantissa);</span>
                } else {
<span class="nc bnc" id="L3130" title="All 2 branches missed.">                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;</span>
                }

<span class="fc bfc" id="L3133" title="All 2 branches covered.">            } else if (scaledExponent &lt; 2047) {</span>
<span class="fc" id="L3134">                return Double.longBitsToDouble(sign | (((long) scaledExponent) &lt;&lt; 52) | mantissa);</span>
            } else {
<span class="pc bpc" id="L3136" title="1 of 2 branches missed.">                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;</span>
            }
        }

    }

    /**
     * Multiply a float number by a power of 2.
     * @param f number to multiply
     * @param n power of 2
     * @return f &amp;times; 2&lt;sup&gt;n&lt;/sup&gt;
     */
    public static float scalb(final float f, final int n) {

        // first simple and fast handling when 2^n can be represented using normal numbers
<span class="fc bfc" id="L3151" title="All 4 branches covered.">        if ((n &gt; -127) &amp;&amp; (n &lt; 128)) {</span>
<span class="fc" id="L3152">            return f * Float.intBitsToFloat((n + 127) &lt;&lt; 23);</span>
        }

        // handle special cases
<span class="fc bfc" id="L3156" title="All 6 branches covered.">        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {</span>
<span class="fc" id="L3157">            return f;</span>
        }
<span class="fc bfc" id="L3159" title="All 2 branches covered.">        if (n &lt; -277) {</span>
<span class="fc bfc" id="L3160" title="All 2 branches covered.">            return (f &gt; 0) ? 0.0f : -0.0f;</span>
        }
<span class="fc bfc" id="L3162" title="All 2 branches covered.">        if (n &gt; 276) {</span>
<span class="fc bfc" id="L3163" title="All 2 branches covered.">            return (f &gt; 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;</span>
        }

        // decompose f
<span class="fc" id="L3167">        final int bits = Float.floatToIntBits(f);</span>
<span class="fc" id="L3168">        final int sign = bits &amp; 0x80000000;</span>
<span class="fc" id="L3169">        int  exponent  = (bits &gt;&gt;&gt; 23) &amp; 0xff;</span>
<span class="fc" id="L3170">        int mantissa   = bits &amp; 0x007fffff;</span>

        // compute scaled exponent
<span class="fc" id="L3173">        int scaledExponent = exponent + n;</span>

<span class="fc bfc" id="L3175" title="All 2 branches covered.">        if (n &lt; 0) {</span>
            // we are really in the case n &lt;= -127
<span class="pc bpc" id="L3177" title="1 of 2 branches missed.">            if (scaledExponent &gt; 0) {</span>
                // both the input and the result are normal numbers, we only adjust the exponent
<span class="nc" id="L3179">                return Float.intBitsToFloat(sign | (scaledExponent &lt;&lt; 23) | mantissa);</span>
<span class="pc bpc" id="L3180" title="1 of 2 branches missed.">            } else if (scaledExponent &gt; -24) {</span>
                // the input is a normal number and the result is a subnormal number

                // recover the hidden mantissa bit
<span class="fc" id="L3184">                mantissa |= 1 &lt;&lt; 23;</span>

                // scales down complete mantissa, hence losing least significant bits
<span class="fc" id="L3187">                final int mostSignificantLostBit = mantissa &amp; (1 &lt;&lt; (-scaledExponent));</span>
<span class="fc" id="L3188">                mantissa &gt;&gt;&gt;= 1 - scaledExponent;</span>
<span class="pc bpc" id="L3189" title="1 of 2 branches missed.">                if (mostSignificantLostBit != 0) {</span>
                    // we need to add 1 bit to round up the result
<span class="fc" id="L3191">                    mantissa++;</span>
                }
<span class="fc" id="L3193">                return Float.intBitsToFloat(sign | mantissa);</span>

            } else {
                // no need to compute the mantissa, the number scales down to 0
<span class="nc bnc" id="L3197" title="All 2 branches missed.">                return (sign == 0) ? 0.0f : -0.0f;</span>
            }
        } else {
            // we are really in the case n &gt;= 128
<span class="fc bfc" id="L3201" title="All 2 branches covered.">            if (exponent == 0) {</span>

                // the input number is subnormal, normalize it
<span class="fc bfc" id="L3204" title="All 2 branches covered.">                while ((mantissa &gt;&gt;&gt; 23) != 1) {</span>
<span class="fc" id="L3205">                    mantissa &lt;&lt;= 1;</span>
<span class="fc" id="L3206">                    --scaledExponent;</span>
                }
<span class="fc" id="L3208">                ++scaledExponent;</span>
<span class="fc" id="L3209">                mantissa &amp;= 0x007fffff;</span>

<span class="pc bpc" id="L3211" title="1 of 2 branches missed.">                if (scaledExponent &lt; 255) {</span>
<span class="fc" id="L3212">                    return Float.intBitsToFloat(sign | (scaledExponent &lt;&lt; 23) | mantissa);</span>
                } else {
<span class="nc bnc" id="L3214" title="All 2 branches missed.">                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;</span>
                }

<span class="fc bfc" id="L3217" title="All 2 branches covered.">            } else if (scaledExponent &lt; 255) {</span>
<span class="fc" id="L3218">                return Float.intBitsToFloat(sign | (scaledExponent &lt;&lt; 23) | mantissa);</span>
            } else {
<span class="pc bpc" id="L3220" title="1 of 2 branches missed.">                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;</span>
            }
        }

    }

    /**
     * Get the next machine representable number after a number, moving
     * in the direction of another number.
     * &lt;p&gt;
     * The ordering is as follows (increasing):
     * &lt;ul&gt;
     * &lt;li&gt;-INFINITY&lt;/li&gt;
     * &lt;li&gt;-MAX_VALUE&lt;/li&gt;
     * &lt;li&gt;-MIN_VALUE&lt;/li&gt;
     * &lt;li&gt;-0.0&lt;/li&gt;
     * &lt;li&gt;+0.0&lt;/li&gt;
     * &lt;li&gt;+MIN_VALUE&lt;/li&gt;
     * &lt;li&gt;+MAX_VALUE&lt;/li&gt;
     * &lt;li&gt;+INFINITY&lt;/li&gt;
     * &lt;li&gt;&lt;/li&gt;
     * &lt;p&gt;
     * If arguments compare equal, then the second argument is returned.
     * &lt;p&gt;
     * If {@code direction} is greater than {@code d},
     * the smallest machine representable number strictly greater than
     * {@code d} is returned; if less, then the largest representable number
     * strictly less than {@code d} is returned.&lt;/p&gt;
     * &lt;p&gt;
     * If {@code d} is infinite and direction does not
     * bring it back to finite numbers, it is returned unchanged.&lt;/p&gt;
     *
     * @param d base number
     * @param direction (the only important thing is whether
     * {@code direction} is greater or smaller than {@code d})
     * @return the next machine representable number in the specified direction
     */
    public static double nextAfter(double d, double direction) {

        // handling of some important special cases
<span class="fc bfc" id="L3260" title="All 4 branches covered.">        if (Double.isNaN(d) || Double.isNaN(direction)) {</span>
<span class="fc" id="L3261">            return Double.NaN;</span>
<span class="fc bfc" id="L3262" title="All 2 branches covered.">        } else if (d == direction) {</span>
<span class="fc" id="L3263">            return direction;</span>
<span class="fc bfc" id="L3264" title="All 2 branches covered.">        } else if (Double.isInfinite(d)) {</span>
<span class="fc bfc" id="L3265" title="All 2 branches covered.">            return (d &lt; 0) ? -Double.MAX_VALUE : Double.MAX_VALUE;</span>
<span class="fc bfc" id="L3266" title="All 2 branches covered.">        } else if (d == 0) {</span>
<span class="fc bfc" id="L3267" title="All 2 branches covered.">            return (direction &lt; 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;</span>
        }
        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0
        // are handled just as normal numbers
        // can use raw bits since already dealt with infinity and NaN
<span class="fc" id="L3272">        final long bits = Double.doubleToRawLongBits(d);</span>
<span class="fc" id="L3273">        final long sign = bits &amp; 0x8000000000000000L;</span>
<span class="fc bfc" id="L3274" title="All 6 branches covered.">        if ((direction &lt; d) ^ (sign == 0L)) {</span>
<span class="fc" id="L3275">            return Double.longBitsToDouble(sign | ((bits &amp; 0x7fffffffffffffffL) + 1));</span>
        } else {
<span class="fc" id="L3277">            return Double.longBitsToDouble(sign | ((bits &amp; 0x7fffffffffffffffL) - 1));</span>
        }

    }

    /**
     * Get the next machine representable number after a number, moving
     * in the direction of another number.
     * &lt;p&gt;
     * The ordering is as follows (increasing):
     * &lt;ul&gt;
     * &lt;li&gt;-INFINITY&lt;/li&gt;
     * &lt;li&gt;-MAX_VALUE&lt;/li&gt;
     * &lt;li&gt;-MIN_VALUE&lt;/li&gt;
     * &lt;li&gt;-0.0&lt;/li&gt;
     * &lt;li&gt;+0.0&lt;/li&gt;
     * &lt;li&gt;+MIN_VALUE&lt;/li&gt;
     * &lt;li&gt;+MAX_VALUE&lt;/li&gt;
     * &lt;li&gt;+INFINITY&lt;/li&gt;
     * &lt;li&gt;&lt;/li&gt;
     * &lt;p&gt;
     * If arguments compare equal, then the second argument is returned.
     * &lt;p&gt;
     * If {@code direction} is greater than {@code f},
     * the smallest machine representable number strictly greater than
     * {@code f} is returned; if less, then the largest representable number
     * strictly less than {@code f} is returned.&lt;/p&gt;
     * &lt;p&gt;
     * If {@code f} is infinite and direction does not
     * bring it back to finite numbers, it is returned unchanged.&lt;/p&gt;
     *
     * @param f base number
     * @param direction (the only important thing is whether
     * {@code direction} is greater or smaller than {@code f})
     * @return the next machine representable number in the specified direction
     */
    public static float nextAfter(final float f, final double direction) {

        // handling of some important special cases
<span class="fc bfc" id="L3316" title="All 4 branches covered.">        if (Double.isNaN(f) || Double.isNaN(direction)) {</span>
<span class="fc" id="L3317">            return Float.NaN;</span>
<span class="fc bfc" id="L3318" title="All 2 branches covered.">        } else if (f == direction) {</span>
<span class="fc" id="L3319">            return (float) direction;</span>
<span class="fc bfc" id="L3320" title="All 2 branches covered.">        } else if (Float.isInfinite(f)) {</span>
<span class="fc bfc" id="L3321" title="All 2 branches covered.">            return (f &lt; 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;</span>
<span class="fc bfc" id="L3322" title="All 2 branches covered.">        } else if (f == 0f) {</span>
<span class="fc bfc" id="L3323" title="All 2 branches covered.">            return (direction &lt; 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;</span>
        }
        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0
        // are handled just as normal numbers

<span class="fc" id="L3328">        final int bits = Float.floatToIntBits(f);</span>
<span class="fc" id="L3329">        final int sign = bits &amp; 0x80000000;</span>
<span class="fc bfc" id="L3330" title="All 6 branches covered.">        if ((direction &lt; f) ^ (sign == 0)) {</span>
<span class="fc" id="L3331">            return Float.intBitsToFloat(sign | ((bits &amp; 0x7fffffff) + 1));</span>
        } else {
<span class="fc" id="L3333">            return Float.intBitsToFloat(sign | ((bits &amp; 0x7fffffff) - 1));</span>
        }

    }

    /** Get the largest whole number smaller than x.
     * @param x number from which floor is requested
     * @return a double number f such that f is an integer f &lt;= x &lt; f + 1.0
     */
    public static double floor(double x) {
        long y;

<span class="fc bfc" id="L3345" title="All 2 branches covered.">        if (x != x) { // NaN</span>
<span class="fc" id="L3346">            return x;</span>
        }

<span class="fc bfc" id="L3349" title="All 4 branches covered.">        if (x &gt;= TWO_POWER_52 || x &lt;= -TWO_POWER_52) {</span>
<span class="fc" id="L3350">            return x;</span>
        }

<span class="fc" id="L3353">        y = (long) x;</span>
<span class="fc bfc" id="L3354" title="All 4 branches covered.">        if (x &lt; 0 &amp;&amp; y != x) {</span>
<span class="fc" id="L3355">            y--;</span>
        }

<span class="fc bfc" id="L3358" title="All 2 branches covered.">        if (y == 0) {</span>
<span class="fc" id="L3359">            return x*y;</span>
        }

<span class="fc" id="L3362">        return y;</span>
    }

    /** Get the smallest whole number larger than x.
     * @param x number from which ceil is requested
     * @return a double number c such that c is an integer c - 1.0 &lt; x &lt;= c
     */
    public static double ceil(double x) {
        double y;

<span class="fc bfc" id="L3372" title="All 2 branches covered.">        if (x != x) { // NaN</span>
<span class="fc" id="L3373">            return x;</span>
        }

<span class="fc" id="L3376">        y = floor(x);</span>
<span class="fc bfc" id="L3377" title="All 2 branches covered.">        if (y == x) {</span>
<span class="fc" id="L3378">            return y;</span>
        }

<span class="fc" id="L3381">        y += 1.0;</span>

<span class="fc bfc" id="L3383" title="All 2 branches covered.">        if (y == 0) {</span>
<span class="fc" id="L3384">            return x*y;</span>
        }

<span class="fc" id="L3387">        return y;</span>
    }

    /** Get the whole number that is the nearest to x, or the even one if x is exactly half way between two integers.
     * @param x number from which nearest whole number is requested
     * @return a double number r such that r is an integer r - 0.5 &lt;= x &lt;= r + 0.5
     */
    public static double rint(double x) {
<span class="fc" id="L3395">        double y = floor(x);</span>
<span class="fc" id="L3396">        double d = x - y;</span>

<span class="fc bfc" id="L3398" title="All 2 branches covered.">        if (d &gt; 0.5) {</span>
<span class="fc bfc" id="L3399" title="All 2 branches covered.">            if (y == -1.0) {</span>
<span class="fc" id="L3400">                return -0.0; // Preserve sign of operand</span>
            }
<span class="fc" id="L3402">            return y+1.0;</span>
        }
<span class="fc bfc" id="L3404" title="All 2 branches covered.">        if (d &lt; 0.5) {</span>
<span class="fc" id="L3405">            return y;</span>
        }

        /* half way, round to even */
<span class="fc" id="L3409">        long z = (long) y;</span>
<span class="fc bfc" id="L3410" title="All 2 branches covered.">        return (z &amp; 1) == 0 ? y : y + 1.0;</span>
    }

    /** Get the closest long to x.
     * @param x number from which closest long is requested
     * @return closest long to x
     */
    public static long round(double x) {
<span class="fc" id="L3418">        return (long) floor(x + 0.5);</span>
    }

    /** Get the closest int to x.
     * @param x number from which closest int is requested
     * @return closest int to x
     */
    public static int round(final float x) {
<span class="fc" id="L3426">        return (int) floor(x + 0.5f);</span>
    }

    /** Compute the minimum of two values
     * @param a first value
     * @param b second value
     * @return a if a is lesser or equal to b, b otherwise
     */
    public static int min(final int a, final int b) {
<span class="fc bfc" id="L3435" title="All 2 branches covered.">        return (a &lt;= b) ? a : b;</span>
    }

    /** Compute the minimum of two values
     * @param a first value
     * @param b second value
     * @return a if a is lesser or equal to b, b otherwise
     */
    public static long min(final long a, final long b) {
<span class="fc bfc" id="L3444" title="All 2 branches covered.">        return (a &lt;= b) ? a : b;</span>
    }

    /** Compute the minimum of two values
     * @param a first value
     * @param b second value
     * @return a if a is lesser or equal to b, b otherwise
     */
    public static float min(final float a, final float b) {
<span class="fc bfc" id="L3453" title="All 2 branches covered.">        if (a &gt; b) {</span>
<span class="fc" id="L3454">            return b;</span>
        }
<span class="fc bfc" id="L3456" title="All 2 branches covered.">        if (a &lt; b) {</span>
<span class="fc" id="L3457">            return a;</span>
        }
        /* if either arg is NaN, return NaN */
<span class="fc bfc" id="L3460" title="All 2 branches covered.">        if (a != b) {</span>
<span class="fc" id="L3461">            return Float.NaN;</span>
        }
        /* min(+0.0,-0.0) == -0.0 */
        /* 0x80000000 == Float.floatToRawIntBits(-0.0d) */
<span class="fc" id="L3465">        int bits = Float.floatToRawIntBits(a);</span>
<span class="fc bfc" id="L3466" title="All 2 branches covered.">        if (bits == 0x80000000) {</span>
<span class="fc" id="L3467">            return a;</span>
        }
<span class="fc" id="L3469">        return b;</span>
    }

    /** Compute the minimum of two values
     * @param a first value
     * @param b second value
     * @return a if a is lesser or equal to b, b otherwise
     */
    public static double min(final double a, final double b) {
<span class="fc bfc" id="L3478" title="All 2 branches covered.">        if (a &gt; b) {</span>
<span class="fc" id="L3479">            return b;</span>
        }
<span class="fc bfc" id="L3481" title="All 2 branches covered.">        if (a &lt; b) {</span>
<span class="fc" id="L3482">            return a;</span>
        }
        /* if either arg is NaN, return NaN */
<span class="fc bfc" id="L3485" title="All 2 branches covered.">        if (a != b) {</span>
<span class="fc" id="L3486">            return Double.NaN;</span>
        }
        /* min(+0.0,-0.0) == -0.0 */
        /* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */
<span class="fc" id="L3490">        long bits = Double.doubleToRawLongBits(a);</span>
<span class="fc bfc" id="L3491" title="All 2 branches covered.">        if (bits == 0x8000000000000000L) {</span>
<span class="fc" id="L3492">            return a;</span>
        }
<span class="fc" id="L3494">        return b;</span>
    }

    /** Compute the maximum of two values
     * @param a first value
     * @param b second value
     * @return b if a is lesser or equal to b, a otherwise
     */
    public static int max(final int a, final int b) {
<span class="fc bfc" id="L3503" title="All 2 branches covered.">        return (a &lt;= b) ? b : a;</span>
    }

    /** Compute the maximum of two values
     * @param a first value
     * @param b second value
     * @return b if a is lesser or equal to b, a otherwise
     */
    public static long max(final long a, final long b) {
<span class="fc bfc" id="L3512" title="All 2 branches covered.">        return (a &lt;= b) ? b : a;</span>
    }

    /** Compute the maximum of two values
     * @param a first value
     * @param b second value
     * @return b if a is lesser or equal to b, a otherwise
     */
    public static float max(final float a, final float b) {
<span class="fc bfc" id="L3521" title="All 2 branches covered.">        if (a &gt; b) {</span>
<span class="fc" id="L3522">            return a;</span>
        }
<span class="fc bfc" id="L3524" title="All 2 branches covered.">        if (a &lt; b) {</span>
<span class="fc" id="L3525">            return b;</span>
        }
        /* if either arg is NaN, return NaN */
<span class="fc bfc" id="L3528" title="All 2 branches covered.">        if (a != b) {</span>
<span class="fc" id="L3529">            return Float.NaN;</span>
        }
        /* min(+0.0,-0.0) == -0.0 */
        /* 0x80000000 == Float.floatToRawIntBits(-0.0d) */
<span class="fc" id="L3533">        int bits = Float.floatToRawIntBits(a);</span>
<span class="fc bfc" id="L3534" title="All 2 branches covered.">        if (bits == 0x80000000) {</span>
<span class="fc" id="L3535">            return b;</span>
        }
<span class="fc" id="L3537">        return a;</span>
    }

    /** Compute the maximum of two values
     * @param a first value
     * @param b second value
     * @return b if a is lesser or equal to b, a otherwise
     */
    public static double max(final double a, final double b) {
<span class="fc bfc" id="L3546" title="All 2 branches covered.">        if (a &gt; b) {</span>
<span class="fc" id="L3547">            return a;</span>
        }
<span class="fc bfc" id="L3549" title="All 2 branches covered.">        if (a &lt; b) {</span>
<span class="fc" id="L3550">            return b;</span>
        }
        /* if either arg is NaN, return NaN */
<span class="fc bfc" id="L3553" title="All 2 branches covered.">        if (a != b) {</span>
<span class="fc" id="L3554">            return Double.NaN;</span>
        }
        /* min(+0.0,-0.0) == -0.0 */
        /* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */
<span class="fc" id="L3558">        long bits = Double.doubleToRawLongBits(a);</span>
<span class="fc bfc" id="L3559" title="All 2 branches covered.">        if (bits == 0x8000000000000000L) {</span>
<span class="fc" id="L3560">            return b;</span>
        }
<span class="fc" id="L3562">        return a;</span>
    }

    /**
     * Returns the hypotenuse of a triangle with sides {@code x} and {@code y}
     * - sqrt(&lt;i&gt;x&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;&amp;nbsp;+&lt;i&gt;y&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;)&lt;br/&gt;
     * avoiding intermediate overflow or underflow.
     *
     * &lt;ul&gt;
     * &lt;li&gt; If either argument is infinite, then the result is positive infinity.&lt;/li&gt;
     * &lt;li&gt; else, if either argument is NaN then the result is NaN.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param x a value
     * @param y a value
     * @return sqrt(&lt;i&gt;x&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;&amp;nbsp;+&lt;i&gt;y&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;)
     */
    public static double hypot(final double x, final double y) {
<span class="fc bfc" id="L3580" title="All 4 branches covered.">        if (Double.isInfinite(x) || Double.isInfinite(y)) {</span>
<span class="fc" id="L3581">            return Double.POSITIVE_INFINITY;</span>
<span class="fc bfc" id="L3582" title="All 4 branches covered.">        } else if (Double.isNaN(x) || Double.isNaN(y)) {</span>
<span class="fc" id="L3583">            return Double.NaN;</span>
        } else {

<span class="fc" id="L3586">            final int expX = getExponent(x);</span>
<span class="fc" id="L3587">            final int expY = getExponent(y);</span>
<span class="fc bfc" id="L3588" title="All 2 branches covered.">            if (expX &gt; expY + 27) {</span>
                // y is neglectible with respect to x
<span class="fc" id="L3590">                return abs(x);</span>
<span class="fc bfc" id="L3591" title="All 2 branches covered.">            } else if (expY &gt; expX + 27) {</span>
                // x is neglectible with respect to y
<span class="fc" id="L3593">                return abs(y);</span>
            } else {

                // find an intermediate scale to avoid both overflow and underflow
<span class="fc" id="L3597">                final int middleExp = (expX + expY) / 2;</span>

                // scale parameters without losing precision
<span class="fc" id="L3600">                final double scaledX = scalb(x, -middleExp);</span>
<span class="fc" id="L3601">                final double scaledY = scalb(y, -middleExp);</span>

                // compute scaled hypotenuse
<span class="fc" id="L3604">                final double scaledH = sqrt(scaledX * scaledX + scaledY * scaledY);</span>

                // remove scaling
<span class="fc" id="L3607">                return scalb(scaledH, middleExp);</span>

            }

        }
    }

    /**
     * Computes the remainder as prescribed by the IEEE 754 standard.
     * The remainder value is mathematically equal to {@code x - y*n}
     * where {@code n} is the mathematical integer closest to the exact mathematical value
     * of the quotient {@code x/y}.
     * If two mathematical integers are equally close to {@code x/y} then
     * {@code n} is the integer that is even.
     * &lt;p&gt;
     * &lt;ul&gt;
     * &lt;li&gt;If either operand is NaN, the result is NaN.&lt;/li&gt;
     * &lt;li&gt;If the result is not NaN, the sign of the result equals the sign of the dividend.&lt;/li&gt;
     * &lt;li&gt;If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.&lt;/li&gt;
     * &lt;li&gt;If the dividend is finite and the divisor is an infinity, the result equals the dividend.&lt;/li&gt;
     * &lt;li&gt;If the dividend is a zero and the divisor is finite, the result equals the dividend.&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; this implementation currently delegates to {@link StrictMath#IEEEremainder}
     * @param dividend the number to be divided
     * @param divisor the number by which to divide
     * @return the remainder, rounded
     */
    public static double IEEEremainder(double dividend, double divisor) {
<span class="fc" id="L3635">        return StrictMath.IEEEremainder(dividend, divisor); // TODO provide our own implementation</span>
    }

    /**
     * Returns the first argument with the sign of the second argument.
     * A NaN {@code sign} argument is treated as positive.
     *
     * @param magnitude the value to return
     * @param sign the sign for the returned value
     * @return the magnitude with the same sign as the {@code sign} argument
     */
    public static double copySign(double magnitude, double sign){
        // The highest order bit is going to be zero if the
        // highest order bit of m and s is the same and one otherwise.
        // So (m^s) will be positive if both m and s have the same sign
        // and negative otherwise.
<span class="fc" id="L3651">        final long m = Double.doubleToRawLongBits(magnitude); // don't care about NaN</span>
<span class="fc" id="L3652">        final long s = Double.doubleToRawLongBits(sign);</span>
<span class="fc bfc" id="L3653" title="All 2 branches covered.">        if ((m^s) &gt;= 0) {</span>
<span class="fc" id="L3654">            return magnitude;</span>
        }
<span class="fc" id="L3656">        return -magnitude; // flip sign</span>
    }

    /**
     * Returns the first argument with the sign of the second argument.
     * A NaN {@code sign} argument is treated as positive.
     *
     * @param magnitude the value to return
     * @param sign the sign for the returned value
     * @return the magnitude with the same sign as the {@code sign} argument
     */
    public static float copySign(float magnitude, float sign){
        // The highest order bit is going to be zero if the
        // highest order bit of m and s is the same and one otherwise.
        // So (m^s) will be positive if both m and s have the same sign
        // and negative otherwise.
<span class="fc" id="L3672">        final int m = Float.floatToRawIntBits(magnitude);</span>
<span class="fc" id="L3673">        final int s = Float.floatToRawIntBits(sign);</span>
<span class="fc bfc" id="L3674" title="All 2 branches covered.">        if ((m^s) &gt;= 0) {</span>
<span class="fc" id="L3675">            return magnitude;</span>
        }
<span class="fc" id="L3677">        return -magnitude; // flip sign</span>
    }

    /**
     * Return the exponent of a double number, removing the bias.
     * &lt;p&gt;
     * For double numbers of the form 2&lt;sup&gt;x&lt;/sup&gt;, the unbiased
     * exponent is exactly x.
     * &lt;/p&gt;
     * @param d number from which exponent is requested
     * @return exponent for d in IEEE754 representation, without bias
     */
    public static int getExponent(final double d) {
        // NaN and Infinite will return 1024 anywho so can use raw bits
<span class="fc" id="L3691">        return (int) ((Double.doubleToRawLongBits(d) &gt;&gt;&gt; 52) &amp; 0x7ff) - 1023;</span>
    }

    /**
     * Return the exponent of a float number, removing the bias.
     * &lt;p&gt;
     * For float numbers of the form 2&lt;sup&gt;x&lt;/sup&gt;, the unbiased
     * exponent is exactly x.
     * &lt;/p&gt;
     * @param f number from which exponent is requested
     * @return exponent for d in IEEE754 representation, without bias
     */
    public static int getExponent(final float f) {
        // NaN and Infinite will return the same exponent anywho so can use raw bits
<span class="fc" id="L3705">        return ((Float.floatToRawIntBits(f) &gt;&gt;&gt; 23) &amp; 0xff) - 127;</span>
    }

    /**
     * Print out contents of arrays, and check the length.
     * &lt;p&gt;used to generate the preset arrays originally.&lt;/p&gt;
     * @param a unused
     */
    public static void main(String[] a) {
<span class="nc" id="L3714">        PrintStream out = System.out;</span>
<span class="nc" id="L3715">        FastMathCalc.printarray(out, &quot;EXP_INT_TABLE_A&quot;, EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_A);</span>
<span class="nc" id="L3716">        FastMathCalc.printarray(out, &quot;EXP_INT_TABLE_B&quot;, EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_B);</span>
<span class="nc" id="L3717">        FastMathCalc.printarray(out, &quot;EXP_FRAC_TABLE_A&quot;, EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_A);</span>
<span class="nc" id="L3718">        FastMathCalc.printarray(out, &quot;EXP_FRAC_TABLE_B&quot;, EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_B);</span>
<span class="nc" id="L3719">        FastMathCalc.printarray(out, &quot;LN_MANT&quot;,LN_MANT_LEN, lnMant.LN_MANT);</span>
<span class="nc" id="L3720">        FastMathCalc.printarray(out, &quot;SINE_TABLE_A&quot;, SINE_TABLE_LEN, SINE_TABLE_A);</span>
<span class="nc" id="L3721">        FastMathCalc.printarray(out, &quot;SINE_TABLE_B&quot;, SINE_TABLE_LEN, SINE_TABLE_B);</span>
<span class="nc" id="L3722">        FastMathCalc.printarray(out, &quot;COSINE_TABLE_A&quot;, SINE_TABLE_LEN, COSINE_TABLE_A);</span>
<span class="nc" id="L3723">        FastMathCalc.printarray(out, &quot;COSINE_TABLE_B&quot;, SINE_TABLE_LEN, COSINE_TABLE_B);</span>
<span class="nc" id="L3724">        FastMathCalc.printarray(out, &quot;TANGENT_TABLE_A&quot;, SINE_TABLE_LEN, TANGENT_TABLE_A);</span>
<span class="nc" id="L3725">        FastMathCalc.printarray(out, &quot;TANGENT_TABLE_B&quot;, SINE_TABLE_LEN, TANGENT_TABLE_B);</span>
<span class="nc" id="L3726">    }</span>

    /** Enclose large data table in nested static class so it's only loaded on first access. */
    private static class ExpIntTable {
        /** Exponential evaluated at integer values,
         * exp(x) =  expIntTableA[x + EXP_INT_TABLE_MAX_INDEX] + expIntTableB[x+EXP_INT_TABLE_MAX_INDEX].
         */
        private static final double[] EXP_INT_TABLE_A;
        /** Exponential evaluated at integer values,
         * exp(x) =  expIntTableA[x + EXP_INT_TABLE_MAX_INDEX] + expIntTableB[x+EXP_INT_TABLE_MAX_INDEX]
         */
        private static final double[] EXP_INT_TABLE_B;

        static {
            if (RECOMPUTE_TABLES_AT_RUNTIME) {
                EXP_INT_TABLE_A = new double[FastMath.EXP_INT_TABLE_LEN];
                EXP_INT_TABLE_B = new double[FastMath.EXP_INT_TABLE_LEN];

                final double tmp[] = new double[2];
                final double recip[] = new double[2];

                // Populate expIntTable
                for (int i = 0; i &lt; FastMath.EXP_INT_TABLE_MAX_INDEX; i++) {
                    FastMathCalc.expint(i, tmp);
                    EXP_INT_TABLE_A[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[0];
                    EXP_INT_TABLE_B[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[1];

                    if (i != 0) {
                        // Negative integer powers
                        FastMathCalc.splitReciprocal(tmp, recip);
                        EXP_INT_TABLE_A[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[0];
                        EXP_INT_TABLE_B[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[1];
                    }
                }
            } else {
<span class="fc" id="L3761">                EXP_INT_TABLE_A = FastMathLiteralArrays.loadExpIntA();</span>
<span class="fc" id="L3762">                EXP_INT_TABLE_B = FastMathLiteralArrays.loadExpIntB();</span>
            }
<span class="fc" id="L3764">        }</span>
    }

    /** Enclose large data table in nested static class so it's only loaded on first access. */
    private static class ExpFracTable {
        /** Exponential over the range of 0 - 1 in increments of 2^-10
         * exp(x/1024) =  expFracTableA[x] + expFracTableB[x].
         * 1024 = 2^10
         */
        private static final double[] EXP_FRAC_TABLE_A;
        /** Exponential over the range of 0 - 1 in increments of 2^-10
         * exp(x/1024) =  expFracTableA[x] + expFracTableB[x].
         */
        private static final double[] EXP_FRAC_TABLE_B;

        static {
            if (RECOMPUTE_TABLES_AT_RUNTIME) {
                EXP_FRAC_TABLE_A = new double[FastMath.EXP_FRAC_TABLE_LEN];
                EXP_FRAC_TABLE_B = new double[FastMath.EXP_FRAC_TABLE_LEN];

                final double tmp[] = new double[2];

                // Populate expFracTable
                final double factor = 1d / (EXP_FRAC_TABLE_LEN - 1);
                for (int i = 0; i &lt; EXP_FRAC_TABLE_A.length; i++) {
                    FastMathCalc.slowexp(i * factor, tmp);
                    EXP_FRAC_TABLE_A[i] = tmp[0];
                    EXP_FRAC_TABLE_B[i] = tmp[1];
                }
            } else {
<span class="fc" id="L3794">                EXP_FRAC_TABLE_A = FastMathLiteralArrays.loadExpFracA();</span>
<span class="fc" id="L3795">                EXP_FRAC_TABLE_B = FastMathLiteralArrays.loadExpFracB();</span>
            }
<span class="fc" id="L3797">        }</span>
    }

    /** Enclose large data table in nested static class so it's only loaded on first access. */
    private static class lnMant {
        /** Extended precision logarithm table over the range 1 - 2 in increments of 2^-10. */
        private static final double[][] LN_MANT;

        static {
            if (RECOMPUTE_TABLES_AT_RUNTIME) {
                LN_MANT = new double[FastMath.LN_MANT_LEN][];

                // Populate lnMant table
                for (int i = 0; i &lt; LN_MANT.length; i++) {
                    final double d = Double.longBitsToDouble( (((long) i) &lt;&lt; 42) | 0x3ff0000000000000L );
                    LN_MANT[i] = FastMathCalc.slowLog(d);
                }
            } else {
<span class="fc" id="L3815">                LN_MANT = FastMathLiteralArrays.loadLnMant();</span>
            }
<span class="fc" id="L3817">        }</span>
    }

    /** Enclose the Cody/Waite reduction (used in &quot;sin&quot;, &quot;cos&quot; and &quot;tan&quot;). */
    private static class CodyWaite {
        /** k */
        private final int finalK;
        /** remA */
        private final double finalRemA;
        /** remB */
        private final double finalRemB;

        /**
         * @param xa Argument.
         */
<span class="fc" id="L3832">        CodyWaite(double xa) {</span>
            // Estimate k.
            //k = (int)(xa / 1.5707963267948966);
<span class="fc" id="L3835">            int k = (int)(xa * 0.6366197723675814);</span>

            // Compute remainder.
            double remA;
            double remB;
            while (true) {
<span class="fc" id="L3841">                double a = -k * 1.570796251296997;</span>
<span class="fc" id="L3842">                remA = xa + a;</span>
<span class="fc" id="L3843">                remB = -(remA - xa - a);</span>

<span class="fc" id="L3845">                a = -k * 7.549789948768648E-8;</span>
<span class="fc" id="L3846">                double b = remA;</span>
<span class="fc" id="L3847">                remA = a + b;</span>
<span class="fc" id="L3848">                remB += -(remA - b - a);</span>

<span class="fc" id="L3850">                a = -k * 6.123233995736766E-17;</span>
<span class="fc" id="L3851">                b = remA;</span>
<span class="fc" id="L3852">                remA = a + b;</span>
<span class="fc" id="L3853">                remB += -(remA - b - a);</span>

<span class="fc bfc" id="L3855" title="All 2 branches covered.">                if (remA &gt; 0) {</span>
<span class="fc" id="L3856">                    break;</span>
                }

                // Remainder is negative, so decrement k and try again.
                // This should only happen if the input is very close
                // to an even multiple of pi/2.
<span class="fc" id="L3862">                --k;</span>
<span class="fc" id="L3863">            }</span>

<span class="fc" id="L3865">            this.finalK = k;</span>
<span class="fc" id="L3866">            this.finalRemA = remA;</span>
<span class="fc" id="L3867">            this.finalRemB = remB;</span>
<span class="fc" id="L3868">        }</span>

        /**
         * @return k
         */
        int getK() {
<span class="fc" id="L3874">            return finalK;</span>
        }
        /**
         * @return remA
         */
        double getRemA() {
<span class="fc" id="L3880">            return finalRemA;</span>
        }
        /**
         * @return remB
         */
        double getRemB() {
<span class="fc" id="L3886">            return finalRemB;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>