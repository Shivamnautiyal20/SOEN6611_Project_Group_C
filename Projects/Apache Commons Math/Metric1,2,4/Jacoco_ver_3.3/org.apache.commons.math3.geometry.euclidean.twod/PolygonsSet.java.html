<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PolygonsSet.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Math</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math3.geometry.euclidean.twod</a> &gt; <span class="el_source">PolygonsSet.java</span></div><h1>PolygonsSet.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.math3.geometry.euclidean.twod;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import org.apache.commons.math3.exception.MathInternalError;
import org.apache.commons.math3.geometry.Point;
import org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D;
import org.apache.commons.math3.geometry.euclidean.oned.Interval;
import org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet;
import org.apache.commons.math3.geometry.euclidean.oned.Vector1D;
import org.apache.commons.math3.geometry.partitioning.AbstractRegion;
import org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane;
import org.apache.commons.math3.geometry.partitioning.BSPTree;
import org.apache.commons.math3.geometry.partitioning.BSPTreeVisitor;
import org.apache.commons.math3.geometry.partitioning.BoundaryAttribute;
import org.apache.commons.math3.geometry.partitioning.Side;
import org.apache.commons.math3.geometry.partitioning.SubHyperplane;
import org.apache.commons.math3.geometry.partitioning.utilities.AVLTree;
import org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple;
import org.apache.commons.math3.util.FastMath;

/** This class represents a 2D region: a set of polygons.
 * @version $Id$
 * @since 3.0
 */
public class PolygonsSet extends AbstractRegion&lt;Euclidean2D, Euclidean1D&gt; {

    /** Default value for tolerance. */
    private static final double DEFAULT_TOLERANCE = 1.0e-10;

    /** Vertices organized as boundary loops. */
    private Vector2D[][] vertices;

    /** Build a polygons set representing the whole plane.
     * @param tolerance tolerance below which points are considered identical
     * @since 3.3
     */
    public PolygonsSet(final double tolerance) {
<span class="fc" id="L57">        super(tolerance);</span>
<span class="fc" id="L58">    }</span>

    /** Build a polygons set from a BSP tree.
     * &lt;p&gt;The leaf nodes of the BSP tree &lt;em&gt;must&lt;/em&gt; have a
     * {@code Boolean} attribute representing the inside status of
     * the corresponding cell (true for inside cells, false for outside
     * cells). In order to avoid building too many small objects, it is
     * recommended to use the predefined constants
     * {@code Boolean.TRUE} and {@code Boolean.FALSE}&lt;/p&gt;
     * &lt;p&gt;
     * This constructor is aimed at expert use, as building the tree may
     * be a difficult task. It is not intended for general use and for
     * performances reasons does not check thoroughly its input, as this would
     * require walking the full tree each time. Failing to provide a tree with
     * the proper attributes, &lt;em&gt;will&lt;/em&gt; therefore generate problems like
     * {@link NullPointerException} or {@link ClassCastException} only later on.
     * This limitation is known and explains why this constructor is for expert
     * use only. The caller does have the responsibility to provided correct arguments.
     * &lt;/p&gt;
     * @param tree inside/outside BSP tree representing the region
     * @param tolerance tolerance below which points are considered identical
     * @since 3.3
     */
    public PolygonsSet(final BSPTree&lt;Euclidean2D&gt; tree, final double tolerance) {
<span class="fc" id="L82">        super(tree, tolerance);</span>
<span class="fc" id="L83">    }</span>

    /** Build a polygons set from a Boundary REPresentation (B-rep).
     * &lt;p&gt;The boundary is provided as a collection of {@link
     * SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the
     * interior part of the region on its minus side and the exterior on
     * its plus side.&lt;/p&gt;
     * &lt;p&gt;The boundary elements can be in any order, and can form
     * several non-connected sets (like for example polygons with holes
     * or a set of disjoint polygons considered as a whole). In
     * fact, the elements do not even need to be connected together
     * (their topological connections are not used here). However, if the
     * boundary does not really separate an inside open from an outside
     * open (open having here its topological meaning), then subsequent
     * calls to the {@link
     * org.apache.commons.math3.geometry.partitioning.Region#checkPoint(org.apache.commons.math3.geometry.Point)
     * checkPoint} method will not be meaningful anymore.&lt;/p&gt;
     * &lt;p&gt;If the boundary is empty, the region will represent the whole
     * space.&lt;/p&gt;
     * @param boundary collection of boundary elements, as a
     * collection of {@link SubHyperplane SubHyperplane} objects
     * @param tolerance tolerance below which points are considered identical
     * @since 3.3
     */
    public PolygonsSet(final Collection&lt;SubHyperplane&lt;Euclidean2D&gt;&gt; boundary, final double tolerance) {
<span class="fc" id="L108">        super(boundary, tolerance);</span>
<span class="fc" id="L109">    }</span>

    /** Build a parallellepipedic box.
     * @param xMin low bound along the x direction
     * @param xMax high bound along the x direction
     * @param yMin low bound along the y direction
     * @param yMax high bound along the y direction
     * @param tolerance tolerance below which points are considered identical
     * @since 3.3
     */
    public PolygonsSet(final double xMin, final double xMax,
                       final double yMin, final double yMax,
                       final double tolerance) {
<span class="fc" id="L122">        super(boxBoundary(xMin, xMax, yMin, yMax, tolerance), tolerance);</span>
<span class="fc" id="L123">    }</span>

    /** Build a polygon from a simple list of vertices.
     * &lt;p&gt;The boundary is provided as a list of points considering to
     * represent the vertices of a simple loop. The interior part of the
     * region is on the left side of this path and the exterior is on its
     * right side.&lt;/p&gt;
     * &lt;p&gt;This constructor does not handle polygons with a boundary
     * forming several disconnected paths (such as polygons with holes).&lt;/p&gt;
     * &lt;p&gt;For cases where this simple constructor applies, it is expected to
     * be numerically more robust than the {@link #PolygonsSet(Collection) general
     * constructor} using {@link SubHyperplane subhyperplanes}.&lt;/p&gt;
     * &lt;p&gt;If the list is empty, the region will represent the whole
     * space.&lt;/p&gt;
     * &lt;p&gt;
     * Polygons with thin pikes or dents are inherently difficult to handle because
     * they involve lines with almost opposite directions at some vertices. Polygons
     * whose vertices come from some physical measurement with noise are also
     * difficult because an edge that should be straight may be broken in lots of
     * different pieces with almost equal directions. In both cases, computing the
     * lines intersections is not numerically robust due to the almost 0 or almost
     * &amp;pi; angle. Such cases need to carefully adjust the {@code hyperplaneThickness}
     * parameter. A too small value would often lead to completely wrong polygons
     * with large area wrongly identified as inside or outside. Large values are
     * often much safer. As a rule of thumb, a value slightly below the size of the
     * most accurate detail needed is a good value for the {@code hyperplaneThickness}
     * parameter.
     * &lt;/p&gt;
     * @param hyperplaneThickness tolerance below which points are considered to
     * belong to the hyperplane (which is therefore more a slab)
     * @param vertices vertices of the simple loop boundary
     */
    public PolygonsSet(final double hyperplaneThickness, final Vector2D ... vertices) {
<span class="fc" id="L156">        super(verticesToTree(hyperplaneThickness, vertices), hyperplaneThickness);</span>
<span class="fc" id="L157">    }</span>

    /** Build a polygons set representing the whole real line.
     * @deprecated as of 3.3, replaced with {@link #PolygonsSet(double)}
     */
    @Deprecated
    public PolygonsSet() {
<span class="nc" id="L164">        this(DEFAULT_TOLERANCE);</span>
<span class="nc" id="L165">    }</span>

    /** Build a polygons set from a BSP tree.
     * &lt;p&gt;The leaf nodes of the BSP tree &lt;em&gt;must&lt;/em&gt; have a
     * {@code Boolean} attribute representing the inside status of
     * the corresponding cell (true for inside cells, false for outside
     * cells). In order to avoid building too many small objects, it is
     * recommended to use the predefined constants
     * {@code Boolean.TRUE} and {@code Boolean.FALSE}&lt;/p&gt;
     * @param tree inside/outside BSP tree representing the region
     * @deprecated as of 3.3, replaced with {@link #PolygonsSet(BSPTree, double)}
     */
    @Deprecated
    public PolygonsSet(final BSPTree&lt;Euclidean2D&gt; tree) {
<span class="nc" id="L179">        this(tree, DEFAULT_TOLERANCE);</span>
<span class="nc" id="L180">    }</span>

    /** Build a polygons set from a Boundary REPresentation (B-rep).
     * &lt;p&gt;The boundary is provided as a collection of {@link
     * SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the
     * interior part of the region on its minus side and the exterior on
     * its plus side.&lt;/p&gt;
     * &lt;p&gt;The boundary elements can be in any order, and can form
     * several non-connected sets (like for example polygons with holes
     * or a set of disjoint polygons considered as a whole). In
     * fact, the elements do not even need to be connected together
     * (their topological connections are not used here). However, if the
     * boundary does not really separate an inside open from an outside
     * open (open having here its topological meaning), then subsequent
     * calls to the {@link
     * org.apache.commons.math3.geometry.partitioning.Region#checkPoint(org.apache.commons.math3.geometry.Point)
     * checkPoint} method will not be meaningful anymore.&lt;/p&gt;
     * &lt;p&gt;If the boundary is empty, the region will represent the whole
     * space.&lt;/p&gt;
     * @param boundary collection of boundary elements, as a
     * collection of {@link SubHyperplane SubHyperplane} objects
     * @deprecated as of 3.3, replaced with {@link #PolygonsSet(Collection, double)}
     */
    @Deprecated
    public PolygonsSet(final Collection&lt;SubHyperplane&lt;Euclidean2D&gt;&gt; boundary) {
<span class="nc" id="L205">        this(boundary, DEFAULT_TOLERANCE);</span>
<span class="nc" id="L206">    }</span>

    /** Build a parallellepipedic box.
     * @param xMin low bound along the x direction
     * @param xMax high bound along the x direction
     * @param yMin low bound along the y direction
     * @param yMax high bound along the y direction
     * @deprecated as of 3.3, replaced with {@link #PolygonsSet(double, double, double, double, double)}
     */
    @Deprecated
    public PolygonsSet(final double xMin, final double xMax,
                       final double yMin, final double yMax) {
<span class="nc" id="L218">        this(xMin, xMax, yMin, yMax, DEFAULT_TOLERANCE);</span>
<span class="nc" id="L219">    }</span>

    /** Create a list of hyperplanes representing the boundary of a box.
     * @param xMin low bound along the x direction
     * @param xMax high bound along the x direction
     * @param yMin low bound along the y direction
     * @param yMax high bound along the y direction
     * @param tolerance tolerance below which points are considered identical
     * @return boundary of the box
     */
    private static Line[] boxBoundary(final double xMin, final double xMax,
                                      final double yMin, final double yMax,
                                      final double tolerance) {
<span class="pc bpc" id="L232" title="1 of 4 branches missed.">        if ((xMin &gt;= xMax - tolerance) || (yMin &gt;= yMax - tolerance)) {</span>
            // too thin box, build an empty polygons set
<span class="fc" id="L234">            return null;</span>
        }
<span class="fc" id="L236">        final Vector2D minMin = new Vector2D(xMin, yMin);</span>
<span class="fc" id="L237">        final Vector2D minMax = new Vector2D(xMin, yMax);</span>
<span class="fc" id="L238">        final Vector2D maxMin = new Vector2D(xMax, yMin);</span>
<span class="fc" id="L239">        final Vector2D maxMax = new Vector2D(xMax, yMax);</span>
<span class="fc" id="L240">        return new Line[] {</span>
            new Line(minMin, maxMin, tolerance),
            new Line(maxMin, maxMax, tolerance),
            new Line(maxMax, minMax, tolerance),
            new Line(minMax, minMin, tolerance)
        };
    }

    /** Build the BSP tree of a polygons set from a simple list of vertices.
     * &lt;p&gt;The boundary is provided as a list of points considering to
     * represent the vertices of a simple loop. The interior part of the
     * region is on the left side of this path and the exterior is on its
     * right side.&lt;/p&gt;
     * &lt;p&gt;This constructor does not handle polygons with a boundary
     * forming several disconnected paths (such as polygons with holes).&lt;/p&gt;
     * &lt;p&gt;For cases where this simple constructor applies, it is expected to
     * be numerically more robust than the {@link #PolygonsSet(Collection) general
     * constructor} using {@link SubHyperplane subhyperplanes}.&lt;/p&gt;
     * @param hyperplaneThickness tolerance below which points are consider to
     * belong to the hyperplane (which is therefore more a slab)
     * @param vertices vertices of the simple loop boundary
     * @return the BSP tree of the input vertices
     */
    private static BSPTree&lt;Euclidean2D&gt; verticesToTree(final double hyperplaneThickness,
                                                       final Vector2D ... vertices) {

<span class="fc" id="L266">        final int n = vertices.length;</span>
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">        if (n == 0) {</span>
            // the tree represents the whole space
<span class="nc" id="L269">            return new BSPTree&lt;Euclidean2D&gt;(Boolean.TRUE);</span>
        }

        // build the vertices
<span class="fc" id="L273">        final Vertex[] vArray = new Vertex[n];</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L275">            vArray[i] = new Vertex(vertices[i]);</span>
        }

        // build the edges
<span class="fc" id="L279">        List&lt;Edge&gt; edges = new ArrayList&lt;Edge&gt;(n);</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>

            // get the endpoints of the edge
<span class="fc" id="L283">            final Vertex start = vArray[i];</span>
<span class="fc" id="L284">            final Vertex end   = vArray[(i + 1) % n];</span>

            // get the line supporting the edge, taking care not to recreate it
            // if it was already created earlier due to another edge being aligned
            // with the current one
<span class="fc" id="L289">            Line line = start.sharedLineWith(end);</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">            if (line == null) {</span>
<span class="fc" id="L291">                line = new Line(start.getLocation(), end.getLocation(), hyperplaneThickness);</span>
            }

            // create the edge and store it
<span class="fc" id="L295">            edges.add(new Edge(start, end, line));</span>

            // check if another vertex also happens to be on this line
<span class="fc bfc" id="L298" title="All 2 branches covered.">            for (final Vertex vertex : vArray) {</span>
<span class="fc bfc" id="L299" title="All 4 branches covered.">                if (vertex != start &amp;&amp; vertex != end &amp;&amp;</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">                    FastMath.abs(line.getOffset((Point&lt;Euclidean2D&gt;) vertex.getLocation())) &lt;= hyperplaneThickness) {</span>
<span class="fc" id="L301">                    vertex.bindWith(line);</span>
                }
            }

        }

        // build the tree top-down
<span class="fc" id="L308">        final BSPTree&lt;Euclidean2D&gt; tree = new BSPTree&lt;Euclidean2D&gt;();</span>
<span class="fc" id="L309">        insertEdges(hyperplaneThickness, tree, edges);</span>

<span class="fc" id="L311">        return tree;</span>

    }

    /** Recursively build a tree by inserting cut sub-hyperplanes.
     * @param hyperplaneThickness tolerance below which points are consider to
     * belong to the hyperplane (which is therefore more a slab)
     * @param node current tree node (it is a leaf node at the beginning
     * of the call)
     * @param edges list of edges to insert in the cell defined by this node
     * (excluding edges not belonging to the cell defined by this node)
     */
    private static void insertEdges(final double hyperplaneThickness,
                                    final BSPTree&lt;Euclidean2D&gt; node,
                                    final List&lt;Edge&gt; edges) {

        // find an edge with an hyperplane that can be inserted in the node
<span class="fc" id="L328">        int index = 0;</span>
<span class="fc" id="L329">        Edge inserted =null;</span>
<span class="fc bfc" id="L330" title="All 4 branches covered.">        while (inserted == null &amp;&amp; index &lt; edges.size()) {</span>
<span class="fc" id="L331">            inserted = edges.get(index++);</span>
<span class="pc bpc" id="L332" title="1 of 2 branches missed.">            if (inserted.getNode() == null) {</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">                if (node.insertCut(inserted.getLine())) {</span>
<span class="fc" id="L334">                    inserted.setNode(node);</span>
                } else {
<span class="fc" id="L336">                    inserted = null;</span>
                }
            } else {
<span class="nc" id="L339">                inserted = null;</span>
            }
        }

<span class="fc bfc" id="L343" title="All 2 branches covered.">        if (inserted == null) {</span>
            // no suitable edge was found, the node remains a leaf node
            // we need to set its inside/outside boolean indicator
<span class="fc" id="L346">            final BSPTree&lt;Euclidean2D&gt; parent = node.getParent();</span>
<span class="pc bpc" id="L347" title="2 of 4 branches missed.">            if (parent == null || node == parent.getMinus()) {</span>
<span class="fc" id="L348">                node.setAttribute(Boolean.TRUE);</span>
            } else {
<span class="nc" id="L350">                node.setAttribute(Boolean.FALSE);</span>
            }
<span class="fc" id="L352">            return;</span>
        }

        // we have split the node by inserting an edge as a cut sub-hyperplane
        // distribute the remaining edges in the two sub-trees
<span class="fc" id="L357">        final List&lt;Edge&gt; plusList  = new ArrayList&lt;Edge&gt;();</span>
<span class="fc" id="L358">        final List&lt;Edge&gt; minusList = new ArrayList&lt;Edge&gt;();</span>
<span class="fc bfc" id="L359" title="All 2 branches covered.">        for (final Edge edge : edges) {</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">            if (edge != inserted) {</span>
<span class="fc" id="L361">                final double startOffset = inserted.getLine().getOffset((Point&lt;Euclidean2D&gt;) edge.getStart().getLocation());</span>
<span class="fc" id="L362">                final double endOffset   = inserted.getLine().getOffset((Point&lt;Euclidean2D&gt;) edge.getEnd().getLocation());</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">                Side startSide = (FastMath.abs(startOffset) &lt;= hyperplaneThickness) ?</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">                                 Side.HYPER : ((startOffset &lt; 0) ? Side.MINUS : Side.PLUS);</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">                Side endSide   = (FastMath.abs(endOffset) &lt;= hyperplaneThickness) ?</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">                                 Side.HYPER : ((endOffset &lt; 0) ? Side.MINUS : Side.PLUS);</span>
<span class="fc bfc" id="L367" title="All 3 branches covered.">                switch (startSide) {</span>
                    case PLUS:
<span class="fc bfc" id="L369" title="All 2 branches covered.">                        if (endSide == Side.MINUS) {</span>
                            // we need to insert a split point on the hyperplane
<span class="fc" id="L371">                            final Vertex splitPoint = edge.split(inserted.getLine());</span>
<span class="fc" id="L372">                            minusList.add(splitPoint.getOutgoing());</span>
<span class="fc" id="L373">                            plusList.add(splitPoint.getIncoming());</span>
<span class="fc" id="L374">                        } else {</span>
<span class="fc" id="L375">                            plusList.add(edge);</span>
                        }
<span class="fc" id="L377">                        break;</span>
                    case MINUS:
<span class="fc bfc" id="L379" title="All 2 branches covered.">                        if (endSide == Side.PLUS) {</span>
                            // we need to insert a split point on the hyperplane
<span class="fc" id="L381">                            final Vertex splitPoint = edge.split(inserted.getLine());</span>
<span class="fc" id="L382">                            minusList.add(splitPoint.getIncoming());</span>
<span class="fc" id="L383">                            plusList.add(splitPoint.getOutgoing());</span>
<span class="fc" id="L384">                        } else {</span>
<span class="fc" id="L385">                            minusList.add(edge);</span>
                        }
<span class="fc" id="L387">                        break;</span>
                    default:
<span class="fc bfc" id="L389" title="All 2 branches covered.">                        if (endSide == Side.PLUS) {</span>
<span class="fc" id="L390">                            plusList.add(edge);</span>
<span class="fc bfc" id="L391" title="All 2 branches covered.">                        } else if (endSide == Side.MINUS) {</span>
<span class="fc" id="L392">                            minusList.add(edge);</span>
                        }
                        break;
                }
            }
<span class="fc" id="L397">        }</span>

        // recurse through lower levels
<span class="fc bfc" id="L400" title="All 2 branches covered.">        if (!plusList.isEmpty()) {</span>
<span class="fc" id="L401">            insertEdges(hyperplaneThickness, node.getPlus(),  plusList);</span>
        } else {
<span class="fc" id="L403">            node.getPlus().setAttribute(Boolean.FALSE);</span>
        }
<span class="fc bfc" id="L405" title="All 2 branches covered.">        if (!minusList.isEmpty()) {</span>
<span class="fc" id="L406">            insertEdges(hyperplaneThickness, node.getMinus(), minusList);</span>
        } else {
<span class="fc" id="L408">            node.getMinus().setAttribute(Boolean.TRUE);</span>
        }

<span class="fc" id="L411">    }</span>

    /** Internal class for holding vertices while they are processed to build a BSP tree. */
    private static class Vertex {

        /** Vertex location. */
        private final Vector2D location;

        /** Incoming edge. */
        private Edge incoming;

        /** Outgoing edge. */
        private Edge outgoing;

        /** Lines bound with this vertex. */
        private final List&lt;Line&gt; lines;

        /** Build a non-processed vertex not owned by any node yet.
         * @param location vertex location
         */
<span class="fc" id="L431">        public Vertex(final Vector2D location) {</span>
<span class="fc" id="L432">            this.location = location;</span>
<span class="fc" id="L433">            this.incoming = null;</span>
<span class="fc" id="L434">            this.outgoing = null;</span>
<span class="fc" id="L435">            this.lines    = new ArrayList&lt;Line&gt;();</span>
<span class="fc" id="L436">        }</span>

        /** Get Vertex location.
         * @return vertex location
         */
        public Vector2D getLocation() {
<span class="fc" id="L442">            return location;</span>
        }

        /** Bind a line considered to contain this vertex.
         * @param line line to bind with this vertex
         */
        public void bindWith(final Line line) {
<span class="fc" id="L449">            lines.add(line);</span>
<span class="fc" id="L450">        }</span>

        /** Get the common line bound with both the instance and another vertex, if any.
         * &lt;p&gt;
         * When two vertices are both bound to the same line, this means they are
         * already handled by node associated with this line, so there is no need
         * to create a cut hyperplane for them.
         * &lt;/p&gt;
         * @param vertex other vertex to check instance against
         * @return line bound with both the instance and another vertex, or null if the
         * two vertices do not share a line yet
         */
        public Line sharedLineWith(final Vertex vertex) {
<span class="fc bfc" id="L463" title="All 2 branches covered.">            for (final Line line1 : lines) {</span>
<span class="fc bfc" id="L464" title="All 2 branches covered.">                for (final Line line2 : vertex.lines) {</span>
<span class="fc bfc" id="L465" title="All 2 branches covered.">                    if (line1 == line2) {</span>
<span class="fc" id="L466">                        return line1;</span>
                    }
<span class="fc" id="L468">                }</span>
<span class="fc" id="L469">            }</span>
<span class="fc" id="L470">            return null;</span>
        }

        /** Set incoming edge.
         * &lt;p&gt;
         * The line supporting the incoming edge is automatically bound
         * with the instance.
         * &lt;/p&gt;
         * @param incoming incoming edge
         */
        public void setIncoming(final Edge incoming) {
<span class="fc" id="L481">            this.incoming = incoming;</span>
<span class="fc" id="L482">            bindWith(incoming.getLine());</span>
<span class="fc" id="L483">        }</span>

        /** Get incoming edge.
         * @return incoming edge
         */
        public Edge getIncoming() {
<span class="fc" id="L489">            return incoming;</span>
        }

        /** Set outgoing edge.
         * &lt;p&gt;
         * The line supporting the outgoing edge is automatically bound
         * with the instance.
         * &lt;/p&gt;
         * @param outgoing outgoing edge
         */
        public void setOutgoing(final Edge outgoing) {
<span class="fc" id="L500">            this.outgoing = outgoing;</span>
<span class="fc" id="L501">            bindWith(outgoing.getLine());</span>
<span class="fc" id="L502">        }</span>

        /** Get outgoing edge.
         * @return outgoing edge
         */
        public Edge getOutgoing() {
<span class="fc" id="L508">            return outgoing;</span>
        }

    }

    /** Internal class for holding edges while they are processed to build a BSP tree. */
    private static class Edge {

        /** Start vertex. */
        private final Vertex start;

        /** End vertex. */
        private final Vertex end;

        /** Line supporting the edge. */
        private final Line line;

        /** Node whose cut hyperplane contains this edge. */
        private BSPTree&lt;Euclidean2D&gt; node;

        /** Build an edge not contained in any node yet.
         * @param start start vertex
         * @param end end vertex
         * @param line line supporting the edge
         */
<span class="fc" id="L533">        public Edge(final Vertex start, final Vertex end, final Line line) {</span>

<span class="fc" id="L535">            this.start = start;</span>
<span class="fc" id="L536">            this.end   = end;</span>
<span class="fc" id="L537">            this.line  = line;</span>
<span class="fc" id="L538">            this.node  = null;</span>

            // connect the vertices back to the edge
<span class="fc" id="L541">            start.setOutgoing(this);</span>
<span class="fc" id="L542">            end.setIncoming(this);</span>

<span class="fc" id="L544">        }</span>

        /** Get start vertex.
         * @return start vertex
         */
        public Vertex getStart() {
<span class="fc" id="L550">            return start;</span>
        }

        /** Get end vertex.
         * @return end vertex
         */
        public Vertex getEnd() {
<span class="fc" id="L557">            return end;</span>
        }

        /** Get the line supporting this edge.
         * @return line supporting this edge
         */
        public Line getLine() {
<span class="fc" id="L564">            return line;</span>
        }

        /** Set the node whose cut hyperplane contains this edge.
         * @param node node whose cut hyperplane contains this edge
         */
        public void setNode(final BSPTree&lt;Euclidean2D&gt; node) {
<span class="fc" id="L571">            this.node = node;</span>
<span class="fc" id="L572">        }</span>

        /** Get the node whose cut hyperplane contains this edge.
         * @return node whose cut hyperplane contains this edge
         * (null if edge has not yet been inserted into the BSP tree)
         */
        public BSPTree&lt;Euclidean2D&gt; getNode() {
<span class="fc" id="L579">            return node;</span>
        }

        /** Split the edge.
         * &lt;p&gt;
         * Once split, this edge is not referenced anymore by the vertices,
         * it is replaced by the two half-edges and an intermediate splitting
         * vertex is introduced to connect these two halves.
         * &lt;/p&gt;
         * @param splitLine line splitting the edge in two halves
         * @return split vertex (its incoming and outgoing edges are the two halves)
         */
        public Vertex split(final Line splitLine) {
<span class="fc" id="L592">            final Vertex splitVertex = new Vertex(line.intersection(splitLine));</span>
<span class="fc" id="L593">            splitVertex.bindWith(splitLine);</span>
<span class="fc" id="L594">            final Edge startHalf = new Edge(start, splitVertex, line);</span>
<span class="fc" id="L595">            final Edge endHalf   = new Edge(splitVertex, end, line);</span>
<span class="fc" id="L596">            startHalf.node = node;</span>
<span class="fc" id="L597">            endHalf.node   = node;</span>
<span class="fc" id="L598">            return splitVertex;</span>
        }

    }

    /** {@inheritDoc} */
    @Override
    public PolygonsSet buildNew(final BSPTree&lt;Euclidean2D&gt; tree) {
<span class="fc" id="L606">        return new PolygonsSet(tree, getTolerance());</span>
    }

    /** {@inheritDoc} */
    @Override
    protected void computeGeometricalProperties() {

<span class="fc" id="L613">        final Vector2D[][] v = getVertices();</span>

<span class="fc bfc" id="L615" title="All 2 branches covered.">        if (v.length == 0) {</span>
<span class="fc" id="L616">            final BSPTree&lt;Euclidean2D&gt; tree = getTree(false);</span>
<span class="fc bfc" id="L617" title="All 4 branches covered.">            if (tree.getCut() == null &amp;&amp; (Boolean) tree.getAttribute()) {</span>
                // the instance covers the whole space
<span class="fc" id="L619">                setSize(Double.POSITIVE_INFINITY);</span>
<span class="fc" id="L620">                setBarycenter((Point&lt;Euclidean2D&gt;) Vector2D.NaN);</span>
            } else {
<span class="fc" id="L622">                setSize(0);</span>
<span class="fc" id="L623">                setBarycenter((Point&lt;Euclidean2D&gt;) new Vector2D(0, 0));</span>
            }
<span class="pc bpc" id="L625" title="1 of 2 branches missed.">        } else if (v[0][0] == null) {</span>
            // there is at least one open-loop: the polygon is infinite
<span class="nc" id="L627">            setSize(Double.POSITIVE_INFINITY);</span>
<span class="nc" id="L628">            setBarycenter((Point&lt;Euclidean2D&gt;) Vector2D.NaN);</span>
        } else {
            // all loops are closed, we compute some integrals around the shape

<span class="fc" id="L632">            double sum  = 0;</span>
<span class="fc" id="L633">            double sumX = 0;</span>
<span class="fc" id="L634">            double sumY = 0;</span>

<span class="fc bfc" id="L636" title="All 2 branches covered.">            for (Vector2D[] loop : v) {</span>
<span class="fc" id="L637">                double x1 = loop[loop.length - 1].getX();</span>
<span class="fc" id="L638">                double y1 = loop[loop.length - 1].getY();</span>
<span class="fc bfc" id="L639" title="All 2 branches covered.">                for (final Vector2D point : loop) {</span>
<span class="fc" id="L640">                    final double x0 = x1;</span>
<span class="fc" id="L641">                    final double y0 = y1;</span>
<span class="fc" id="L642">                    x1 = point.getX();</span>
<span class="fc" id="L643">                    y1 = point.getY();</span>
<span class="fc" id="L644">                    final double factor = x0 * y1 - y0 * x1;</span>
<span class="fc" id="L645">                    sum  += factor;</span>
<span class="fc" id="L646">                    sumX += factor * (x0 + x1);</span>
<span class="fc" id="L647">                    sumY += factor * (y0 + y1);</span>
                }
            }

<span class="pc bpc" id="L651" title="1 of 2 branches missed.">            if (sum &lt; 0) {</span>
                // the polygon as a finite outside surrounded by an infinite inside
<span class="nc" id="L653">                setSize(Double.POSITIVE_INFINITY);</span>
<span class="nc" id="L654">                setBarycenter((Point&lt;Euclidean2D&gt;) Vector2D.NaN);</span>
            } else {
<span class="fc" id="L656">                setSize(sum / 2);</span>
<span class="fc" id="L657">                setBarycenter((Point&lt;Euclidean2D&gt;) new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));</span>
            }

        }

<span class="fc" id="L662">    }</span>

    /** Get the vertices of the polygon.
     * &lt;p&gt;The polygon boundary can be represented as an array of loops,
     * each loop being itself an array of vertices.&lt;/p&gt;
     * &lt;p&gt;In order to identify open loops which start and end by
     * infinite edges, the open loops arrays start with a null point. In
     * this case, the first non null point and the last point of the
     * array do not represent real vertices, they are dummy points
     * intended only to get the direction of the first and last edge. An
     * open loop consisting of a single infinite line will therefore be
     * represented by a three elements array with one null point
     * followed by two dummy points. The open loops are always the first
     * ones in the loops array.&lt;/p&gt;
     * &lt;p&gt;If the polygon has no boundary at all, a zero length loop
     * array will be returned.&lt;/p&gt;
     * &lt;p&gt;All line segments in the various loops have the inside of the
     * region on their left side and the outside on their right side
     * when moving in the underlying line direction. This means that
     * closed loops surrounding finite areas obey the direct
     * trigonometric orientation.&lt;/p&gt;
     * @return vertices of the polygon, organized as oriented boundary
     * loops with the open loops first (the returned value is guaranteed
     * to be non-null)
     */
    public Vector2D[][] getVertices() {
<span class="fc bfc" id="L688" title="All 2 branches covered.">        if (vertices == null) {</span>
<span class="fc bfc" id="L689" title="All 2 branches covered.">            if (getTree(false).getCut() == null) {</span>
<span class="fc" id="L690">                vertices = new Vector2D[0][];</span>
            } else {

                // sort the segments according to their start point
<span class="fc" id="L694">                final SegmentsBuilder visitor = new SegmentsBuilder();</span>
<span class="fc" id="L695">                getTree(true).visit(visitor);</span>
<span class="fc" id="L696">                final AVLTree&lt;ComparableSegment&gt; sorted = visitor.getSorted();</span>

                // identify the loops, starting from the open ones
                // (their start segments are naturally at the sorted set beginning)
<span class="fc" id="L700">                final ArrayList&lt;List&lt;ComparableSegment&gt;&gt; loops = new ArrayList&lt;List&lt;ComparableSegment&gt;&gt;();</span>
<span class="fc bfc" id="L701" title="All 2 branches covered.">                while (!sorted.isEmpty()) {</span>
<span class="fc" id="L702">                    final AVLTree&lt;ComparableSegment&gt;.Node node = sorted.getSmallest();</span>
<span class="fc" id="L703">                    final List&lt;ComparableSegment&gt; loop = followLoop(node, sorted);</span>
<span class="fc bfc" id="L704" title="All 2 branches covered.">                    if (loop != null) {</span>
<span class="fc" id="L705">                        loops.add(loop);</span>
                    }
<span class="fc" id="L707">                }</span>

                // transform the loops in an array of arrays of points
<span class="fc" id="L710">                vertices = new Vector2D[loops.size()][];</span>
<span class="fc" id="L711">                int i = 0;</span>

<span class="fc bfc" id="L713" title="All 2 branches covered.">                for (final List&lt;ComparableSegment&gt; loop : loops) {</span>
<span class="pc bpc" id="L714" title="1 of 2 branches missed.">                    if (loop.size() &lt; 2) {</span>
                        // single infinite line
<span class="nc" id="L716">                        final Line line = loop.get(0).getLine();</span>
<span class="nc" id="L717">                        vertices[i++] = new Vector2D[] {</span>
                            null,
<span class="nc" id="L719">                            line.toSpace((Point&lt;Euclidean1D&gt;) new Vector1D(-Float.MAX_VALUE)),</span>
<span class="nc" id="L720">                            line.toSpace((Point&lt;Euclidean1D&gt;) new Vector1D(+Float.MAX_VALUE))</span>
                        };
<span class="pc bpc" id="L722" title="1 of 2 branches missed.">                    } else if (loop.get(0).getStart() == null) {</span>
                        // open loop with at least one real point
<span class="nc" id="L724">                        final Vector2D[] array = new Vector2D[loop.size() + 2];</span>
<span class="nc" id="L725">                        int j = 0;</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">                        for (Segment segment : loop) {</span>

<span class="nc bnc" id="L728" title="All 2 branches missed.">                            if (j == 0) {</span>
                                // null point and first dummy point
<span class="nc" id="L730">                                double x = segment.getLine().toSubSpace((Point&lt;Euclidean2D&gt;) segment.getEnd()).getX();</span>
<span class="nc" id="L731">                                x -= FastMath.max(1.0, FastMath.abs(x / 2));</span>
<span class="nc" id="L732">                                array[j++] = null;</span>
<span class="nc" id="L733">                                array[j++] = segment.getLine().toSpace((Point&lt;Euclidean1D&gt;) new Vector1D(x));</span>
                            }

<span class="nc bnc" id="L736" title="All 2 branches missed.">                            if (j &lt; (array.length - 1)) {</span>
                                // current point
<span class="nc" id="L738">                                array[j++] = segment.getEnd();</span>
                            }

<span class="nc bnc" id="L741" title="All 2 branches missed.">                            if (j == (array.length - 1)) {</span>
                                // last dummy point
<span class="nc" id="L743">                                double x = segment.getLine().toSubSpace((Point&lt;Euclidean2D&gt;) segment.getStart()).getX();</span>
<span class="nc" id="L744">                                x += FastMath.max(1.0, FastMath.abs(x / 2));</span>
<span class="nc" id="L745">                                array[j++] = segment.getLine().toSpace((Point&lt;Euclidean1D&gt;) new Vector1D(x));</span>
                            }

<span class="nc" id="L748">                        }</span>
<span class="nc" id="L749">                        vertices[i++] = array;</span>
<span class="nc" id="L750">                    } else {</span>
<span class="fc" id="L751">                        final Vector2D[] array = new Vector2D[loop.size()];</span>
<span class="fc" id="L752">                        int j = 0;</span>
<span class="fc bfc" id="L753" title="All 2 branches covered.">                        for (Segment segment : loop) {</span>
<span class="fc" id="L754">                            array[j++] = segment.getStart();</span>
<span class="fc" id="L755">                        }</span>
<span class="fc" id="L756">                        vertices[i++] = array;</span>
                    }
<span class="fc" id="L758">                }</span>

            }
        }

<span class="fc" id="L763">        return vertices.clone();</span>

    }

    /** Follow a boundary loop.
     * @param node node containing the segment starting the loop
     * @param sorted set of segments belonging to the boundary, sorted by
     * start points (contains {@code node})
     * @return a list of connected sub-hyperplanes starting at
     * {@code node}
     */
    private List&lt;ComparableSegment&gt; followLoop(final AVLTree&lt;ComparableSegment&gt;.Node node,
                                               final AVLTree&lt;ComparableSegment&gt; sorted) {

<span class="fc" id="L777">        final ArrayList&lt;ComparableSegment&gt; loop = new ArrayList&lt;ComparableSegment&gt;();</span>
<span class="fc" id="L778">        ComparableSegment segment = node.getElement();</span>
<span class="fc" id="L779">        loop.add(segment);</span>
<span class="fc" id="L780">        final Vector2D globalStart = segment.getStart();</span>
<span class="fc" id="L781">        Vector2D end = segment.getEnd();</span>
<span class="fc" id="L782">        node.delete();</span>

        // is this an open or a closed loop ?
<span class="pc bpc" id="L785" title="1 of 2 branches missed.">        final boolean open = segment.getStart() == null;</span>

<span class="pc bpc" id="L787" title="2 of 6 branches missed.">        while ((end != null) &amp;&amp; (open || (globalStart.distance((Point&lt;Euclidean2D&gt;) end) &gt; 1.0e-10))) {</span>

            // search the sub-hyperplane starting where the previous one ended
<span class="fc" id="L790">            AVLTree&lt;ComparableSegment&gt;.Node selectedNode = null;</span>
<span class="fc" id="L791">            ComparableSegment       selectedSegment  = null;</span>
<span class="fc" id="L792">            double                  selectedDistance = Double.POSITIVE_INFINITY;</span>
<span class="fc" id="L793">            final ComparableSegment lowerLeft        = new ComparableSegment(end, -1.0e-10, -1.0e-10);</span>
<span class="fc" id="L794">            final ComparableSegment upperRight       = new ComparableSegment(end, +1.0e-10, +1.0e-10);</span>
<span class="fc" id="L795">            for (AVLTree&lt;ComparableSegment&gt;.Node n = sorted.getNotSmaller(lowerLeft);</span>
<span class="fc bfc" id="L796" title="All 4 branches covered.">                 (n != null) &amp;&amp; (n.getElement().compareTo(upperRight) &lt;= 0);</span>
<span class="fc" id="L797">                 n = n.getNext()) {</span>
<span class="fc" id="L798">                segment = n.getElement();</span>
<span class="fc" id="L799">                final double distance = end.distance((Point&lt;Euclidean2D&gt;) segment.getStart());</span>
<span class="fc bfc" id="L800" title="All 2 branches covered.">                if (distance &lt; selectedDistance) {</span>
<span class="fc" id="L801">                    selectedNode     = n;</span>
<span class="fc" id="L802">                    selectedSegment  = segment;</span>
<span class="fc" id="L803">                    selectedDistance = distance;</span>
                }
            }

<span class="fc bfc" id="L807" title="All 2 branches covered.">            if (selectedDistance &gt; 1.0e-10) {</span>
                // this is a degenerated loop, it probably comes from a very
                // tiny region with some segments smaller than the threshold, we
                // simply ignore it
<span class="fc" id="L811">                return null;</span>
            }

<span class="fc" id="L814">            end = selectedSegment.getEnd();</span>
<span class="fc" id="L815">            loop.add(selectedSegment);</span>
<span class="fc" id="L816">            selectedNode.delete();</span>

<span class="fc" id="L818">        }</span>

<span class="pc bpc" id="L820" title="1 of 4 branches missed.">        if ((loop.size() == 2) &amp;&amp; !open) {</span>
            // this is a degenerated infinitely thin loop, we simply ignore it
<span class="fc" id="L822">            return null;</span>
        }

<span class="pc bpc" id="L825" title="3 of 4 branches missed.">        if ((end == null) &amp;&amp; !open) {</span>
<span class="nc" id="L826">            throw new MathInternalError();</span>
        }

<span class="fc" id="L829">        return loop;</span>

    }

    /** Private extension of Segment allowing comparison. */
    private static class ComparableSegment extends Segment implements Comparable&lt;ComparableSegment&gt; {

        /** Sorting key. */
        private OrderedTuple sortingKey;

        /** Build a segment.
         * @param start start point of the segment
         * @param end end point of the segment
         * @param line line containing the segment
         */
        public ComparableSegment(final Vector2D start, final Vector2D end, final Line line) {
<span class="fc" id="L845">            super(start, end, line);</span>
<span class="pc bpc" id="L846" title="1 of 2 branches missed.">            sortingKey = (start == null) ?</span>
<span class="nc" id="L847">                         new OrderedTuple(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY) :</span>
<span class="fc" id="L848">                         new OrderedTuple(start.getX(), start.getY());</span>
<span class="fc" id="L849">        }</span>

        /** Build a dummy segment.
         * &lt;p&gt;
         * The object built is not a real segment, only the sorting key is used to
         * allow searching in the neighborhood of a point. This is an horrible hack ...
         * &lt;/p&gt;
         * @param start start point of the segment
         * @param dx abscissa offset from the start point
         * @param dy ordinate offset from the start point
         */
        public ComparableSegment(final Vector2D start, final double dx, final double dy) {
<span class="fc" id="L861">            super(null, null, null);</span>
<span class="fc" id="L862">            sortingKey = new OrderedTuple(start.getX() + dx, start.getY() + dy);</span>
<span class="fc" id="L863">        }</span>

        /** {@inheritDoc} */
        public int compareTo(final ComparableSegment o) {
<span class="fc" id="L867">            return sortingKey.compareTo(o.sortingKey);</span>
        }

        /** {@inheritDoc} */
        @Override
        public boolean equals(final Object other) {
<span class="nc bnc" id="L873" title="All 2 branches missed.">            if (this == other) {</span>
<span class="nc" id="L874">                return true;</span>
<span class="nc bnc" id="L875" title="All 2 branches missed.">            } else if (other instanceof ComparableSegment) {</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">                return compareTo((ComparableSegment) other) == 0;</span>
            } else {
<span class="nc" id="L878">                return false;</span>
            }
        }

        /** {@inheritDoc} */
        @Override
        public int hashCode() {
<span class="nc" id="L885">            return getStart().hashCode() ^ getEnd().hashCode() ^</span>
<span class="nc" id="L886">                   getLine().hashCode() ^ sortingKey.hashCode();</span>
        }

    }

    /** Visitor building segments. */
    private static class SegmentsBuilder implements BSPTreeVisitor&lt;Euclidean2D&gt; {

        /** Sorted segments. */
        private AVLTree&lt;ComparableSegment&gt; sorted;

        /** Simple constructor. */
<span class="fc" id="L898">        public SegmentsBuilder() {</span>
<span class="fc" id="L899">            sorted = new AVLTree&lt;ComparableSegment&gt;();</span>
<span class="fc" id="L900">        }</span>

        /** {@inheritDoc} */
        public Order visitOrder(final BSPTree&lt;Euclidean2D&gt; node) {
<span class="fc" id="L904">            return Order.MINUS_SUB_PLUS;</span>
        }

        /** {@inheritDoc} */
        public void visitInternalNode(final BSPTree&lt;Euclidean2D&gt; node) {
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L910">            final BoundaryAttribute&lt;Euclidean2D&gt; attribute = (BoundaryAttribute&lt;Euclidean2D&gt;) node.getAttribute();</span>
<span class="fc bfc" id="L911" title="All 2 branches covered.">            if (attribute.getPlusOutside() != null) {</span>
<span class="fc" id="L912">                addContribution(attribute.getPlusOutside(), false);</span>
            }
<span class="fc bfc" id="L914" title="All 2 branches covered.">            if (attribute.getPlusInside() != null) {</span>
<span class="fc" id="L915">                addContribution(attribute.getPlusInside(), true);</span>
            }
<span class="fc" id="L917">        }</span>

        /** {@inheritDoc} */
        public void visitLeafNode(final BSPTree&lt;Euclidean2D&gt; node) {
<span class="fc" id="L921">        }</span>

        /** Add the contribution of a boundary facet.
         * @param sub boundary facet
         * @param reversed if true, the facet has the inside on its plus side
         */
        private void addContribution(final SubHyperplane&lt;Euclidean2D&gt; sub, final boolean reversed) {
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L929">            final AbstractSubHyperplane&lt;Euclidean2D, Euclidean1D&gt; absSub =</span>
                (AbstractSubHyperplane&lt;Euclidean2D, Euclidean1D&gt;) sub;
<span class="fc" id="L931">            final Line line      = (Line) sub.getHyperplane();</span>
<span class="fc" id="L932">            final List&lt;Interval&gt; intervals = ((IntervalsSet) absSub.getRemainingRegion()).asList();</span>
<span class="fc bfc" id="L933" title="All 2 branches covered.">            for (final Interval i : intervals) {</span>
<span class="pc bpc" id="L934" title="1 of 2 branches missed.">                final Vector2D start = Double.isInfinite(i.getInf()) ?</span>
<span class="pc" id="L935">                                      null : (Vector2D) line.toSpace((Point&lt;Euclidean1D&gt;) new Vector1D(i.getInf()));</span>
<span class="pc bpc" id="L936" title="1 of 2 branches missed.">                final Vector2D end   = Double.isInfinite(i.getSup()) ?</span>
<span class="pc" id="L937">                                      null : (Vector2D) line.toSpace((Point&lt;Euclidean1D&gt;) new Vector1D(i.getSup()));</span>
<span class="fc bfc" id="L938" title="All 2 branches covered.">                if (reversed) {</span>
<span class="fc" id="L939">                    sorted.insert(new ComparableSegment(end, start, line.getReverse()));</span>
                } else {
<span class="fc" id="L941">                    sorted.insert(new ComparableSegment(start, end, line));</span>
                }
<span class="fc" id="L943">            }</span>
<span class="fc" id="L944">        }</span>

        /** Get the sorted segments.
         * @return sorted segments
         */
        public AVLTree&lt;ComparableSegment&gt; getSorted() {
<span class="fc" id="L950">            return sorted;</span>
        }

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>