<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BlockRealMatrix.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Commons Math</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math3.linear</a> &gt; <span class="el_source">BlockRealMatrix.java</span></div><h1>BlockRealMatrix.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.math3.linear;

import java.io.Serializable;
import java.util.Arrays;

import org.apache.commons.math3.exception.DimensionMismatchException;
import org.apache.commons.math3.exception.NoDataException;
import org.apache.commons.math3.exception.NotStrictlyPositiveException;
import org.apache.commons.math3.exception.NullArgumentException;
import org.apache.commons.math3.exception.NumberIsTooSmallException;
import org.apache.commons.math3.exception.OutOfRangeException;
import org.apache.commons.math3.exception.util.LocalizedFormats;
import org.apache.commons.math3.util.FastMath;
import org.apache.commons.math3.util.MathUtils;

/**
 * Cache-friendly implementation of RealMatrix using a flat arrays to store
 * square blocks of the matrix.
 * &lt;p&gt;
 * This implementation is specially designed to be cache-friendly. Square blocks are
 * stored as small arrays and allow efficient traversal of data both in row major direction
 * and columns major direction, one block at a time. This greatly increases performances
 * for algorithms that use crossed directions loops like multiplication or transposition.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The size of square blocks is a static parameter. It may be tuned according to the cache
 * size of the target computer processor. As a rule of thumbs, it should be the largest
 * value that allows three blocks to be simultaneously cached (this is necessary for example
 * for matrix multiplication). The default value is to use 52x52 blocks which is well suited
 * for processors with 64k L1 cache (one block holds 2704 values or 21632 bytes). This value
 * could be lowered to 36x36 for processors with 32k L1 cache.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The regular blocks represent {@link #BLOCK_SIZE} x {@link #BLOCK_SIZE} squares. Blocks
 * at right hand side and bottom side which may be smaller to fit matrix dimensions. The square
 * blocks are flattened in row major order in single dimension arrays which are therefore
 * {@link #BLOCK_SIZE}&lt;sup&gt;2&lt;/sup&gt; elements long for regular blocks. The blocks are themselves
 * organized in row major order.
 * &lt;/p&gt;
 * &lt;p&gt;
 * As an example, for a block size of 52x52, a 100x60 matrix would be stored in 4 blocks.
 * Block 0 would be a double[2704] array holding the upper left 52x52 square, block 1 would be
 * a double[416] array holding the upper right 52x8 rectangle, block 2 would be a double[2496]
 * array holding the lower left 48x52 rectangle and block 3 would be a double[384] array
 * holding the lower right 48x8 rectangle.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The layout complexity overhead versus simple mapping of matrices to java
 * arrays is negligible for small matrices (about 1%). The gain from cache efficiency leads
 * to up to 3-fold improvements for matrices of moderate to large size.
 * &lt;/p&gt;
 * @version $Id$
 * @since 2.0
 */
public class BlockRealMatrix extends AbstractRealMatrix implements Serializable {
    /** Block size. */
    public static final int BLOCK_SIZE = 52;
    /** Serializable version identifier */
    private static final long serialVersionUID = 4991895511313664478L;
    /** Blocks of matrix entries. */
    private final double blocks[][];
    /** Number of rows of the matrix. */
    private final int rows;
    /** Number of columns of the matrix. */
    private final int columns;
    /** Number of block rows of the matrix. */
    private final int blockRows;
    /** Number of block columns of the matrix. */
    private final int blockColumns;

    /**
     * Create a new matrix with the supplied row and column dimensions.
     *
     * @param rows  the number of rows in the new matrix
     * @param columns  the number of columns in the new matrix
     * @throws NotStrictlyPositiveException if row or column dimension is not
     * positive.
     */
    public BlockRealMatrix(final int rows, final int columns)
        throws NotStrictlyPositiveException {
<span class="fc" id="L98">        super(rows, columns);</span>
<span class="fc" id="L99">        this.rows = rows;</span>
<span class="fc" id="L100">        this.columns = columns;</span>

        // number of blocks
<span class="fc" id="L103">        blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;</span>
<span class="fc" id="L104">        blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;</span>

        // allocate storage blocks, taking care of smaller ones at right and bottom
<span class="fc" id="L107">        blocks = createBlocksLayout(rows, columns);</span>
<span class="fc" id="L108">    }</span>

    /**
     * Create a new dense matrix copying entries from raw layout data.
     * &lt;p&gt;The input array &lt;em&gt;must&lt;/em&gt; already be in raw layout.&lt;/p&gt;
     * &lt;p&gt;Calling this constructor is equivalent to call:
     * &lt;pre&gt;matrix = new BlockRealMatrix(rawData.length, rawData[0].length,
     *                                   toBlocksLayout(rawData), false);&lt;/pre&gt;
     * &lt;/p&gt;
     *
     * @param rawData data for new matrix, in raw layout
     * @throws DimensionMismatchException if the shape of {@code blockData} is
     * inconsistent with block layout.
     * @throws NotStrictlyPositiveException if row or column dimension is not
     * positive.
     * @see #BlockRealMatrix(int, int, double[][], boolean)
     */
    public BlockRealMatrix(final double[][] rawData)
        throws DimensionMismatchException, NotStrictlyPositiveException {
<span class="fc" id="L127">        this(rawData.length, rawData[0].length, toBlocksLayout(rawData), false);</span>
<span class="fc" id="L128">    }</span>

    /**
     * Create a new dense matrix copying entries from block layout data.
     * &lt;p&gt;The input array &lt;em&gt;must&lt;/em&gt; already be in blocks layout.&lt;/p&gt;
     *
     * @param rows Number of rows in the new matrix.
     * @param columns Number of columns in the new matrix.
     * @param blockData data for new matrix
     * @param copyArray Whether the input array will be copied or referenced.
     * @throws DimensionMismatchException if the shape of {@code blockData} is
     * inconsistent with block layout.
     * @throws NotStrictlyPositiveException if row or column dimension is not
     * positive.
     * @see #createBlocksLayout(int, int)
     * @see #toBlocksLayout(double[][])
     * @see #BlockRealMatrix(double[][])
     */
    public BlockRealMatrix(final int rows, final int columns,
                           final double[][] blockData, final boolean copyArray)
        throws DimensionMismatchException, NotStrictlyPositiveException {
<span class="fc" id="L149">        super(rows, columns);</span>
<span class="fc" id="L150">        this.rows = rows;</span>
<span class="fc" id="L151">        this.columns = columns;</span>

        // number of blocks
<span class="fc" id="L154">        blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;</span>
<span class="fc" id="L155">        blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;</span>

<span class="pc bpc" id="L157" title="1 of 2 branches missed.">        if (copyArray) {</span>
            // allocate storage blocks, taking care of smaller ones at right and bottom
<span class="nc" id="L159">            blocks = new double[blockRows * blockColumns][];</span>
        } else {
            // reference existing array
<span class="fc" id="L162">            blocks = blockData;</span>
        }

<span class="fc" id="L165">        int index = 0;</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">        for (int iBlock = 0; iBlock &lt; blockRows; ++iBlock) {</span>
<span class="fc" id="L167">            final int iHeight = blockHeight(iBlock);</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">            for (int jBlock = 0; jBlock &lt; blockColumns; ++jBlock, ++index) {</span>
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">                if (blockData[index].length != iHeight * blockWidth(jBlock)) {</span>
<span class="nc" id="L170">                    throw new DimensionMismatchException(blockData[index].length,</span>
<span class="nc" id="L171">                                                         iHeight * blockWidth(jBlock));</span>
                }
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">                if (copyArray) {</span>
<span class="nc" id="L174">                    blocks[index] = blockData[index].clone();</span>
                }
            }
        }
<span class="fc" id="L178">    }</span>

    /**
     * Convert a data array from raw layout to blocks layout.
     * &lt;p&gt;
     * Raw layout is the straightforward layout where element at row i and
     * column j is in array element &lt;code&gt;rawData[i][j]&lt;/code&gt;. Blocks layout
     * is the layout used in {@link BlockRealMatrix} instances, where the matrix
     * is split in square blocks (except at right and bottom side where blocks may
     * be rectangular to fit matrix size) and each block is stored in a flattened
     * one-dimensional array.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This method creates an array in blocks layout from an input array in raw layout.
     * It can be used to provide the array argument of the {@link
     * #BlockRealMatrix(int, int, double[][], boolean)} constructor.
     * &lt;/p&gt;
     * @param rawData Data array in raw layout.
     * @return a new data array containing the same entries but in blocks layout.
     * @throws DimensionMismatchException if {@code rawData} is not rectangular.
     * @see #createBlocksLayout(int, int)
     * @see #BlockRealMatrix(int, int, double[][], boolean)
     */
    public static double[][] toBlocksLayout(final double[][] rawData)
        throws DimensionMismatchException {
<span class="fc" id="L203">        final int rows = rawData.length;</span>
<span class="fc" id="L204">        final int columns = rawData[0].length;</span>
<span class="fc" id="L205">        final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;</span>
<span class="fc" id="L206">        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;</span>

        // safety checks
<span class="fc bfc" id="L209" title="All 2 branches covered.">        for (int i = 0; i &lt; rawData.length; ++i) {</span>
<span class="fc" id="L210">            final int length = rawData[i].length;</span>
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">            if (length != columns) {</span>
<span class="nc" id="L212">                throw new DimensionMismatchException(columns, length);</span>
            }
        }

        // convert array
<span class="fc" id="L217">        final double[][] blocks = new double[blockRows * blockColumns][];</span>
<span class="fc" id="L218">        int blockIndex = 0;</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">        for (int iBlock = 0; iBlock &lt; blockRows; ++iBlock) {</span>
<span class="fc" id="L220">            final int pStart = iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L221">            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);</span>
<span class="fc" id="L222">            final int iHeight = pEnd - pStart;</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">            for (int jBlock = 0; jBlock &lt; blockColumns; ++jBlock) {</span>
<span class="fc" id="L224">                final int qStart = jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L225">                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);</span>
<span class="fc" id="L226">                final int jWidth = qEnd - qStart;</span>

                // allocate new block
<span class="fc" id="L229">                final double[] block = new double[iHeight * jWidth];</span>
<span class="fc" id="L230">                blocks[blockIndex] = block;</span>

                // copy data
<span class="fc" id="L233">                int index = 0;</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">                for (int p = pStart; p &lt; pEnd; ++p) {</span>
<span class="fc" id="L235">                    System.arraycopy(rawData[p], qStart, block, index, jWidth);</span>
<span class="fc" id="L236">                    index += jWidth;</span>
                }
<span class="fc" id="L238">                ++blockIndex;</span>
            }
        }

<span class="fc" id="L242">        return blocks;</span>
    }

    /**
     * Create a data array in blocks layout.
     * &lt;p&gt;
     * This method can be used to create the array argument of the {@link
     * #BlockRealMatrix(int, int, double[][], boolean)} constructor.
     * &lt;/p&gt;
     * @param rows Number of rows in the new matrix.
     * @param columns Number of columns in the new matrix.
     * @return a new data array in blocks layout.
     * @see #toBlocksLayout(double[][])
     * @see #BlockRealMatrix(int, int, double[][], boolean)
     */
    public static double[][] createBlocksLayout(final int rows, final int columns) {
<span class="fc" id="L258">        final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;</span>
<span class="fc" id="L259">        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;</span>

<span class="fc" id="L261">        final double[][] blocks = new double[blockRows * blockColumns][];</span>
<span class="fc" id="L262">        int blockIndex = 0;</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">        for (int iBlock = 0; iBlock &lt; blockRows; ++iBlock) {</span>
<span class="fc" id="L264">            final int pStart = iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L265">            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);</span>
<span class="fc" id="L266">            final int iHeight = pEnd - pStart;</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">            for (int jBlock = 0; jBlock &lt; blockColumns; ++jBlock) {</span>
<span class="fc" id="L268">                final int qStart = jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L269">                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);</span>
<span class="fc" id="L270">                final int jWidth = qEnd - qStart;</span>
<span class="fc" id="L271">                blocks[blockIndex] = new double[iHeight * jWidth];</span>
<span class="fc" id="L272">                ++blockIndex;</span>
            }
        }

<span class="fc" id="L276">        return blocks;</span>
    }

    /** {@inheritDoc} */
    @Override
    public BlockRealMatrix createMatrix(final int rowDimension,
                                        final int columnDimension)
        throws NotStrictlyPositiveException {
<span class="fc" id="L284">        return new BlockRealMatrix(rowDimension, columnDimension);</span>
    }

    /** {@inheritDoc} */
    @Override
    public BlockRealMatrix copy() {
        // create an empty matrix
<span class="fc" id="L291">        BlockRealMatrix copied = new BlockRealMatrix(rows, columns);</span>

        // copy the blocks
<span class="fc bfc" id="L294" title="All 2 branches covered.">        for (int i = 0; i &lt; blocks.length; ++i) {</span>
<span class="fc" id="L295">            System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);</span>
        }

<span class="fc" id="L298">        return copied;</span>
    }

    /** {@inheritDoc} */
    @Override
    public BlockRealMatrix add(final RealMatrix m)
        throws MatrixDimensionMismatchException {
        try {
<span class="fc" id="L306">            return add((BlockRealMatrix) m);</span>
<span class="nc" id="L307">        } catch (ClassCastException cce) {</span>
            // safety check
<span class="nc" id="L309">            MatrixUtils.checkAdditionCompatible(this, m);</span>

<span class="nc" id="L311">            final BlockRealMatrix out = new BlockRealMatrix(rows, columns);</span>

            // perform addition block-wise, to ensure good cache behavior
<span class="nc" id="L314">            int blockIndex = 0;</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">            for (int iBlock = 0; iBlock &lt; out.blockRows; ++iBlock) {</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">                for (int jBlock = 0; jBlock &lt; out.blockColumns; ++jBlock) {</span>

                    // perform addition on the current block
<span class="nc" id="L319">                    final double[] outBlock = out.blocks[blockIndex];</span>
<span class="nc" id="L320">                    final double[] tBlock   = blocks[blockIndex];</span>
<span class="nc" id="L321">                    final int pStart = iBlock * BLOCK_SIZE;</span>
<span class="nc" id="L322">                    final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);</span>
<span class="nc" id="L323">                    final int qStart = jBlock * BLOCK_SIZE;</span>
<span class="nc" id="L324">                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);</span>
<span class="nc" id="L325">                    int k = 0;</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">                    for (int p = pStart; p &lt; pEnd; ++p) {</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">                        for (int q = qStart; q &lt; qEnd; ++q) {</span>
<span class="nc" id="L328">                            outBlock[k] = tBlock[k] + m.getEntry(p, q);</span>
<span class="nc" id="L329">                            ++k;</span>
                        }
                    }
                    // go to next block
<span class="nc" id="L333">                    ++blockIndex;</span>
                }
            }

<span class="nc" id="L337">            return out;</span>
        }
    }

    /**
     * Compute the sum of this matrix and {@code m}.
     *
     * @param m Matrix to be added.
     * @return {@code this} + m.
     * @throws MatrixDimensionMismatchException if {@code m} is not the same
     * size as this matrix.
     */
    public BlockRealMatrix add(final BlockRealMatrix m)
        throws MatrixDimensionMismatchException {
        // safety check
<span class="fc" id="L352">        MatrixUtils.checkAdditionCompatible(this, m);</span>

<span class="fc" id="L354">        final BlockRealMatrix out = new BlockRealMatrix(rows, columns);</span>

        // perform addition block-wise, to ensure good cache behavior
<span class="fc bfc" id="L357" title="All 2 branches covered.">        for (int blockIndex = 0; blockIndex &lt; out.blocks.length; ++blockIndex) {</span>
<span class="fc" id="L358">            final double[] outBlock = out.blocks[blockIndex];</span>
<span class="fc" id="L359">            final double[] tBlock = blocks[blockIndex];</span>
<span class="fc" id="L360">            final double[] mBlock = m.blocks[blockIndex];</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">            for (int k = 0; k &lt; outBlock.length; ++k) {</span>
<span class="fc" id="L362">                outBlock[k] = tBlock[k] + mBlock[k];</span>
            }
        }

<span class="fc" id="L366">        return out;</span>
    }

    /** {@inheritDoc} */
    @Override
    public BlockRealMatrix subtract(final RealMatrix m)
        throws MatrixDimensionMismatchException {
        try {
<span class="fc" id="L374">            return subtract((BlockRealMatrix) m);</span>
<span class="fc" id="L375">        } catch (ClassCastException cce) {</span>
            // safety check
<span class="fc" id="L377">            MatrixUtils.checkSubtractionCompatible(this, m);</span>

<span class="fc" id="L379">            final BlockRealMatrix out = new BlockRealMatrix(rows, columns);</span>

            // perform subtraction block-wise, to ensure good cache behavior
<span class="fc" id="L382">            int blockIndex = 0;</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">            for (int iBlock = 0; iBlock &lt; out.blockRows; ++iBlock) {</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">                for (int jBlock = 0; jBlock &lt; out.blockColumns; ++jBlock) {</span>

                    // perform subtraction on the current block
<span class="fc" id="L387">                    final double[] outBlock = out.blocks[blockIndex];</span>
<span class="fc" id="L388">                    final double[] tBlock = blocks[blockIndex];</span>
<span class="fc" id="L389">                    final int pStart = iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L390">                    final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);</span>
<span class="fc" id="L391">                    final int qStart = jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L392">                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);</span>
<span class="fc" id="L393">                    int k = 0;</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">                    for (int p = pStart; p &lt; pEnd; ++p) {</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">                        for (int q = qStart; q &lt; qEnd; ++q) {</span>
<span class="fc" id="L396">                            outBlock[k] = tBlock[k] - m.getEntry(p, q);</span>
<span class="fc" id="L397">                            ++k;</span>
                        }
                    }
                    // go to next block
<span class="fc" id="L401">                    ++blockIndex;</span>
                }
            }

<span class="fc" id="L405">            return out;</span>
        }
    }

    /**
     * Subtract {@code m} from this matrix.
     *
     * @param m Matrix to be subtracted.
     * @return {@code this} - m.
     * @throws MatrixDimensionMismatchException if {@code m} is not the
     * same size as this matrix.
     */
    public BlockRealMatrix subtract(final BlockRealMatrix m)
        throws MatrixDimensionMismatchException {
        // safety check
<span class="fc" id="L420">        MatrixUtils.checkSubtractionCompatible(this, m);</span>

<span class="fc" id="L422">        final BlockRealMatrix out = new BlockRealMatrix(rows, columns);</span>

        // perform subtraction block-wise, to ensure good cache behavior
<span class="fc bfc" id="L425" title="All 2 branches covered.">        for (int blockIndex = 0; blockIndex &lt; out.blocks.length; ++blockIndex) {</span>
<span class="fc" id="L426">            final double[] outBlock = out.blocks[blockIndex];</span>
<span class="fc" id="L427">            final double[] tBlock = blocks[blockIndex];</span>
<span class="fc" id="L428">            final double[] mBlock = m.blocks[blockIndex];</span>
<span class="fc bfc" id="L429" title="All 2 branches covered.">            for (int k = 0; k &lt; outBlock.length; ++k) {</span>
<span class="fc" id="L430">                outBlock[k] = tBlock[k] - mBlock[k];</span>
            }
        }

<span class="fc" id="L434">        return out;</span>
    }

    /** {@inheritDoc} */
    @Override
    public BlockRealMatrix scalarAdd(final double d) {

<span class="fc" id="L441">        final BlockRealMatrix out = new BlockRealMatrix(rows, columns);</span>

        // perform subtraction block-wise, to ensure good cache behavior
<span class="fc bfc" id="L444" title="All 2 branches covered.">        for (int blockIndex = 0; blockIndex &lt; out.blocks.length; ++blockIndex) {</span>
<span class="fc" id="L445">            final double[] outBlock = out.blocks[blockIndex];</span>
<span class="fc" id="L446">            final double[] tBlock = blocks[blockIndex];</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">            for (int k = 0; k &lt; outBlock.length; ++k) {</span>
<span class="fc" id="L448">                outBlock[k] = tBlock[k] + d;</span>
            }
        }

<span class="fc" id="L452">        return out;</span>
    }

    /** {@inheritDoc} */
    @Override
    public RealMatrix scalarMultiply(final double d) {
<span class="fc" id="L458">        final BlockRealMatrix out = new BlockRealMatrix(rows, columns);</span>

        // perform subtraction block-wise, to ensure good cache behavior
<span class="fc bfc" id="L461" title="All 2 branches covered.">        for (int blockIndex = 0; blockIndex &lt; out.blocks.length; ++blockIndex) {</span>
<span class="fc" id="L462">            final double[] outBlock = out.blocks[blockIndex];</span>
<span class="fc" id="L463">            final double[] tBlock = blocks[blockIndex];</span>
<span class="fc bfc" id="L464" title="All 2 branches covered.">            for (int k = 0; k &lt; outBlock.length; ++k) {</span>
<span class="fc" id="L465">                outBlock[k] = tBlock[k] * d;</span>
            }
        }

<span class="fc" id="L469">        return out;</span>
    }

    /** {@inheritDoc} */
    @Override
    public BlockRealMatrix multiply(final RealMatrix m)
        throws DimensionMismatchException {
        try {
<span class="fc" id="L477">            return multiply((BlockRealMatrix) m);</span>
<span class="fc" id="L478">        } catch (ClassCastException cce) {</span>
            // safety check
<span class="fc" id="L480">            MatrixUtils.checkMultiplicationCompatible(this, m);</span>

<span class="fc" id="L482">            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());</span>

            // perform multiplication block-wise, to ensure good cache behavior
<span class="fc" id="L485">            int blockIndex = 0;</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">            for (int iBlock = 0; iBlock &lt; out.blockRows; ++iBlock) {</span>
<span class="fc" id="L487">                final int pStart = iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L488">                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);</span>

<span class="fc bfc" id="L490" title="All 2 branches covered.">                for (int jBlock = 0; jBlock &lt; out.blockColumns; ++jBlock) {</span>
<span class="fc" id="L491">                    final int qStart = jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L492">                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());</span>

                    // select current block
<span class="fc" id="L495">                    final double[] outBlock = out.blocks[blockIndex];</span>

                    // perform multiplication on current block
<span class="fc bfc" id="L498" title="All 2 branches covered.">                    for (int kBlock = 0; kBlock &lt; blockColumns; ++kBlock) {</span>
<span class="fc" id="L499">                        final int kWidth = blockWidth(kBlock);</span>
<span class="fc" id="L500">                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];</span>
<span class="fc" id="L501">                        final int rStart = kBlock * BLOCK_SIZE;</span>
<span class="fc" id="L502">                        int k = 0;</span>
<span class="fc bfc" id="L503" title="All 2 branches covered.">                        for (int p = pStart; p &lt; pEnd; ++p) {</span>
<span class="fc" id="L504">                            final int lStart = (p - pStart) * kWidth;</span>
<span class="fc" id="L505">                            final int lEnd = lStart + kWidth;</span>
<span class="fc bfc" id="L506" title="All 2 branches covered.">                            for (int q = qStart; q &lt; qEnd; ++q) {</span>
<span class="fc" id="L507">                                double sum = 0;</span>
<span class="fc" id="L508">                                int r = rStart;</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">                                for (int l = lStart; l &lt; lEnd; ++l) {</span>
<span class="fc" id="L510">                                    sum += tBlock[l] * m.getEntry(r, q);</span>
<span class="fc" id="L511">                                    ++r;</span>
                                }
<span class="fc" id="L513">                                outBlock[k] += sum;</span>
<span class="fc" id="L514">                                ++k;</span>
                            }
                        }
                    }
                    // go to next block
<span class="fc" id="L519">                    ++blockIndex;</span>
                }
            }

<span class="fc" id="L523">            return out;</span>
        }
    }

    /**
     * Returns the result of postmultiplying this by {@code m}.
     *
     * @param m Matrix to postmultiply by.
     * @return {@code this} * m.
     * @throws DimensionMismatchException if the matrices are not compatible.
     */
    public BlockRealMatrix multiply(BlockRealMatrix m)
        throws DimensionMismatchException {
        // safety check
<span class="fc" id="L537">        MatrixUtils.checkMultiplicationCompatible(this, m);</span>

<span class="fc" id="L539">        final BlockRealMatrix out = new BlockRealMatrix(rows, m.columns);</span>

        // perform multiplication block-wise, to ensure good cache behavior
<span class="fc" id="L542">        int blockIndex = 0;</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">        for (int iBlock = 0; iBlock &lt; out.blockRows; ++iBlock) {</span>

<span class="fc" id="L545">            final int pStart = iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L546">            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);</span>

<span class="fc bfc" id="L548" title="All 2 branches covered.">            for (int jBlock = 0; jBlock &lt; out.blockColumns; ++jBlock) {</span>
<span class="fc" id="L549">                final int jWidth = out.blockWidth(jBlock);</span>
<span class="fc" id="L550">                final int jWidth2 = jWidth  + jWidth;</span>
<span class="fc" id="L551">                final int jWidth3 = jWidth2 + jWidth;</span>
<span class="fc" id="L552">                final int jWidth4 = jWidth3 + jWidth;</span>

                // select current block
<span class="fc" id="L555">                final double[] outBlock = out.blocks[blockIndex];</span>

                // perform multiplication on current block
<span class="fc bfc" id="L558" title="All 2 branches covered.">                for (int kBlock = 0; kBlock &lt; blockColumns; ++kBlock) {</span>
<span class="fc" id="L559">                    final int kWidth = blockWidth(kBlock);</span>
<span class="fc" id="L560">                    final double[] tBlock = blocks[iBlock * blockColumns + kBlock];</span>
<span class="fc" id="L561">                    final double[] mBlock = m.blocks[kBlock * m.blockColumns + jBlock];</span>
<span class="fc" id="L562">                    int k = 0;</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">                    for (int p = pStart; p &lt; pEnd; ++p) {</span>
<span class="fc" id="L564">                        final int lStart = (p - pStart) * kWidth;</span>
<span class="fc" id="L565">                        final int lEnd = lStart + kWidth;</span>
<span class="fc bfc" id="L566" title="All 2 branches covered.">                        for (int nStart = 0; nStart &lt; jWidth; ++nStart) {</span>
<span class="fc" id="L567">                            double sum = 0;</span>
<span class="fc" id="L568">                            int l = lStart;</span>
<span class="fc" id="L569">                            int n = nStart;</span>
<span class="fc bfc" id="L570" title="All 2 branches covered.">                            while (l &lt; lEnd - 3) {</span>
<span class="fc" id="L571">                                sum += tBlock[l] * mBlock[n] +</span>
                                       tBlock[l + 1] * mBlock[n + jWidth] +
                                       tBlock[l + 2] * mBlock[n + jWidth2] +
                                       tBlock[l + 3] * mBlock[n + jWidth3];
<span class="fc" id="L575">                                l += 4;</span>
<span class="fc" id="L576">                                n += jWidth4;</span>
                            }
<span class="fc bfc" id="L578" title="All 2 branches covered.">                            while (l &lt; lEnd) {</span>
<span class="fc" id="L579">                                sum += tBlock[l++] * mBlock[n];</span>
<span class="fc" id="L580">                                n += jWidth;</span>
                            }
<span class="fc" id="L582">                            outBlock[k] += sum;</span>
<span class="fc" id="L583">                            ++k;</span>
                        }
                    }
                }
                // go to next block
<span class="fc" id="L588">                ++blockIndex;</span>
            }
        }

<span class="fc" id="L592">        return out;</span>
    }

    /** {@inheritDoc} */
    @Override
    public double[][] getData() {
<span class="fc" id="L598">        final double[][] data = new double[getRowDimension()][getColumnDimension()];</span>
<span class="fc" id="L599">        final int lastColumns = columns - (blockColumns - 1) * BLOCK_SIZE;</span>

<span class="fc bfc" id="L601" title="All 2 branches covered.">        for (int iBlock = 0; iBlock &lt; blockRows; ++iBlock) {</span>
<span class="fc" id="L602">            final int pStart = iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L603">            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);</span>
<span class="fc" id="L604">            int regularPos = 0;</span>
<span class="fc" id="L605">            int lastPos = 0;</span>
<span class="fc bfc" id="L606" title="All 2 branches covered.">            for (int p = pStart; p &lt; pEnd; ++p) {</span>
<span class="fc" id="L607">                final double[] dataP = data[p];</span>
<span class="fc" id="L608">                int blockIndex = iBlock * blockColumns;</span>
<span class="fc" id="L609">                int dataPos = 0;</span>
<span class="fc bfc" id="L610" title="All 2 branches covered.">                for (int jBlock = 0; jBlock &lt; blockColumns - 1; ++jBlock) {</span>
<span class="fc" id="L611">                    System.arraycopy(blocks[blockIndex++], regularPos, dataP, dataPos, BLOCK_SIZE);</span>
<span class="fc" id="L612">                    dataPos += BLOCK_SIZE;</span>
                }
<span class="fc" id="L614">                System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);</span>
<span class="fc" id="L615">                regularPos += BLOCK_SIZE;</span>
<span class="fc" id="L616">                lastPos    += lastColumns;</span>
            }
        }

<span class="fc" id="L620">        return data;</span>
    }

    /** {@inheritDoc} */
    @Override
    public double getNorm() {
<span class="fc" id="L626">        final double[] colSums = new double[BLOCK_SIZE];</span>
<span class="fc" id="L627">        double maxColSum = 0;</span>
<span class="fc bfc" id="L628" title="All 2 branches covered.">        for (int jBlock = 0; jBlock &lt; blockColumns; jBlock++) {</span>
<span class="fc" id="L629">            final int jWidth = blockWidth(jBlock);</span>
<span class="fc" id="L630">            Arrays.fill(colSums, 0, jWidth, 0.0);</span>
<span class="fc bfc" id="L631" title="All 2 branches covered.">            for (int iBlock = 0; iBlock &lt; blockRows; ++iBlock) {</span>
<span class="fc" id="L632">                final int iHeight = blockHeight(iBlock);</span>
<span class="fc" id="L633">                final double[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc bfc" id="L634" title="All 2 branches covered.">                for (int j = 0; j &lt; jWidth; ++j) {</span>
<span class="fc" id="L635">                    double sum = 0;</span>
<span class="fc bfc" id="L636" title="All 2 branches covered.">                    for (int i = 0; i &lt; iHeight; ++i) {</span>
<span class="fc" id="L637">                        sum += FastMath.abs(block[i * jWidth + j]);</span>
                    }
<span class="fc" id="L639">                    colSums[j] += sum;</span>
                }
            }
<span class="fc bfc" id="L642" title="All 2 branches covered.">            for (int j = 0; j &lt; jWidth; ++j) {</span>
<span class="fc" id="L643">                maxColSum = FastMath.max(maxColSum, colSums[j]);</span>
            }
        }
<span class="fc" id="L646">        return maxColSum;</span>
    }

    /** {@inheritDoc} */
    @Override
    public double getFrobeniusNorm() {
<span class="fc" id="L652">        double sum2 = 0;</span>
<span class="fc bfc" id="L653" title="All 2 branches covered.">        for (int blockIndex = 0; blockIndex &lt; blocks.length; ++blockIndex) {</span>
<span class="fc bfc" id="L654" title="All 2 branches covered.">            for (final double entry : blocks[blockIndex]) {</span>
<span class="fc" id="L655">                sum2 += entry * entry;</span>
            }
        }
<span class="fc" id="L658">        return FastMath.sqrt(sum2);</span>
    }

    /** {@inheritDoc} */
    @Override
    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,
                                        final int startColumn,
                                        final int endColumn)
        throws OutOfRangeException, NumberIsTooSmallException {
        // safety checks
<span class="fc" id="L668">        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);</span>

        // create the output matrix
<span class="fc" id="L671">        final BlockRealMatrix out =</span>
            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);

        // compute blocks shifts
<span class="fc" id="L675">        final int blockStartRow = startRow / BLOCK_SIZE;</span>
<span class="fc" id="L676">        final int rowsShift = startRow % BLOCK_SIZE;</span>
<span class="fc" id="L677">        final int blockStartColumn = startColumn / BLOCK_SIZE;</span>
<span class="fc" id="L678">        final int columnsShift = startColumn % BLOCK_SIZE;</span>

        // perform extraction block-wise, to ensure good cache behavior
<span class="fc" id="L681">        int pBlock = blockStartRow;</span>
<span class="fc bfc" id="L682" title="All 2 branches covered.">        for (int iBlock = 0; iBlock &lt; out.blockRows; ++iBlock) {</span>
<span class="fc" id="L683">            final int iHeight = out.blockHeight(iBlock);</span>
<span class="fc" id="L684">            int qBlock = blockStartColumn;</span>
<span class="fc bfc" id="L685" title="All 2 branches covered.">            for (int jBlock = 0; jBlock &lt; out.blockColumns; ++jBlock) {</span>
<span class="fc" id="L686">                final int jWidth = out.blockWidth(jBlock);</span>

                // handle one block of the output matrix
<span class="fc" id="L689">                final int outIndex = iBlock * out.blockColumns + jBlock;</span>
<span class="fc" id="L690">                final double[] outBlock = out.blocks[outIndex];</span>
<span class="fc" id="L691">                final int index = pBlock * blockColumns + qBlock;</span>
<span class="fc" id="L692">                final int width = blockWidth(qBlock);</span>

<span class="fc" id="L694">                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;</span>
<span class="fc" id="L695">                final int widthExcess = jWidth + columnsShift - BLOCK_SIZE;</span>
<span class="fc bfc" id="L696" title="All 2 branches covered.">                if (heightExcess &gt; 0) {</span>
                    // the submatrix block spans on two blocks rows from the original matrix
<span class="fc bfc" id="L698" title="All 2 branches covered.">                    if (widthExcess &gt; 0) {</span>
                        // the submatrix block spans on two blocks columns from the original matrix
<span class="fc" id="L700">                        final int width2 = blockWidth(qBlock + 1);</span>
<span class="fc" id="L701">                        copyBlockPart(blocks[index], width,</span>
                                      rowsShift, BLOCK_SIZE,
                                      columnsShift, BLOCK_SIZE,
                                      outBlock, jWidth, 0, 0);
<span class="fc" id="L705">                        copyBlockPart(blocks[index + 1], width2,</span>
                                      rowsShift, BLOCK_SIZE,
                                      0, widthExcess,
                                      outBlock, jWidth, 0, jWidth - widthExcess);
<span class="fc" id="L709">                        copyBlockPart(blocks[index + blockColumns], width,</span>
                                      0, heightExcess,
                                      columnsShift, BLOCK_SIZE,
                                      outBlock, jWidth, iHeight - heightExcess, 0);
<span class="fc" id="L713">                        copyBlockPart(blocks[index + blockColumns + 1], width2,</span>
                                      0, heightExcess,
                                      0, widthExcess,
                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);
<span class="fc" id="L717">                    } else {</span>
                        // the submatrix block spans on one block column from the original matrix
<span class="fc" id="L719">                        copyBlockPart(blocks[index], width,</span>
                                      rowsShift, BLOCK_SIZE,
                                      columnsShift, jWidth + columnsShift,
                                      outBlock, jWidth, 0, 0);
<span class="fc" id="L723">                        copyBlockPart(blocks[index + blockColumns], width,</span>
                                      0, heightExcess,
                                      columnsShift, jWidth + columnsShift,
                                      outBlock, jWidth, iHeight - heightExcess, 0);
                    }
                } else {
                    // the submatrix block spans on one block row from the original matrix
<span class="fc bfc" id="L730" title="All 2 branches covered.">                    if (widthExcess &gt; 0) {</span>
                        // the submatrix block spans on two blocks columns from the original matrix
<span class="fc" id="L732">                        final int width2 = blockWidth(qBlock + 1);</span>
<span class="fc" id="L733">                        copyBlockPart(blocks[index], width,</span>
                                      rowsShift, iHeight + rowsShift,
                                      columnsShift, BLOCK_SIZE,
                                      outBlock, jWidth, 0, 0);
<span class="fc" id="L737">                        copyBlockPart(blocks[index + 1], width2,</span>
                                      rowsShift, iHeight + rowsShift,
                                      0, widthExcess,
                                      outBlock, jWidth, 0, jWidth - widthExcess);
<span class="fc" id="L741">                    } else {</span>
                        // the submatrix block spans on one block column from the original matrix
<span class="fc" id="L743">                        copyBlockPart(blocks[index], width,</span>
                                      rowsShift, iHeight + rowsShift,
                                      columnsShift, jWidth + columnsShift,
                                      outBlock, jWidth, 0, 0);
                    }
               }
<span class="fc" id="L749">                ++qBlock;</span>
            }
<span class="fc" id="L751">            ++pBlock;</span>
        }

<span class="fc" id="L754">        return out;</span>
    }

    /**
     * Copy a part of a block into another one
     * &lt;p&gt;This method can be called only when the specified part fits in both
     * blocks, no verification is done here.&lt;/p&gt;
     * @param srcBlock source block
     * @param srcWidth source block width ({@link #BLOCK_SIZE} or smaller)
     * @param srcStartRow start row in the source block
     * @param srcEndRow end row (exclusive) in the source block
     * @param srcStartColumn start column in the source block
     * @param srcEndColumn end column (exclusive) in the source block
     * @param dstBlock destination block
     * @param dstWidth destination block width ({@link #BLOCK_SIZE} or smaller)
     * @param dstStartRow start row in the destination block
     * @param dstStartColumn start column in the destination block
     */
    private void copyBlockPart(final double[] srcBlock, final int srcWidth,
                               final int srcStartRow, final int srcEndRow,
                               final int srcStartColumn, final int srcEndColumn,
                               final double[] dstBlock, final int dstWidth,
                               final int dstStartRow, final int dstStartColumn) {
<span class="fc" id="L777">        final int length = srcEndColumn - srcStartColumn;</span>
<span class="fc" id="L778">        int srcPos = srcStartRow * srcWidth + srcStartColumn;</span>
<span class="fc" id="L779">        int dstPos = dstStartRow * dstWidth + dstStartColumn;</span>
<span class="fc bfc" id="L780" title="All 2 branches covered.">        for (int srcRow = srcStartRow; srcRow &lt; srcEndRow; ++srcRow) {</span>
<span class="fc" id="L781">            System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);</span>
<span class="fc" id="L782">            srcPos += srcWidth;</span>
<span class="fc" id="L783">            dstPos += dstWidth;</span>
        }
<span class="fc" id="L785">    }</span>

    /** {@inheritDoc} */
    @Override
    public void setSubMatrix(final double[][] subMatrix, final int row,
                             final int column)
        throws OutOfRangeException, NoDataException, NullArgumentException,
        DimensionMismatchException {
        // safety checks
<span class="fc" id="L794">        MathUtils.checkNotNull(subMatrix);</span>
<span class="fc" id="L795">        final int refLength = subMatrix[0].length;</span>
<span class="fc bfc" id="L796" title="All 2 branches covered.">        if (refLength == 0) {</span>
<span class="fc" id="L797">            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);</span>
        }
<span class="fc" id="L799">        final int endRow = row + subMatrix.length - 1;</span>
<span class="fc" id="L800">        final int endColumn = column + refLength - 1;</span>
<span class="fc" id="L801">        MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);</span>
<span class="fc bfc" id="L802" title="All 2 branches covered.">        for (final double[] subRow : subMatrix) {</span>
<span class="fc bfc" id="L803" title="All 2 branches covered.">            if (subRow.length != refLength) {</span>
<span class="fc" id="L804">                throw new DimensionMismatchException(refLength, subRow.length);</span>
            }
        }

        // compute blocks bounds
<span class="fc" id="L809">        final int blockStartRow = row / BLOCK_SIZE;</span>
<span class="fc" id="L810">        final int blockEndRow = (endRow + BLOCK_SIZE) / BLOCK_SIZE;</span>
<span class="fc" id="L811">        final int blockStartColumn = column / BLOCK_SIZE;</span>
<span class="fc" id="L812">        final int blockEndColumn = (endColumn + BLOCK_SIZE) / BLOCK_SIZE;</span>

        // perform copy block-wise, to ensure good cache behavior
<span class="fc bfc" id="L815" title="All 2 branches covered.">        for (int iBlock = blockStartRow; iBlock &lt; blockEndRow; ++iBlock) {</span>
<span class="fc" id="L816">            final int iHeight = blockHeight(iBlock);</span>
<span class="fc" id="L817">            final int firstRow = iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L818">            final int iStart = FastMath.max(row,    firstRow);</span>
<span class="fc" id="L819">            final int iEnd = FastMath.min(endRow + 1, firstRow + iHeight);</span>

<span class="fc bfc" id="L821" title="All 2 branches covered.">            for (int jBlock = blockStartColumn; jBlock &lt; blockEndColumn; ++jBlock) {</span>
<span class="fc" id="L822">                final int jWidth = blockWidth(jBlock);</span>
<span class="fc" id="L823">                final int firstColumn = jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L824">                final int jStart = FastMath.max(column,    firstColumn);</span>
<span class="fc" id="L825">                final int jEnd = FastMath.min(endColumn + 1, firstColumn + jWidth);</span>
<span class="fc" id="L826">                final int jLength = jEnd - jStart;</span>

                // handle one block, row by row
<span class="fc" id="L829">                final double[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc bfc" id="L830" title="All 2 branches covered.">                for (int i = iStart; i &lt; iEnd; ++i) {</span>
<span class="fc" id="L831">                    System.arraycopy(subMatrix[i - row], jStart - column,</span>
                                     block, (i - firstRow) * jWidth + (jStart - firstColumn),
                                     jLength);
                }

            }
        }
<span class="fc" id="L838">    }</span>

    /** {@inheritDoc} */
    @Override
    public BlockRealMatrix getRowMatrix(final int row)
        throws OutOfRangeException {
<span class="fc" id="L844">        MatrixUtils.checkRowIndex(this, row);</span>
<span class="fc" id="L845">        final BlockRealMatrix out = new BlockRealMatrix(1, columns);</span>

        // perform copy block-wise, to ensure good cache behavior
<span class="fc" id="L848">        final int iBlock = row / BLOCK_SIZE;</span>
<span class="fc" id="L849">        final int iRow = row - iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L850">        int outBlockIndex = 0;</span>
<span class="fc" id="L851">        int outIndex = 0;</span>
<span class="fc" id="L852">        double[] outBlock = out.blocks[outBlockIndex];</span>
<span class="fc bfc" id="L853" title="All 2 branches covered.">        for (int jBlock = 0; jBlock &lt; blockColumns; ++jBlock) {</span>
<span class="fc" id="L854">            final int jWidth = blockWidth(jBlock);</span>
<span class="fc" id="L855">            final double[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc" id="L856">            final int available = outBlock.length - outIndex;</span>
<span class="fc bfc" id="L857" title="All 2 branches covered.">            if (jWidth &gt; available) {</span>
<span class="fc" id="L858">                System.arraycopy(block, iRow * jWidth, outBlock, outIndex, available);</span>
<span class="fc" id="L859">                outBlock = out.blocks[++outBlockIndex];</span>
<span class="fc" id="L860">                System.arraycopy(block, iRow * jWidth, outBlock, 0, jWidth - available);</span>
<span class="fc" id="L861">                outIndex = jWidth - available;</span>
            } else {
<span class="fc" id="L863">                System.arraycopy(block, iRow * jWidth, outBlock, outIndex, jWidth);</span>
<span class="fc" id="L864">                outIndex += jWidth;</span>
            }
        }

<span class="fc" id="L868">        return out;</span>
    }

    /** {@inheritDoc} */
    @Override
    public void setRowMatrix(final int row, final RealMatrix matrix)
        throws OutOfRangeException, MatrixDimensionMismatchException {
        try {
<span class="fc" id="L876">            setRowMatrix(row, (BlockRealMatrix) matrix);</span>
<span class="nc" id="L877">        } catch (ClassCastException cce) {</span>
<span class="nc" id="L878">            super.setRowMatrix(row, matrix);</span>
<span class="fc" id="L879">        }</span>
<span class="fc" id="L880">    }</span>

    /**
     * Sets the entries in row number &lt;code&gt;row&lt;/code&gt;
     * as a row matrix.  Row indices start at 0.
     *
     * @param row the row to be set
     * @param matrix row matrix (must have one row and the same number of columns
     * as the instance)
     * @throws OutOfRangeException if the specified row index is invalid.
     * @throws MatrixDimensionMismatchException if the matrix dimensions do
     * not match one instance row.
     */
    public void setRowMatrix(final int row, final BlockRealMatrix matrix)
        throws OutOfRangeException, MatrixDimensionMismatchException {
<span class="fc" id="L895">        MatrixUtils.checkRowIndex(this, row);</span>
<span class="fc" id="L896">        final int nCols = getColumnDimension();</span>
<span class="fc bfc" id="L897" title="All 2 branches covered.">        if ((matrix.getRowDimension() != 1) ||</span>
<span class="pc bpc" id="L898" title="1 of 2 branches missed.">            (matrix.getColumnDimension() != nCols)) {</span>
<span class="fc" id="L899">            throw new MatrixDimensionMismatchException(matrix.getRowDimension(),</span>
<span class="fc" id="L900">                                                       matrix.getColumnDimension(),</span>
                                                       1, nCols);
        }

        // perform copy block-wise, to ensure good cache behavior
<span class="fc" id="L905">        final int iBlock = row / BLOCK_SIZE;</span>
<span class="fc" id="L906">        final int iRow = row - iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L907">        int mBlockIndex = 0;</span>
<span class="fc" id="L908">        int mIndex = 0;</span>
<span class="fc" id="L909">        double[] mBlock = matrix.blocks[mBlockIndex];</span>
<span class="fc bfc" id="L910" title="All 2 branches covered.">        for (int jBlock = 0; jBlock &lt; blockColumns; ++jBlock) {</span>
<span class="fc" id="L911">            final int jWidth = blockWidth(jBlock);</span>
<span class="fc" id="L912">            final double[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc" id="L913">            final int available  = mBlock.length - mIndex;</span>
<span class="fc bfc" id="L914" title="All 2 branches covered.">            if (jWidth &gt; available) {</span>
<span class="fc" id="L915">                System.arraycopy(mBlock, mIndex, block, iRow * jWidth, available);</span>
<span class="fc" id="L916">                mBlock = matrix.blocks[++mBlockIndex];</span>
<span class="fc" id="L917">                System.arraycopy(mBlock, 0, block, iRow * jWidth, jWidth - available);</span>
<span class="fc" id="L918">                mIndex = jWidth - available;</span>
            } else {
<span class="fc" id="L920">                System.arraycopy(mBlock, mIndex, block, iRow * jWidth, jWidth);</span>
<span class="fc" id="L921">                mIndex += jWidth;</span>
           }
        }
<span class="fc" id="L924">    }</span>

    /** {@inheritDoc} */
    @Override
    public BlockRealMatrix getColumnMatrix(final int column)
        throws OutOfRangeException {
<span class="fc" id="L930">        MatrixUtils.checkColumnIndex(this, column);</span>
<span class="fc" id="L931">        final BlockRealMatrix out = new BlockRealMatrix(rows, 1);</span>

        // perform copy block-wise, to ensure good cache behavior
<span class="fc" id="L934">        final int jBlock = column / BLOCK_SIZE;</span>
<span class="fc" id="L935">        final int jColumn = column - jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L936">        final int jWidth = blockWidth(jBlock);</span>
<span class="fc" id="L937">        int outBlockIndex = 0;</span>
<span class="fc" id="L938">        int outIndex = 0;</span>
<span class="fc" id="L939">        double[] outBlock = out.blocks[outBlockIndex];</span>
<span class="fc bfc" id="L940" title="All 2 branches covered.">        for (int iBlock = 0; iBlock &lt; blockRows; ++iBlock) {</span>
<span class="fc" id="L941">            final int iHeight = blockHeight(iBlock);</span>
<span class="fc" id="L942">            final double[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc bfc" id="L943" title="All 2 branches covered.">            for (int i = 0; i &lt; iHeight; ++i) {</span>
<span class="fc bfc" id="L944" title="All 2 branches covered.">                if (outIndex &gt;= outBlock.length) {</span>
<span class="fc" id="L945">                    outBlock = out.blocks[++outBlockIndex];</span>
<span class="fc" id="L946">                    outIndex = 0;</span>
                }
<span class="fc" id="L948">                outBlock[outIndex++] = block[i * jWidth + jColumn];</span>
            }
        }

<span class="fc" id="L952">        return out;</span>
    }

    /** {@inheritDoc} */
    @Override
    public void setColumnMatrix(final int column, final RealMatrix matrix)
        throws OutOfRangeException, MatrixDimensionMismatchException {
        try {
<span class="fc" id="L960">            setColumnMatrix(column, (BlockRealMatrix) matrix);</span>
<span class="nc" id="L961">        } catch (ClassCastException cce) {</span>
<span class="nc" id="L962">            super.setColumnMatrix(column, matrix);</span>
<span class="fc" id="L963">        }</span>
<span class="fc" id="L964">    }</span>

    /**
     * Sets the entries in column number &lt;code&gt;column&lt;/code&gt;
     * as a column matrix.  Column indices start at 0.
     *
     * @param column the column to be set
     * @param matrix column matrix (must have one column and the same number of rows
     * as the instance)
     * @throws OutOfRangeException if the specified column index is invalid.
     * @throws MatrixDimensionMismatchException if the matrix dimensions do
     * not match one instance column.
     */
    void setColumnMatrix(final int column, final BlockRealMatrix matrix)
        throws OutOfRangeException, MatrixDimensionMismatchException {
<span class="fc" id="L979">        MatrixUtils.checkColumnIndex(this, column);</span>
<span class="fc" id="L980">        final int nRows = getRowDimension();</span>
<span class="pc bpc" id="L981" title="1 of 2 branches missed.">        if ((matrix.getRowDimension() != nRows) ||</span>
<span class="fc bfc" id="L982" title="All 2 branches covered.">            (matrix.getColumnDimension() != 1)) {</span>
<span class="fc" id="L983">            throw new MatrixDimensionMismatchException(matrix.getRowDimension(),</span>
<span class="fc" id="L984">                                                       matrix.getColumnDimension(),</span>
                                                       nRows, 1);
        }

        // perform copy block-wise, to ensure good cache behavior
<span class="fc" id="L989">        final int jBlock = column / BLOCK_SIZE;</span>
<span class="fc" id="L990">        final int jColumn = column - jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L991">        final int jWidth = blockWidth(jBlock);</span>
<span class="fc" id="L992">        int mBlockIndex = 0;</span>
<span class="fc" id="L993">        int mIndex = 0;</span>
<span class="fc" id="L994">        double[] mBlock = matrix.blocks[mBlockIndex];</span>
<span class="fc bfc" id="L995" title="All 2 branches covered.">        for (int iBlock = 0; iBlock &lt; blockRows; ++iBlock) {</span>
<span class="fc" id="L996">            final int iHeight = blockHeight(iBlock);</span>
<span class="fc" id="L997">            final double[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc bfc" id="L998" title="All 2 branches covered.">            for (int i = 0; i &lt; iHeight; ++i) {</span>
<span class="fc bfc" id="L999" title="All 2 branches covered.">                if (mIndex &gt;= mBlock.length) {</span>
<span class="fc" id="L1000">                    mBlock = matrix.blocks[++mBlockIndex];</span>
<span class="fc" id="L1001">                    mIndex = 0;</span>
                }
<span class="fc" id="L1003">                block[i * jWidth + jColumn] = mBlock[mIndex++];</span>
            }
        }
<span class="fc" id="L1006">    }</span>

    /** {@inheritDoc} */
    @Override
    public RealVector getRowVector(final int row)
        throws OutOfRangeException {
<span class="fc" id="L1012">        MatrixUtils.checkRowIndex(this, row);</span>
<span class="fc" id="L1013">        final double[] outData = new double[columns];</span>

        // perform copy block-wise, to ensure good cache behavior
<span class="fc" id="L1016">        final int iBlock = row / BLOCK_SIZE;</span>
<span class="fc" id="L1017">        final int iRow = row - iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1018">        int outIndex = 0;</span>
<span class="fc bfc" id="L1019" title="All 2 branches covered.">        for (int jBlock = 0; jBlock &lt; blockColumns; ++jBlock) {</span>
<span class="fc" id="L1020">            final int jWidth = blockWidth(jBlock);</span>
<span class="fc" id="L1021">            final double[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc" id="L1022">            System.arraycopy(block, iRow * jWidth, outData, outIndex, jWidth);</span>
<span class="fc" id="L1023">            outIndex += jWidth;</span>
        }

<span class="fc" id="L1026">        return new ArrayRealVector(outData, false);</span>
    }

    /** {@inheritDoc} */
    @Override
    public void setRowVector(final int row, final RealVector vector)
        throws OutOfRangeException, MatrixDimensionMismatchException {
        try {
<span class="fc" id="L1034">            setRow(row, ((ArrayRealVector) vector).getDataRef());</span>
<span class="nc" id="L1035">        } catch (ClassCastException cce) {</span>
<span class="nc" id="L1036">            super.setRowVector(row, vector);</span>
<span class="fc" id="L1037">        }</span>
<span class="fc" id="L1038">    }</span>

    /** {@inheritDoc} */
    @Override
    public RealVector getColumnVector(final int column)
        throws OutOfRangeException {
<span class="fc" id="L1044">        MatrixUtils.checkColumnIndex(this, column);</span>
<span class="fc" id="L1045">        final double[] outData = new double[rows];</span>

        // perform copy block-wise, to ensure good cache behavior
<span class="fc" id="L1048">        final int jBlock = column / BLOCK_SIZE;</span>
<span class="fc" id="L1049">        final int jColumn = column - jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1050">        final int jWidth = blockWidth(jBlock);</span>
<span class="fc" id="L1051">        int outIndex = 0;</span>
<span class="fc bfc" id="L1052" title="All 2 branches covered.">        for (int iBlock = 0; iBlock &lt; blockRows; ++iBlock) {</span>
<span class="fc" id="L1053">            final int iHeight = blockHeight(iBlock);</span>
<span class="fc" id="L1054">            final double[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc bfc" id="L1055" title="All 2 branches covered.">            for (int i = 0; i &lt; iHeight; ++i) {</span>
<span class="fc" id="L1056">                outData[outIndex++] = block[i * jWidth + jColumn];</span>
            }
        }

<span class="fc" id="L1060">        return new ArrayRealVector(outData, false);</span>
    }

    /** {@inheritDoc} */
    @Override
    public void setColumnVector(final int column, final RealVector vector)
        throws OutOfRangeException, MatrixDimensionMismatchException {
        try {
<span class="fc" id="L1068">            setColumn(column, ((ArrayRealVector) vector).getDataRef());</span>
<span class="nc" id="L1069">        } catch (ClassCastException cce) {</span>
<span class="nc" id="L1070">            super.setColumnVector(column, vector);</span>
<span class="fc" id="L1071">        }</span>
<span class="fc" id="L1072">    }</span>

    /** {@inheritDoc} */
    @Override
    public double[] getRow(final int row) throws OutOfRangeException {
<span class="fc" id="L1077">        MatrixUtils.checkRowIndex(this, row);</span>
<span class="fc" id="L1078">        final double[] out = new double[columns];</span>

        // perform copy block-wise, to ensure good cache behavior
<span class="fc" id="L1081">        final int iBlock = row / BLOCK_SIZE;</span>
<span class="fc" id="L1082">        final int iRow = row - iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1083">        int outIndex = 0;</span>
<span class="fc bfc" id="L1084" title="All 2 branches covered.">        for (int jBlock = 0; jBlock &lt; blockColumns; ++jBlock) {</span>
<span class="fc" id="L1085">            final int jWidth     = blockWidth(jBlock);</span>
<span class="fc" id="L1086">            final double[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc" id="L1087">            System.arraycopy(block, iRow * jWidth, out, outIndex, jWidth);</span>
<span class="fc" id="L1088">            outIndex += jWidth;</span>
        }

<span class="fc" id="L1091">        return out;</span>
    }

    /** {@inheritDoc} */
    @Override
    public void setRow(final int row, final double[] array)
        throws OutOfRangeException, MatrixDimensionMismatchException {
<span class="fc" id="L1098">        MatrixUtils.checkRowIndex(this, row);</span>
<span class="fc" id="L1099">        final int nCols = getColumnDimension();</span>
<span class="fc bfc" id="L1100" title="All 2 branches covered.">        if (array.length != nCols) {</span>
<span class="fc" id="L1101">            throw new MatrixDimensionMismatchException(1, array.length, 1, nCols);</span>
        }

        // perform copy block-wise, to ensure good cache behavior
<span class="fc" id="L1105">        final int iBlock = row / BLOCK_SIZE;</span>
<span class="fc" id="L1106">        final int iRow = row - iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1107">        int outIndex = 0;</span>
<span class="fc bfc" id="L1108" title="All 2 branches covered.">        for (int jBlock = 0; jBlock &lt; blockColumns; ++jBlock) {</span>
<span class="fc" id="L1109">            final int jWidth     = blockWidth(jBlock);</span>
<span class="fc" id="L1110">            final double[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc" id="L1111">            System.arraycopy(array, outIndex, block, iRow * jWidth, jWidth);</span>
<span class="fc" id="L1112">            outIndex += jWidth;</span>
        }
<span class="fc" id="L1114">    }</span>

    /** {@inheritDoc} */
    @Override
    public double[] getColumn(final int column) throws OutOfRangeException {
<span class="fc" id="L1119">        MatrixUtils.checkColumnIndex(this, column);</span>
<span class="fc" id="L1120">        final double[] out = new double[rows];</span>

        // perform copy block-wise, to ensure good cache behavior
<span class="fc" id="L1123">        final int jBlock  = column / BLOCK_SIZE;</span>
<span class="fc" id="L1124">        final int jColumn = column - jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1125">        final int jWidth  = blockWidth(jBlock);</span>
<span class="fc" id="L1126">        int outIndex = 0;</span>
<span class="fc bfc" id="L1127" title="All 2 branches covered.">        for (int iBlock = 0; iBlock &lt; blockRows; ++iBlock) {</span>
<span class="fc" id="L1128">            final int iHeight = blockHeight(iBlock);</span>
<span class="fc" id="L1129">            final double[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc bfc" id="L1130" title="All 2 branches covered.">            for (int i = 0; i &lt; iHeight; ++i) {</span>
<span class="fc" id="L1131">                out[outIndex++] = block[i * jWidth + jColumn];</span>
            }
        }

<span class="fc" id="L1135">        return out;</span>
    }

    /** {@inheritDoc} */
    @Override
    public void setColumn(final int column, final double[] array)
        throws OutOfRangeException, MatrixDimensionMismatchException {
<span class="fc" id="L1142">        MatrixUtils.checkColumnIndex(this, column);</span>
<span class="fc" id="L1143">        final int nRows = getRowDimension();</span>
<span class="fc bfc" id="L1144" title="All 2 branches covered.">        if (array.length != nRows) {</span>
<span class="fc" id="L1145">            throw new MatrixDimensionMismatchException(array.length, 1, nRows, 1);</span>
        }

        // perform copy block-wise, to ensure good cache behavior
<span class="fc" id="L1149">        final int jBlock  = column / BLOCK_SIZE;</span>
<span class="fc" id="L1150">        final int jColumn = column - jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1151">        final int jWidth = blockWidth(jBlock);</span>
<span class="fc" id="L1152">        int outIndex = 0;</span>
<span class="fc bfc" id="L1153" title="All 2 branches covered.">        for (int iBlock = 0; iBlock &lt; blockRows; ++iBlock) {</span>
<span class="fc" id="L1154">            final int iHeight = blockHeight(iBlock);</span>
<span class="fc" id="L1155">            final double[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc bfc" id="L1156" title="All 2 branches covered.">            for (int i = 0; i &lt; iHeight; ++i) {</span>
<span class="fc" id="L1157">                block[i * jWidth + jColumn] = array[outIndex++];</span>
            }
        }
<span class="fc" id="L1160">    }</span>

    /** {@inheritDoc} */
    @Override
    public double getEntry(final int row, final int column)
        throws OutOfRangeException {
<span class="fc" id="L1166">        MatrixUtils.checkMatrixIndex(this, row, column);</span>
<span class="fc" id="L1167">        final int iBlock = row / BLOCK_SIZE;</span>
<span class="fc" id="L1168">        final int jBlock = column / BLOCK_SIZE;</span>
<span class="fc" id="L1169">        final int k = (row - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +</span>
            (column - jBlock * BLOCK_SIZE);
<span class="fc" id="L1171">        return blocks[iBlock * blockColumns + jBlock][k];</span>
    }

    /** {@inheritDoc} */
    @Override
    public void setEntry(final int row, final int column, final double value)
        throws OutOfRangeException {
<span class="fc" id="L1178">        MatrixUtils.checkMatrixIndex(this, row, column);</span>
<span class="fc" id="L1179">        final int iBlock = row / BLOCK_SIZE;</span>
<span class="fc" id="L1180">        final int jBlock = column / BLOCK_SIZE;</span>
<span class="fc" id="L1181">        final int k = (row - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +</span>
            (column - jBlock * BLOCK_SIZE);
<span class="fc" id="L1183">        blocks[iBlock * blockColumns + jBlock][k] = value;</span>
<span class="fc" id="L1184">    }</span>

    /** {@inheritDoc} */
    @Override
    public void addToEntry(final int row, final int column,
                           final double increment)
        throws OutOfRangeException {
<span class="fc" id="L1191">        MatrixUtils.checkMatrixIndex(this, row, column);</span>
<span class="fc" id="L1192">        final int iBlock = row    / BLOCK_SIZE;</span>
<span class="fc" id="L1193">        final int jBlock = column / BLOCK_SIZE;</span>
<span class="fc" id="L1194">        final int k = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +</span>
            (column - jBlock * BLOCK_SIZE);
<span class="fc" id="L1196">        blocks[iBlock * blockColumns + jBlock][k] += increment;</span>
<span class="fc" id="L1197">    }</span>

    /** {@inheritDoc} */
    @Override
    public void multiplyEntry(final int row, final int column,
                              final double factor)
        throws OutOfRangeException {
<span class="nc" id="L1204">        MatrixUtils.checkMatrixIndex(this, row, column);</span>
<span class="nc" id="L1205">        final int iBlock = row / BLOCK_SIZE;</span>
<span class="nc" id="L1206">        final int jBlock = column / BLOCK_SIZE;</span>
<span class="nc" id="L1207">        final int k = (row - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +</span>
            (column - jBlock * BLOCK_SIZE);
<span class="nc" id="L1209">        blocks[iBlock * blockColumns + jBlock][k] *= factor;</span>
<span class="nc" id="L1210">    }</span>

    /** {@inheritDoc} */
    @Override
    public BlockRealMatrix transpose() {
<span class="fc" id="L1215">        final int nRows = getRowDimension();</span>
<span class="fc" id="L1216">        final int nCols = getColumnDimension();</span>
<span class="fc" id="L1217">        final BlockRealMatrix out = new BlockRealMatrix(nCols, nRows);</span>

        // perform transpose block-wise, to ensure good cache behavior
<span class="fc" id="L1220">        int blockIndex = 0;</span>
<span class="fc bfc" id="L1221" title="All 2 branches covered.">        for (int iBlock = 0; iBlock &lt; blockColumns; ++iBlock) {</span>
<span class="fc bfc" id="L1222" title="All 2 branches covered.">            for (int jBlock = 0; jBlock &lt; blockRows; ++jBlock) {</span>
                // transpose current block
<span class="fc" id="L1224">                final double[] outBlock = out.blocks[blockIndex];</span>
<span class="fc" id="L1225">                final double[] tBlock = blocks[jBlock * blockColumns + iBlock];</span>
<span class="fc" id="L1226">                final int pStart = iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1227">                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, columns);</span>
<span class="fc" id="L1228">                final int qStart = jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1229">                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, rows);</span>
<span class="fc" id="L1230">                int k = 0;</span>
<span class="fc bfc" id="L1231" title="All 2 branches covered.">                for (int p = pStart; p &lt; pEnd; ++p) {</span>
<span class="fc" id="L1232">                    final int lInc = pEnd - pStart;</span>
<span class="fc" id="L1233">                    int l = p - pStart;</span>
<span class="fc bfc" id="L1234" title="All 2 branches covered.">                    for (int q = qStart; q &lt; qEnd; ++q) {</span>
<span class="fc" id="L1235">                        outBlock[k] = tBlock[l];</span>
<span class="fc" id="L1236">                        ++k;</span>
<span class="fc" id="L1237">                        l+= lInc;</span>
                    }
                }
                // go to next block
<span class="fc" id="L1241">                ++blockIndex;</span>
            }
        }

<span class="fc" id="L1245">        return out;</span>
    }

    /** {@inheritDoc} */
    @Override
    public int getRowDimension() {
<span class="fc" id="L1251">        return rows;</span>
    }

    /** {@inheritDoc} */
    @Override
    public int getColumnDimension() {
<span class="fc" id="L1257">        return columns;</span>
    }

    /** {@inheritDoc} */
    @Override
    public double[] operate(final double[] v)
        throws DimensionMismatchException {
<span class="fc bfc" id="L1264" title="All 2 branches covered.">        if (v.length != columns) {</span>
<span class="fc" id="L1265">            throw new DimensionMismatchException(v.length, columns);</span>
        }
<span class="fc" id="L1267">        final double[] out = new double[rows];</span>

        // perform multiplication block-wise, to ensure good cache behavior
<span class="fc bfc" id="L1270" title="All 2 branches covered.">        for (int iBlock = 0; iBlock &lt; blockRows; ++iBlock) {</span>
<span class="fc" id="L1271">            final int pStart = iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1272">            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);</span>
<span class="fc bfc" id="L1273" title="All 2 branches covered.">            for (int jBlock = 0; jBlock &lt; blockColumns; ++jBlock) {</span>
<span class="fc" id="L1274">                final double[] block  = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc" id="L1275">                final int qStart = jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1276">                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);</span>
<span class="fc" id="L1277">                int k = 0;</span>
<span class="fc bfc" id="L1278" title="All 2 branches covered.">                for (int p = pStart; p &lt; pEnd; ++p) {</span>
<span class="fc" id="L1279">                    double sum = 0;</span>
<span class="fc" id="L1280">                    int q = qStart;</span>
<span class="fc bfc" id="L1281" title="All 2 branches covered.">                    while (q &lt; qEnd - 3) {</span>
<span class="fc" id="L1282">                        sum += block[k]     * v[q]     +</span>
                               block[k + 1] * v[q + 1] +
                               block[k + 2] * v[q + 2] +
                               block[k + 3] * v[q + 3];
<span class="fc" id="L1286">                        k += 4;</span>
<span class="fc" id="L1287">                        q += 4;</span>
                    }
<span class="fc bfc" id="L1289" title="All 2 branches covered.">                    while (q &lt; qEnd) {</span>
<span class="fc" id="L1290">                        sum += block[k++] * v[q++];</span>
                    }
<span class="fc" id="L1292">                    out[p] += sum;</span>
                }
            }
        }

<span class="fc" id="L1297">        return out;</span>
    }

    /** {@inheritDoc} */
    @Override
    public double[] preMultiply(final double[] v)
        throws DimensionMismatchException {
<span class="fc bfc" id="L1304" title="All 2 branches covered.">        if (v.length != rows) {</span>
<span class="fc" id="L1305">            throw new DimensionMismatchException(v.length, rows);</span>
        }
<span class="fc" id="L1307">        final double[] out = new double[columns];</span>

        // perform multiplication block-wise, to ensure good cache behavior
<span class="fc bfc" id="L1310" title="All 2 branches covered.">        for (int jBlock = 0; jBlock &lt; blockColumns; ++jBlock) {</span>
<span class="fc" id="L1311">            final int jWidth  = blockWidth(jBlock);</span>
<span class="fc" id="L1312">            final int jWidth2 = jWidth  + jWidth;</span>
<span class="fc" id="L1313">            final int jWidth3 = jWidth2 + jWidth;</span>
<span class="fc" id="L1314">            final int jWidth4 = jWidth3 + jWidth;</span>
<span class="fc" id="L1315">            final int qStart = jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1316">            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);</span>
<span class="fc bfc" id="L1317" title="All 2 branches covered.">            for (int iBlock = 0; iBlock &lt; blockRows; ++iBlock) {</span>
<span class="fc" id="L1318">                final double[] block  = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc" id="L1319">                final int pStart = iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1320">                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);</span>
<span class="fc bfc" id="L1321" title="All 2 branches covered.">                for (int q = qStart; q &lt; qEnd; ++q) {</span>
<span class="fc" id="L1322">                    int k = q - qStart;</span>
<span class="fc" id="L1323">                    double sum = 0;</span>
<span class="fc" id="L1324">                    int p = pStart;</span>
<span class="fc bfc" id="L1325" title="All 2 branches covered.">                    while (p &lt; pEnd - 3) {</span>
<span class="fc" id="L1326">                        sum += block[k]           * v[p]     +</span>
                               block[k + jWidth]  * v[p + 1] +
                               block[k + jWidth2] * v[p + 2] +
                               block[k + jWidth3] * v[p + 3];
<span class="fc" id="L1330">                        k += jWidth4;</span>
<span class="fc" id="L1331">                        p += 4;</span>
                    }
<span class="fc bfc" id="L1333" title="All 2 branches covered.">                    while (p &lt; pEnd) {</span>
<span class="fc" id="L1334">                        sum += block[k] * v[p++];</span>
<span class="fc" id="L1335">                        k += jWidth;</span>
                    }
<span class="fc" id="L1337">                    out[q] += sum;</span>
                }
            }
        }

<span class="fc" id="L1342">        return out;</span>
    }

    /** {@inheritDoc} */
    @Override
    public double walkInRowOrder(final RealMatrixChangingVisitor visitor) {
<span class="fc" id="L1348">        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);</span>
<span class="fc bfc" id="L1349" title="All 2 branches covered.">        for (int iBlock = 0; iBlock &lt; blockRows; ++iBlock) {</span>
<span class="fc" id="L1350">            final int pStart = iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1351">            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);</span>
<span class="fc bfc" id="L1352" title="All 2 branches covered.">            for (int p = pStart; p &lt; pEnd; ++p) {</span>
<span class="fc bfc" id="L1353" title="All 2 branches covered.">                for (int jBlock = 0; jBlock &lt; blockColumns; ++jBlock) {</span>
<span class="fc" id="L1354">                    final int jWidth = blockWidth(jBlock);</span>
<span class="fc" id="L1355">                    final int qStart = jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1356">                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);</span>
<span class="fc" id="L1357">                    final double[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc" id="L1358">                    int k = (p - pStart) * jWidth;</span>
<span class="fc bfc" id="L1359" title="All 2 branches covered.">                    for (int q = qStart; q &lt; qEnd; ++q) {</span>
<span class="fc" id="L1360">                        block[k] = visitor.visit(p, q, block[k]);</span>
<span class="fc" id="L1361">                        ++k;</span>
                    }
                }
             }
        }
<span class="fc" id="L1366">        return visitor.end();</span>
    }

    /** {@inheritDoc} */
    @Override
    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor) {
<span class="fc" id="L1372">        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);</span>
<span class="fc bfc" id="L1373" title="All 2 branches covered.">        for (int iBlock = 0; iBlock &lt; blockRows; ++iBlock) {</span>
<span class="fc" id="L1374">            final int pStart = iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1375">            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);</span>
<span class="fc bfc" id="L1376" title="All 2 branches covered.">            for (int p = pStart; p &lt; pEnd; ++p) {</span>
<span class="fc bfc" id="L1377" title="All 2 branches covered.">                for (int jBlock = 0; jBlock &lt; blockColumns; ++jBlock) {</span>
<span class="fc" id="L1378">                    final int jWidth = blockWidth(jBlock);</span>
<span class="fc" id="L1379">                    final int qStart = jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1380">                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);</span>
<span class="fc" id="L1381">                    final double[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc" id="L1382">                    int k = (p - pStart) * jWidth;</span>
<span class="fc bfc" id="L1383" title="All 2 branches covered.">                    for (int q = qStart; q &lt; qEnd; ++q) {</span>
<span class="fc" id="L1384">                        visitor.visit(p, q, block[k]);</span>
<span class="fc" id="L1385">                        ++k;</span>
                    }
                }
             }
        }
<span class="fc" id="L1390">        return visitor.end();</span>
    }

    /** {@inheritDoc} */
    @Override
    public double walkInRowOrder(final RealMatrixChangingVisitor visitor,
                                 final int startRow, final int endRow,
                                 final int startColumn, final int endColumn)
        throws OutOfRangeException, NumberIsTooSmallException {
<span class="fc" id="L1399">        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);</span>
<span class="fc" id="L1400">        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);</span>
<span class="fc bfc" id="L1401" title="All 2 branches covered.">        for (int iBlock = startRow / BLOCK_SIZE; iBlock &lt; 1 + endRow / BLOCK_SIZE; ++iBlock) {</span>
<span class="fc" id="L1402">            final int p0 = iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1403">            final int pStart = FastMath.max(startRow, p0);</span>
<span class="fc" id="L1404">            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);</span>
<span class="fc bfc" id="L1405" title="All 2 branches covered.">            for (int p = pStart; p &lt; pEnd; ++p) {</span>
<span class="fc bfc" id="L1406" title="All 2 branches covered.">                for (int jBlock = startColumn / BLOCK_SIZE; jBlock &lt; 1 + endColumn / BLOCK_SIZE; ++jBlock) {</span>
<span class="fc" id="L1407">                    final int jWidth = blockWidth(jBlock);</span>
<span class="fc" id="L1408">                    final int q0 = jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1409">                    final int qStart = FastMath.max(startColumn, q0);</span>
<span class="fc" id="L1410">                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);</span>
<span class="fc" id="L1411">                    final double[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc" id="L1412">                    int k = (p - p0) * jWidth + qStart - q0;</span>
<span class="fc bfc" id="L1413" title="All 2 branches covered.">                    for (int q = qStart; q &lt; qEnd; ++q) {</span>
<span class="fc" id="L1414">                        block[k] = visitor.visit(p, q, block[k]);</span>
<span class="fc" id="L1415">                        ++k;</span>
                    }
                }
             }
        }
<span class="fc" id="L1420">        return visitor.end();</span>
    }

    /** {@inheritDoc} */
    @Override
    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,
                                 final int startRow, final int endRow,
                                 final int startColumn, final int endColumn)
        throws OutOfRangeException, NumberIsTooSmallException {
<span class="fc" id="L1429">        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);</span>
<span class="fc" id="L1430">        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);</span>
<span class="fc bfc" id="L1431" title="All 2 branches covered.">        for (int iBlock = startRow / BLOCK_SIZE; iBlock &lt; 1 + endRow / BLOCK_SIZE; ++iBlock) {</span>
<span class="fc" id="L1432">            final int p0 = iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1433">            final int pStart = FastMath.max(startRow, p0);</span>
<span class="fc" id="L1434">            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);</span>
<span class="fc bfc" id="L1435" title="All 2 branches covered.">            for (int p = pStart; p &lt; pEnd; ++p) {</span>
<span class="fc bfc" id="L1436" title="All 2 branches covered.">                for (int jBlock = startColumn / BLOCK_SIZE; jBlock &lt; 1 + endColumn / BLOCK_SIZE; ++jBlock) {</span>
<span class="fc" id="L1437">                    final int jWidth = blockWidth(jBlock);</span>
<span class="fc" id="L1438">                    final int q0 = jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1439">                    final int qStart = FastMath.max(startColumn, q0);</span>
<span class="fc" id="L1440">                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);</span>
<span class="fc" id="L1441">                    final double[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc" id="L1442">                    int k = (p - p0) * jWidth + qStart - q0;</span>
<span class="fc bfc" id="L1443" title="All 2 branches covered.">                    for (int q = qStart; q &lt; qEnd; ++q) {</span>
<span class="fc" id="L1444">                        visitor.visit(p, q, block[k]);</span>
<span class="fc" id="L1445">                        ++k;</span>
                    }
                }
             }
        }
<span class="fc" id="L1450">        return visitor.end();</span>
    }

    /** {@inheritDoc} */
    @Override
    public double walkInOptimizedOrder(final RealMatrixChangingVisitor visitor) {
<span class="fc" id="L1456">        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);</span>
<span class="fc" id="L1457">        int blockIndex = 0;</span>
<span class="fc bfc" id="L1458" title="All 2 branches covered.">        for (int iBlock = 0; iBlock &lt; blockRows; ++iBlock) {</span>
<span class="fc" id="L1459">            final int pStart = iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1460">            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);</span>
<span class="fc bfc" id="L1461" title="All 2 branches covered.">            for (int jBlock = 0; jBlock &lt; blockColumns; ++jBlock) {</span>
<span class="fc" id="L1462">                final int qStart = jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1463">                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);</span>
<span class="fc" id="L1464">                final double[] block = blocks[blockIndex];</span>
<span class="fc" id="L1465">                int k = 0;</span>
<span class="fc bfc" id="L1466" title="All 2 branches covered.">                for (int p = pStart; p &lt; pEnd; ++p) {</span>
<span class="fc bfc" id="L1467" title="All 2 branches covered.">                    for (int q = qStart; q &lt; qEnd; ++q) {</span>
<span class="fc" id="L1468">                        block[k] = visitor.visit(p, q, block[k]);</span>
<span class="fc" id="L1469">                        ++k;</span>
                    }
                }
<span class="fc" id="L1472">                ++blockIndex;</span>
            }
        }
<span class="fc" id="L1475">        return visitor.end();</span>
    }

    /** {@inheritDoc} */
    @Override
    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor) {
<span class="fc" id="L1481">        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);</span>
<span class="fc" id="L1482">        int blockIndex = 0;</span>
<span class="fc bfc" id="L1483" title="All 2 branches covered.">        for (int iBlock = 0; iBlock &lt; blockRows; ++iBlock) {</span>
<span class="fc" id="L1484">            final int pStart = iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1485">            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);</span>
<span class="fc bfc" id="L1486" title="All 2 branches covered.">            for (int jBlock = 0; jBlock &lt; blockColumns; ++jBlock) {</span>
<span class="fc" id="L1487">                final int qStart = jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1488">                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);</span>
<span class="fc" id="L1489">                final double[] block = blocks[blockIndex];</span>
<span class="fc" id="L1490">                int k = 0;</span>
<span class="fc bfc" id="L1491" title="All 2 branches covered.">                for (int p = pStart; p &lt; pEnd; ++p) {</span>
<span class="fc bfc" id="L1492" title="All 2 branches covered.">                    for (int q = qStart; q &lt; qEnd; ++q) {</span>
<span class="fc" id="L1493">                        visitor.visit(p, q, block[k]);</span>
<span class="fc" id="L1494">                        ++k;</span>
                    }
                }
<span class="fc" id="L1497">                ++blockIndex;</span>
            }
        }
<span class="fc" id="L1500">        return visitor.end();</span>
    }

    /** {@inheritDoc} */
    @Override
    public double walkInOptimizedOrder(final RealMatrixChangingVisitor visitor,
                                       final int startRow, final int endRow,
                                       final int startColumn,
                                       final int endColumn)
        throws OutOfRangeException, NumberIsTooSmallException {
<span class="fc" id="L1510">        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);</span>
<span class="fc" id="L1511">        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);</span>
<span class="fc bfc" id="L1512" title="All 2 branches covered.">        for (int iBlock = startRow / BLOCK_SIZE; iBlock &lt; 1 + endRow / BLOCK_SIZE; ++iBlock) {</span>
<span class="fc" id="L1513">            final int p0 = iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1514">            final int pStart = FastMath.max(startRow, p0);</span>
<span class="fc" id="L1515">            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);</span>
<span class="fc bfc" id="L1516" title="All 2 branches covered.">            for (int jBlock = startColumn / BLOCK_SIZE; jBlock &lt; 1 + endColumn / BLOCK_SIZE; ++jBlock) {</span>
<span class="fc" id="L1517">                final int jWidth = blockWidth(jBlock);</span>
<span class="fc" id="L1518">                final int q0 = jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1519">                final int qStart = FastMath.max(startColumn, q0);</span>
<span class="fc" id="L1520">                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);</span>
<span class="fc" id="L1521">                final double[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc bfc" id="L1522" title="All 2 branches covered.">                for (int p = pStart; p &lt; pEnd; ++p) {</span>
<span class="fc" id="L1523">                    int k = (p - p0) * jWidth + qStart - q0;</span>
<span class="fc bfc" id="L1524" title="All 2 branches covered.">                    for (int q = qStart; q &lt; qEnd; ++q) {</span>
<span class="fc" id="L1525">                        block[k] = visitor.visit(p, q, block[k]);</span>
<span class="fc" id="L1526">                        ++k;</span>
                    }
                }
            }
        }
<span class="fc" id="L1531">        return visitor.end();</span>
    }

    /** {@inheritDoc} */
    @Override
    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,
                                       final int startRow, final int endRow,
                                       final int startColumn,
                                       final int endColumn)
        throws OutOfRangeException, NumberIsTooSmallException {
<span class="fc" id="L1541">        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);</span>
<span class="fc" id="L1542">        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);</span>
<span class="fc bfc" id="L1543" title="All 2 branches covered.">        for (int iBlock = startRow / BLOCK_SIZE; iBlock &lt; 1 + endRow / BLOCK_SIZE; ++iBlock) {</span>
<span class="fc" id="L1544">            final int p0 = iBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1545">            final int pStart = FastMath.max(startRow, p0);</span>
<span class="fc" id="L1546">            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);</span>
<span class="fc bfc" id="L1547" title="All 2 branches covered.">            for (int jBlock = startColumn / BLOCK_SIZE; jBlock &lt; 1 + endColumn / BLOCK_SIZE; ++jBlock) {</span>
<span class="fc" id="L1548">                final int jWidth = blockWidth(jBlock);</span>
<span class="fc" id="L1549">                final int q0 = jBlock * BLOCK_SIZE;</span>
<span class="fc" id="L1550">                final int qStart = FastMath.max(startColumn, q0);</span>
<span class="fc" id="L1551">                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);</span>
<span class="fc" id="L1552">                final double[] block = blocks[iBlock * blockColumns + jBlock];</span>
<span class="fc bfc" id="L1553" title="All 2 branches covered.">                for (int p = pStart; p &lt; pEnd; ++p) {</span>
<span class="fc" id="L1554">                    int k = (p - p0) * jWidth + qStart - q0;</span>
<span class="fc bfc" id="L1555" title="All 2 branches covered.">                    for (int q = qStart; q &lt; qEnd; ++q) {</span>
<span class="fc" id="L1556">                        visitor.visit(p, q, block[k]);</span>
<span class="fc" id="L1557">                        ++k;</span>
                    }
                }
            }
        }
<span class="fc" id="L1562">        return visitor.end();</span>
    }

    /**
     * Get the height of a block.
     * @param blockRow row index (in block sense) of the block
     * @return height (number of rows) of the block
     */
    private int blockHeight(final int blockRow) {
<span class="fc bfc" id="L1571" title="All 2 branches covered.">        return (blockRow == blockRows - 1) ? rows - blockRow * BLOCK_SIZE : BLOCK_SIZE;</span>
    }

    /**
     * Get the width of a block.
     * @param blockColumn column index (in block sense) of the block
     * @return width (number of columns) of the block
     */
    private int blockWidth(final int blockColumn) {
<span class="fc bfc" id="L1580" title="All 2 branches covered.">        return (blockColumn == blockColumns - 1) ? columns - blockColumn * BLOCK_SIZE : BLOCK_SIZE;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>