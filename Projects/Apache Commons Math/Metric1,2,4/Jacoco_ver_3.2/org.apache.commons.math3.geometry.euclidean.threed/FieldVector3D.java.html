<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FieldVector3D.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Commons Math</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math3.geometry.euclidean.threed</a> &gt; <span class="el_source">FieldVector3D.java</span></div><h1>FieldVector3D.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.math3.geometry.euclidean.threed;

import java.io.Serializable;
import java.text.NumberFormat;

import org.apache.commons.math3.RealFieldElement;
import org.apache.commons.math3.exception.DimensionMismatchException;
import org.apache.commons.math3.exception.MathArithmeticException;
import org.apache.commons.math3.exception.util.LocalizedFormats;
import org.apache.commons.math3.util.FastMath;
import org.apache.commons.math3.util.MathArrays;

/**
 * This class is a re-implementation of {@link Vector3D} using {@link RealFieldElement}.
 * &lt;p&gt;Instance of this class are guaranteed to be immutable.&lt;/p&gt;
 * @param &lt;T&gt; the type of the field elements
 * @version $Id$
 * @since 3.2
 */
public class FieldVector3D&lt;T extends RealFieldElement&lt;T&gt;&gt; implements Serializable {

    /** Serializable version identifier. */
    private static final long serialVersionUID = 20130224L;

    /** Abscissa. */
    private final T x;

    /** Ordinate. */
    private final T y;

    /** Height. */
    private final T z;

    /** Simple constructor.
     * Build a vector from its coordinates
     * @param x abscissa
     * @param y ordinate
     * @param z height
     * @see #getX()
     * @see #getY()
     * @see #getZ()
     */
<span class="fc" id="L60">    public FieldVector3D(final T x, final T y, final T z) {</span>
<span class="fc" id="L61">        this.x = x;</span>
<span class="fc" id="L62">        this.y = y;</span>
<span class="fc" id="L63">        this.z = z;</span>
<span class="fc" id="L64">    }</span>

    /** Simple constructor.
     * Build a vector from its coordinates
     * @param v coordinates array
     * @exception DimensionMismatchException if array does not have 3 elements
     * @see #toArray()
     */
<span class="fc" id="L72">    public FieldVector3D(final T[] v) throws DimensionMismatchException {</span>
<span class="fc bfc" id="L73" title="All 2 branches covered.">        if (v.length != 3) {</span>
<span class="fc" id="L74">            throw new DimensionMismatchException(v.length, 3);</span>
        }
<span class="fc" id="L76">        this.x = v[0];</span>
<span class="fc" id="L77">        this.y = v[1];</span>
<span class="fc" id="L78">        this.z = v[2];</span>
<span class="fc" id="L79">    }</span>

    /** Simple constructor.
     * Build a vector from its azimuthal coordinates
     * @param alpha azimuth (&amp;alpha;) around Z
     *              (0 is +X, &amp;pi;/2 is +Y, &amp;pi; is -X and 3&amp;pi;/2 is -Y)
     * @param delta elevation (&amp;delta;) above (XY) plane, from -&amp;pi;/2 to +&amp;pi;/2
     * @see #getAlpha()
     * @see #getDelta()
     */
<span class="fc" id="L89">    public FieldVector3D(final T alpha, final T delta) {</span>
<span class="fc" id="L90">        T cosDelta = delta.cos();</span>
<span class="fc" id="L91">        this.x = alpha.cos().multiply(cosDelta);</span>
<span class="fc" id="L92">        this.y = alpha.sin().multiply(cosDelta);</span>
<span class="fc" id="L93">        this.z = delta.sin();</span>
<span class="fc" id="L94">    }</span>

    /** Multiplicative constructor
     * Build a vector from another one and a scale factor.
     * The vector built will be a * u
     * @param a scale factor
     * @param u base (unscaled) vector
     */
<span class="fc" id="L102">    public FieldVector3D(final T a, final FieldVector3D&lt;T&gt;u) {</span>
<span class="fc" id="L103">        this.x = a.multiply(u.x);</span>
<span class="fc" id="L104">        this.y = a.multiply(u.y);</span>
<span class="fc" id="L105">        this.z = a.multiply(u.z);</span>
<span class="fc" id="L106">    }</span>

    /** Multiplicative constructor
     * Build a vector from another one and a scale factor.
     * The vector built will be a * u
     * @param a scale factor
     * @param u base (unscaled) vector
     */
<span class="fc" id="L114">    public FieldVector3D(final T a, final Vector3D u) {</span>
<span class="fc" id="L115">        this.x = a.multiply(u.getX());</span>
<span class="fc" id="L116">        this.y = a.multiply(u.getY());</span>
<span class="fc" id="L117">        this.z = a.multiply(u.getZ());</span>
<span class="fc" id="L118">    }</span>

    /** Multiplicative constructor
     * Build a vector from another one and a scale factor.
     * The vector built will be a * u
     * @param a scale factor
     * @param u base (unscaled) vector
     */
<span class="fc" id="L126">    public FieldVector3D(final double a, final FieldVector3D&lt;T&gt; u) {</span>
<span class="fc" id="L127">        this.x = u.x.multiply(a);</span>
<span class="fc" id="L128">        this.y = u.y.multiply(a);</span>
<span class="fc" id="L129">        this.z = u.z.multiply(a);</span>
<span class="fc" id="L130">    }</span>

    /** Linear constructor
     * Build a vector from two other ones and corresponding scale factors.
     * The vector built will be a1 * u1 + a2 * u2
     * @param a1 first scale factor
     * @param u1 first base (unscaled) vector
     * @param a2 second scale factor
     * @param u2 second base (unscaled) vector
     */
    public FieldVector3D(final T a1, final FieldVector3D&lt;T&gt; u1,
<span class="fc" id="L141">                         final T a2, final FieldVector3D&lt;T&gt; u2) {</span>
<span class="fc" id="L142">        final T prototype = a1;</span>
<span class="fc" id="L143">        this.x = prototype.linearCombination(a1, u1.getX(), a2, u2.getX());</span>
<span class="fc" id="L144">        this.y = prototype.linearCombination(a1, u1.getY(), a2, u2.getY());</span>
<span class="fc" id="L145">        this.z = prototype.linearCombination(a1, u1.getZ(), a2, u2.getZ());</span>
<span class="fc" id="L146">    }</span>

    /** Linear constructor
     * Build a vector from two other ones and corresponding scale factors.
     * The vector built will be a1 * u1 + a2 * u2
     * @param a1 first scale factor
     * @param u1 first base (unscaled) vector
     * @param a2 second scale factor
     * @param u2 second base (unscaled) vector
     */
    public FieldVector3D(final T a1, final Vector3D u1,
<span class="fc" id="L157">                         final T a2, final Vector3D u2) {</span>
<span class="fc" id="L158">        final T prototype = a1;</span>
<span class="fc" id="L159">        this.x = prototype.linearCombination(u1.getX(), a1, u2.getX(), a2);</span>
<span class="fc" id="L160">        this.y = prototype.linearCombination(u1.getY(), a1, u2.getY(), a2);</span>
<span class="fc" id="L161">        this.z = prototype.linearCombination(u1.getZ(), a1, u2.getZ(), a2);</span>
<span class="fc" id="L162">    }</span>

    /** Linear constructor
     * Build a vector from two other ones and corresponding scale factors.
     * The vector built will be a1 * u1 + a2 * u2
     * @param a1 first scale factor
     * @param u1 first base (unscaled) vector
     * @param a2 second scale factor
     * @param u2 second base (unscaled) vector
     */
    public FieldVector3D(final double a1, final FieldVector3D&lt;T&gt; u1,
<span class="fc" id="L173">                         final double a2, final FieldVector3D&lt;T&gt; u2) {</span>
<span class="fc" id="L174">        final T prototype = u1.getX();</span>
<span class="fc" id="L175">        this.x = prototype.linearCombination(a1, u1.getX(), a2, u2.getX());</span>
<span class="fc" id="L176">        this.y = prototype.linearCombination(a1, u1.getY(), a2, u2.getY());</span>
<span class="fc" id="L177">        this.z = prototype.linearCombination(a1, u1.getZ(), a2, u2.getZ());</span>
<span class="fc" id="L178">    }</span>

    /** Linear constructor
     * Build a vector from three other ones and corresponding scale factors.
     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3
     * @param a1 first scale factor
     * @param u1 first base (unscaled) vector
     * @param a2 second scale factor
     * @param u2 second base (unscaled) vector
     * @param a3 third scale factor
     * @param u3 third base (unscaled) vector
     */
    public FieldVector3D(final T a1, final FieldVector3D&lt;T&gt; u1,
                         final T a2, final FieldVector3D&lt;T&gt; u2,
<span class="fc" id="L192">                         final T a3, final FieldVector3D&lt;T&gt; u3) {</span>
<span class="fc" id="L193">        final T prototype = a1;</span>
<span class="fc" id="L194">        this.x = prototype.linearCombination(a1, u1.getX(), a2, u2.getX(), a3, u3.getX());</span>
<span class="fc" id="L195">        this.y = prototype.linearCombination(a1, u1.getY(), a2, u2.getY(), a3, u3.getY());</span>
<span class="fc" id="L196">        this.z = prototype.linearCombination(a1, u1.getZ(), a2, u2.getZ(), a3, u3.getZ());</span>
<span class="fc" id="L197">    }</span>

    /** Linear constructor
     * Build a vector from three other ones and corresponding scale factors.
     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3
     * @param a1 first scale factor
     * @param u1 first base (unscaled) vector
     * @param a2 second scale factor
     * @param u2 second base (unscaled) vector
     * @param a3 third scale factor
     * @param u3 third base (unscaled) vector
     */
    public FieldVector3D(final T a1, final Vector3D u1,
                         final T a2, final Vector3D u2,
<span class="fc" id="L211">                         final T a3, final Vector3D u3) {</span>
<span class="fc" id="L212">        final T prototype = a1;</span>
<span class="fc" id="L213">        this.x = prototype.linearCombination(u1.getX(), a1, u2.getX(), a2, u3.getX(), a3);</span>
<span class="fc" id="L214">        this.y = prototype.linearCombination(u1.getY(), a1, u2.getY(), a2, u3.getY(), a3);</span>
<span class="fc" id="L215">        this.z = prototype.linearCombination(u1.getZ(), a1, u2.getZ(), a2, u3.getZ(), a3);</span>
<span class="fc" id="L216">    }</span>

    /** Linear constructor
     * Build a vector from three other ones and corresponding scale factors.
     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3
     * @param a1 first scale factor
     * @param u1 first base (unscaled) vector
     * @param a2 second scale factor
     * @param u2 second base (unscaled) vector
     * @param a3 third scale factor
     * @param u3 third base (unscaled) vector
     */
    public FieldVector3D(final double a1, final FieldVector3D&lt;T&gt; u1,
                         final double a2, final FieldVector3D&lt;T&gt; u2,
<span class="fc" id="L230">                         final double a3, final FieldVector3D&lt;T&gt; u3) {</span>
<span class="fc" id="L231">        final T prototype = u1.getX();</span>
<span class="fc" id="L232">        this.x = prototype.linearCombination(a1, u1.getX(), a2, u2.getX(), a3, u3.getX());</span>
<span class="fc" id="L233">        this.y = prototype.linearCombination(a1, u1.getY(), a2, u2.getY(), a3, u3.getY());</span>
<span class="fc" id="L234">        this.z = prototype.linearCombination(a1, u1.getZ(), a2, u2.getZ(), a3, u3.getZ());</span>
<span class="fc" id="L235">    }</span>

    /** Linear constructor
     * Build a vector from four other ones and corresponding scale factors.
     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4
     * @param a1 first scale factor
     * @param u1 first base (unscaled) vector
     * @param a2 second scale factor
     * @param u2 second base (unscaled) vector
     * @param a3 third scale factor
     * @param u3 third base (unscaled) vector
     * @param a4 fourth scale factor
     * @param u4 fourth base (unscaled) vector
     */
    public FieldVector3D(final T a1, final FieldVector3D&lt;T&gt; u1,
                         final T a2, final FieldVector3D&lt;T&gt; u2,
                         final T a3, final FieldVector3D&lt;T&gt; u3,
<span class="fc" id="L252">                         final T a4, final FieldVector3D&lt;T&gt; u4) {</span>
<span class="fc" id="L253">        final T prototype = a1;</span>
<span class="fc" id="L254">        this.x = prototype.linearCombination(a1, u1.getX(), a2, u2.getX(), a3, u3.getX(), a4, u4.getX());</span>
<span class="fc" id="L255">        this.y = prototype.linearCombination(a1, u1.getY(), a2, u2.getY(), a3, u3.getY(), a4, u4.getY());</span>
<span class="fc" id="L256">        this.z = prototype.linearCombination(a1, u1.getZ(), a2, u2.getZ(), a3, u3.getZ(), a4, u4.getZ());</span>
<span class="fc" id="L257">    }</span>

    /** Linear constructor
     * Build a vector from four other ones and corresponding scale factors.
     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4
     * @param a1 first scale factor
     * @param u1 first base (unscaled) vector
     * @param a2 second scale factor
     * @param u2 second base (unscaled) vector
     * @param a3 third scale factor
     * @param u3 third base (unscaled) vector
     * @param a4 fourth scale factor
     * @param u4 fourth base (unscaled) vector
     */
    public FieldVector3D(final T a1, final Vector3D u1,
                         final T a2, final Vector3D u2,
                         final T a3, final Vector3D u3,
<span class="fc" id="L274">                         final T a4, final Vector3D u4) {</span>
<span class="fc" id="L275">        final T prototype = a1;</span>
<span class="fc" id="L276">        this.x = prototype.linearCombination(u1.getX(), a1, u2.getX(), a2, u3.getX(), a3, u4.getX(), a4);</span>
<span class="fc" id="L277">        this.y = prototype.linearCombination(u1.getY(), a1, u2.getY(), a2, u3.getY(), a3, u4.getY(), a4);</span>
<span class="fc" id="L278">        this.z = prototype.linearCombination(u1.getZ(), a1, u2.getZ(), a2, u3.getZ(), a3, u4.getZ(), a4);</span>
<span class="fc" id="L279">    }</span>

    /** Linear constructor
     * Build a vector from four other ones and corresponding scale factors.
     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4
     * @param a1 first scale factor
     * @param u1 first base (unscaled) vector
     * @param a2 second scale factor
     * @param u2 second base (unscaled) vector
     * @param a3 third scale factor
     * @param u3 third base (unscaled) vector
     * @param a4 fourth scale factor
     * @param u4 fourth base (unscaled) vector
     */
    public FieldVector3D(final double a1, final FieldVector3D&lt;T&gt; u1,
                         final double a2, final FieldVector3D&lt;T&gt; u2,
                         final double a3, final FieldVector3D&lt;T&gt; u3,
<span class="fc" id="L296">                         final double a4, final FieldVector3D&lt;T&gt; u4) {</span>
<span class="fc" id="L297">        final T prototype = u1.getX();</span>
<span class="fc" id="L298">        this.x = prototype.linearCombination(a1, u1.getX(), a2, u2.getX(), a3, u3.getX(), a4, u4.getX());</span>
<span class="fc" id="L299">        this.y = prototype.linearCombination(a1, u1.getY(), a2, u2.getY(), a3, u3.getY(), a4, u4.getY());</span>
<span class="fc" id="L300">        this.z = prototype.linearCombination(a1, u1.getZ(), a2, u2.getZ(), a3, u3.getZ(), a4, u4.getZ());</span>
<span class="fc" id="L301">    }</span>

    /** Get the abscissa of the vector.
     * @return abscissa of the vector
     * @see #FieldVector3D(RealFieldElement, RealFieldElement, RealFieldElement)
     */
    public T getX() {
<span class="fc" id="L308">        return x;</span>
    }

    /** Get the ordinate of the vector.
     * @return ordinate of the vector
     * @see #FieldVector3D(RealFieldElement, RealFieldElement, RealFieldElement)
     */
    public T getY() {
<span class="fc" id="L316">        return y;</span>
    }

    /** Get the height of the vector.
     * @return height of the vector
     * @see #FieldVector3D(RealFieldElement, RealFieldElement, RealFieldElement)
     */
    public T getZ() {
<span class="fc" id="L324">        return z;</span>
    }

    /** Get the vector coordinates as a dimension 3 array.
     * @return vector coordinates
     * @see #FieldVector3D(RealFieldElement[])
     */
    public T[] toArray() {
<span class="fc" id="L332">        final T[] array = MathArrays.buildArray(x.getField(), 3);</span>
<span class="fc" id="L333">        array[0] = x;</span>
<span class="fc" id="L334">        array[1] = y;</span>
<span class="fc" id="L335">        array[2] = z;</span>
<span class="fc" id="L336">        return array;</span>
    }

    /** Convert to a constant vector without derivatives.
     * @return a constant vector
     */
    public Vector3D toVector3D() {
<span class="fc" id="L343">        return new Vector3D(x.getReal(), y.getReal(), z.getReal());</span>
    }

    /** Get the L&lt;sub&gt;1&lt;/sub&gt; norm for the vector.
     * @return L&lt;sub&gt;1&lt;/sub&gt; norm for the vector
     */
    public T getNorm1() {
<span class="fc" id="L350">        return x.abs().add(y.abs()).add(z.abs());</span>
    }

    /** Get the L&lt;sub&gt;2&lt;/sub&gt; norm for the vector.
     * @return Euclidean norm for the vector
     */
    public T getNorm() {
        // there are no cancellation problems here, so we use the straightforward formula
<span class="fc" id="L358">        return x.multiply(x).add(y.multiply(y)).add(z.multiply(z)).sqrt();</span>
    }

    /** Get the square of the norm for the vector.
     * @return square of the Euclidean norm for the vector
     */
    public T getNormSq() {
        // there are no cancellation problems here, so we use the straightforward formula
<span class="fc" id="L366">        return x.multiply(x).add(y.multiply(y)).add(z.multiply(z));</span>
    }

    /** Get the L&lt;sub&gt;&amp;infin;&lt;/sub&gt; norm for the vector.
     * @return L&lt;sub&gt;&amp;infin;&lt;/sub&gt; norm for the vector
     */
    public T getNormInf() {
<span class="fc" id="L373">        final T xAbs = x.abs();</span>
<span class="fc" id="L374">        final T yAbs = y.abs();</span>
<span class="fc" id="L375">        final T zAbs = z.abs();</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">        if (xAbs.getReal() &lt;= yAbs.getReal()) {</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">            if (yAbs.getReal() &lt;= zAbs.getReal()) {</span>
<span class="fc" id="L378">                return zAbs;</span>
            } else {
<span class="fc" id="L380">                return yAbs;</span>
            }
        } else {
<span class="fc bfc" id="L383" title="All 2 branches covered.">            if (xAbs.getReal() &lt;= zAbs.getReal()) {</span>
<span class="fc" id="L384">                return zAbs;</span>
            } else {
<span class="fc" id="L386">                return xAbs;</span>
            }
        }
    }

    /** Get the azimuth of the vector.
     * @return azimuth (&amp;alpha;) of the vector, between -&amp;pi; and +&amp;pi;
     * @see #FieldVector3D(RealFieldElement, RealFieldElement)
     */
    public T getAlpha() {
<span class="fc" id="L396">        return y.atan2(x);</span>
    }

    /** Get the elevation of the vector.
     * @return elevation (&amp;delta;) of the vector, between -&amp;pi;/2 and +&amp;pi;/2
     * @see #FieldVector3D(RealFieldElement, RealFieldElement)
     */
    public T getDelta() {
<span class="fc" id="L404">        return z.divide(getNorm()).asin();</span>
    }

    /** Add a vector to the instance.
     * @param v vector to add
     * @return a new vector
     */
    public FieldVector3D&lt;T&gt; add(final FieldVector3D&lt;T&gt; v) {
<span class="fc" id="L412">        return new FieldVector3D&lt;T&gt;(x.add(v.x), y.add(v.y), z.add(v.z));</span>
    }

    /** Add a vector to the instance.
     * @param v vector to add
     * @return a new vector
     */
    public FieldVector3D&lt;T&gt; add(final Vector3D v) {
<span class="fc" id="L420">        return new FieldVector3D&lt;T&gt;(x.add(v.getX()), y.add(v.getY()), z.add(v.getZ()));</span>
    }

    /** Add a scaled vector to the instance.
     * @param factor scale factor to apply to v before adding it
     * @param v vector to add
     * @return a new vector
     */
    public FieldVector3D&lt;T&gt; add(final T factor, final FieldVector3D&lt;T&gt; v) {
<span class="fc" id="L429">        return new FieldVector3D&lt;T&gt;(x.getField().getOne(), this, factor, v);</span>
    }

    /** Add a scaled vector to the instance.
     * @param factor scale factor to apply to v before adding it
     * @param v vector to add
     * @return a new vector
     */
    public FieldVector3D&lt;T&gt; add(final T factor, final Vector3D v) {
<span class="fc" id="L438">        return new FieldVector3D&lt;T&gt;(x.add(factor.multiply(v.getX())),</span>
<span class="fc" id="L439">                                    y.add(factor.multiply(v.getY())),</span>
<span class="fc" id="L440">                                    z.add(factor.multiply(v.getZ())));</span>
    }

    /** Add a scaled vector to the instance.
     * @param factor scale factor to apply to v before adding it
     * @param v vector to add
     * @return a new vector
     */
    public FieldVector3D&lt;T&gt; add(final double factor, final FieldVector3D&lt;T&gt; v) {
<span class="fc" id="L449">        return new FieldVector3D&lt;T&gt;(1.0, this, factor, v);</span>
    }

    /** Add a scaled vector to the instance.
     * @param factor scale factor to apply to v before adding it
     * @param v vector to add
     * @return a new vector
     */
    public FieldVector3D&lt;T&gt; add(final double factor, final Vector3D v) {
<span class="fc" id="L458">        return new FieldVector3D&lt;T&gt;(x.add(factor * v.getX()),</span>
<span class="fc" id="L459">                                    y.add(factor * v.getY()),</span>
<span class="fc" id="L460">                                    z.add(factor * v.getZ()));</span>
    }

    /** Subtract a vector from the instance.
     * @param v vector to subtract
     * @return a new vector
     */
    public FieldVector3D&lt;T&gt; subtract(final FieldVector3D&lt;T&gt; v) {
<span class="fc" id="L468">        return new FieldVector3D&lt;T&gt;(x.subtract(v.x), y.subtract(v.y), z.subtract(v.z));</span>
    }

    /** Subtract a vector from the instance.
     * @param v vector to subtract
     * @return a new vector
     */
    public FieldVector3D&lt;T&gt; subtract(final Vector3D v) {
<span class="fc" id="L476">        return new FieldVector3D&lt;T&gt;(x.subtract(v.getX()), y.subtract(v.getY()), z.subtract(v.getZ()));</span>
    }

    /** Subtract a scaled vector from the instance.
     * @param factor scale factor to apply to v before subtracting it
     * @param v vector to subtract
     * @return a new vector
     */
    public FieldVector3D&lt;T&gt; subtract(final T factor, final FieldVector3D&lt;T&gt; v) {
<span class="fc" id="L485">        return new FieldVector3D&lt;T&gt;(x.getField().getOne(), this, factor.negate(), v);</span>
    }

    /** Subtract a scaled vector from the instance.
     * @param factor scale factor to apply to v before subtracting it
     * @param v vector to subtract
     * @return a new vector
     */
    public FieldVector3D&lt;T&gt; subtract(final T factor, final Vector3D v) {
<span class="fc" id="L494">        return new FieldVector3D&lt;T&gt;(x.subtract(factor.multiply(v.getX())),</span>
<span class="fc" id="L495">                                    y.subtract(factor.multiply(v.getY())),</span>
<span class="fc" id="L496">                                    z.subtract(factor.multiply(v.getZ())));</span>
    }

    /** Subtract a scaled vector from the instance.
     * @param factor scale factor to apply to v before subtracting it
     * @param v vector to subtract
     * @return a new vector
     */
    public FieldVector3D&lt;T&gt; subtract(final double factor, final FieldVector3D&lt;T&gt; v) {
<span class="fc" id="L505">        return new FieldVector3D&lt;T&gt;(1.0, this, -factor, v);</span>
    }

    /** Subtract a scaled vector from the instance.
     * @param factor scale factor to apply to v before subtracting it
     * @param v vector to subtract
     * @return a new vector
     */
    public FieldVector3D&lt;T&gt; subtract(final double factor, final Vector3D v) {
<span class="fc" id="L514">        return new FieldVector3D&lt;T&gt;(x.subtract(factor * v.getX()),</span>
<span class="fc" id="L515">                                    y.subtract(factor * v.getY()),</span>
<span class="fc" id="L516">                                    z.subtract(factor * v.getZ()));</span>
    }

    /** Get a normalized vector aligned with the instance.
     * @return a new normalized vector
     * @exception MathArithmeticException if the norm is zero
     */
    public FieldVector3D&lt;T&gt; normalize() throws MathArithmeticException {
<span class="fc" id="L524">        final T s = getNorm();</span>
<span class="fc bfc" id="L525" title="All 2 branches covered.">        if (s.getReal() == 0) {</span>
<span class="fc" id="L526">            throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);</span>
        }
<span class="fc" id="L528">        return scalarMultiply(s.reciprocal());</span>
    }

    /** Get a vector orthogonal to the instance.
     * &lt;p&gt;There are an infinite number of normalized vectors orthogonal
     * to the instance. This method picks up one of them almost
     * arbitrarily. It is useful when one needs to compute a reference
     * frame with one of the axes in a predefined direction. The
     * following example shows how to build a frame having the k axis
     * aligned with the known vector u :
     * &lt;pre&gt;&lt;code&gt;
     *   Vector3D k = u.normalize();
     *   Vector3D i = k.orthogonal();
     *   Vector3D j = Vector3D.crossProduct(k, i);
     * &lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
     * @return a new normalized vector orthogonal to the instance
     * @exception MathArithmeticException if the norm of the instance is null
     */
    public FieldVector3D&lt;T&gt; orthogonal() throws MathArithmeticException {

<span class="fc" id="L548">        final double threshold = 0.6 * getNorm().getReal();</span>
<span class="fc bfc" id="L549" title="All 2 branches covered.">        if (threshold == 0) {</span>
<span class="fc" id="L550">            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);</span>
        }

<span class="fc bfc" id="L553" title="All 2 branches covered.">        if (FastMath.abs(x.getReal()) &lt;= threshold) {</span>
<span class="fc" id="L554">            final T inverse  = y.multiply(y).add(z.multiply(z)).sqrt().reciprocal();</span>
<span class="fc" id="L555">            return new FieldVector3D&lt;T&gt;(inverse.getField().getZero(), inverse.multiply(z), inverse.multiply(y).negate());</span>
<span class="fc bfc" id="L556" title="All 2 branches covered.">        } else if (FastMath.abs(y.getReal()) &lt;= threshold) {</span>
<span class="fc" id="L557">            final T inverse  = x.multiply(x).add(z.multiply(z)).sqrt().reciprocal();</span>
<span class="fc" id="L558">            return new FieldVector3D&lt;T&gt;(inverse.multiply(z).negate(), inverse.getField().getZero(), inverse.multiply(x));</span>
        } else {
<span class="fc" id="L560">            final T inverse  = x.multiply(x).add(y.multiply(y)).sqrt().reciprocal();</span>
<span class="fc" id="L561">            return new FieldVector3D&lt;T&gt;(inverse.multiply(y), inverse.multiply(x).negate(), inverse.getField().getZero());</span>
        }

    }

    /** Compute the angular separation between two vectors.
     * &lt;p&gt;This method computes the angular separation between two
     * vectors using the dot product for well separated vectors and the
     * cross product for almost aligned vectors. This allows to have a
     * good accuracy in all cases, even for vectors very close to each
     * other.&lt;/p&gt;
     * @param v1 first vector
     * @param v2 second vector
     * @param &lt;T&gt; the type of the field elements
     * @return angular separation between v1 and v2
     * @exception MathArithmeticException if either vector has a null norm
     */
    public static &lt;T extends RealFieldElement&lt;T&gt;&gt; T angle(final FieldVector3D&lt;T&gt; v1, final FieldVector3D&lt;T&gt; v2)
        throws MathArithmeticException {

<span class="fc" id="L581">        final T normProduct = v1.getNorm().multiply(v2.getNorm());</span>
<span class="fc bfc" id="L582" title="All 2 branches covered.">        if (normProduct.getReal() == 0) {</span>
<span class="fc" id="L583">            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);</span>
        }

<span class="fc" id="L586">        final T dot = dotProduct(v1, v2);</span>
<span class="fc" id="L587">        final double threshold = normProduct.getReal() * 0.9999;</span>
<span class="fc bfc" id="L588" title="All 4 branches covered.">        if ((dot.getReal() &lt; -threshold) || (dot.getReal() &gt; threshold)) {</span>
            // the vectors are almost aligned, compute using the sine
<span class="fc" id="L590">            FieldVector3D&lt;T&gt; v3 = crossProduct(v1, v2);</span>
<span class="fc bfc" id="L591" title="All 2 branches covered.">            if (dot.getReal() &gt;= 0) {</span>
<span class="fc" id="L592">                return v3.getNorm().divide(normProduct).asin();</span>
            }
<span class="fc" id="L594">            return v3.getNorm().divide(normProduct).asin().subtract(FastMath.PI).negate();</span>
        }

        // the vectors are sufficiently separated to use the cosine
<span class="fc" id="L598">        return dot.divide(normProduct).acos();</span>

    }

    /** Compute the angular separation between two vectors.
     * &lt;p&gt;This method computes the angular separation between two
     * vectors using the dot product for well separated vectors and the
     * cross product for almost aligned vectors. This allows to have a
     * good accuracy in all cases, even for vectors very close to each
     * other.&lt;/p&gt;
     * @param v1 first vector
     * @param v2 second vector
     * @param &lt;T&gt; the type of the field elements
     * @return angular separation between v1 and v2
     * @exception MathArithmeticException if either vector has a null norm
     */
    public static &lt;T extends RealFieldElement&lt;T&gt;&gt; T angle(final FieldVector3D&lt;T&gt; v1, final Vector3D v2)
        throws MathArithmeticException {

<span class="fc" id="L617">        final T normProduct = v1.getNorm().multiply(v2.getNorm());</span>
<span class="fc bfc" id="L618" title="All 2 branches covered.">        if (normProduct.getReal() == 0) {</span>
<span class="fc" id="L619">            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);</span>
        }

<span class="fc" id="L622">        final T dot = dotProduct(v1, v2);</span>
<span class="fc" id="L623">        final double threshold = normProduct.getReal() * 0.9999;</span>
<span class="fc bfc" id="L624" title="All 4 branches covered.">        if ((dot.getReal() &lt; -threshold) || (dot.getReal() &gt; threshold)) {</span>
            // the vectors are almost aligned, compute using the sine
<span class="fc" id="L626">            FieldVector3D&lt;T&gt; v3 = crossProduct(v1, v2);</span>
<span class="fc bfc" id="L627" title="All 2 branches covered.">            if (dot.getReal() &gt;= 0) {</span>
<span class="fc" id="L628">                return v3.getNorm().divide(normProduct).asin();</span>
            }
<span class="fc" id="L630">            return v3.getNorm().divide(normProduct).asin().subtract(FastMath.PI).negate();</span>
        }

        // the vectors are sufficiently separated to use the cosine
<span class="fc" id="L634">        return dot.divide(normProduct).acos();</span>

    }

    /** Compute the angular separation between two vectors.
     * &lt;p&gt;This method computes the angular separation between two
     * vectors using the dot product for well separated vectors and the
     * cross product for almost aligned vectors. This allows to have a
     * good accuracy in all cases, even for vectors very close to each
     * other.&lt;/p&gt;
     * @param v1 first vector
     * @param v2 second vector
     * @param &lt;T&gt; the type of the field elements
     * @return angular separation between v1 and v2
     * @exception MathArithmeticException if either vector has a null norm
     */
    public static &lt;T extends RealFieldElement&lt;T&gt;&gt; T angle(final Vector3D v1, final FieldVector3D&lt;T&gt; v2)
        throws MathArithmeticException {
<span class="fc" id="L652">        return angle(v2, v1);</span>
    }

    /** Get the opposite of the instance.
     * @return a new vector which is opposite to the instance
     */
    public FieldVector3D&lt;T&gt; negate() {
<span class="fc" id="L659">        return new FieldVector3D&lt;T&gt;(x.negate(), y.negate(), z.negate());</span>
    }

    /** Multiply the instance by a scalar.
     * @param a scalar
     * @return a new vector
     */
    public FieldVector3D&lt;T&gt; scalarMultiply(final T a) {
<span class="fc" id="L667">        return new FieldVector3D&lt;T&gt;(x.multiply(a), y.multiply(a), z.multiply(a));</span>
    }

    /** Multiply the instance by a scalar.
     * @param a scalar
     * @return a new vector
     */
    public FieldVector3D&lt;T&gt; scalarMultiply(final double a) {
<span class="fc" id="L675">        return new FieldVector3D&lt;T&gt;(x.multiply(a), y.multiply(a), z.multiply(a));</span>
    }

    /**
     * Returns true if any coordinate of this vector is NaN; false otherwise
     * @return  true if any coordinate of this vector is NaN; false otherwise
     */
    public boolean isNaN() {
<span class="fc bfc" id="L683" title="All 6 branches covered.">        return Double.isNaN(x.getReal()) || Double.isNaN(y.getReal()) || Double.isNaN(z.getReal());</span>
    }

    /**
     * Returns true if any coordinate of this vector is infinite and none are NaN;
     * false otherwise
     * @return  true if any coordinate of this vector is infinite and none are NaN;
     * false otherwise
     */
    public boolean isInfinite() {
<span class="fc bfc" id="L693" title="All 8 branches covered.">        return !isNaN() &amp;&amp; (Double.isInfinite(x.getReal()) || Double.isInfinite(y.getReal()) || Double.isInfinite(z.getReal()));</span>
    }

    /**
     * Test for the equality of two 3D vectors.
     * &lt;p&gt;
     * If all coordinates of two 3D vectors are exactly the same, and none of their
     * {@link RealFieldElement#getReal() real part} are &lt;code&gt;NaN&lt;/code&gt;, the
     * two 3D vectors are considered to be equal.
     * &lt;/p&gt;
     * &lt;p&gt;
     * &lt;code&gt;NaN&lt;/code&gt; coordinates are considered to affect globally the vector
     * and be equals to each other - i.e, if either (or all) real part of the
     * coordinates of the 3D vector are &lt;code&gt;NaN&lt;/code&gt;, the 3D vector is &lt;code&gt;NaN&lt;/code&gt;.
     * &lt;/p&gt;
     *
     * @param other Object to test for equality to this
     * @return true if two 3D vector objects are equal, false if
     *         object is null, not an instance of Vector3D, or
     *         not equal to this Vector3D instance
     *
     */
    @Override
    public boolean equals(Object other) {

<span class="fc bfc" id="L718" title="All 2 branches covered.">        if (this == other) {</span>
<span class="fc" id="L719">            return true;</span>
        }

<span class="fc bfc" id="L722" title="All 2 branches covered.">        if (other instanceof FieldVector3D) {</span>
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L724">            final FieldVector3D&lt;T&gt; rhs = (FieldVector3D&lt;T&gt;) other;</span>
<span class="fc bfc" id="L725" title="All 2 branches covered.">            if (rhs.isNaN()) {</span>
<span class="fc" id="L726">                return this.isNaN();</span>
            }

<span class="fc bfc" id="L729" title="All 6 branches covered.">            return x.equals(rhs.x) &amp;&amp; y.equals(rhs.y) &amp;&amp; z.equals(rhs.z);</span>

        }
<span class="fc" id="L732">        return false;</span>
    }

    /**
     * Get a hashCode for the 3D vector.
     * &lt;p&gt;
     * All NaN values have the same hash code.&lt;/p&gt;
     *
     * @return a hash code value for this object
     */
    @Override
    public int hashCode() {
<span class="fc bfc" id="L744" title="All 2 branches covered.">        if (isNaN()) {</span>
<span class="fc" id="L745">            return 409;</span>
        }
<span class="fc" id="L747">        return 311 * (107 * x.hashCode() + 83 * y.hashCode() +  z.hashCode());</span>
    }

    /** Compute the dot-product of the instance and another vector.
     * &lt;p&gt;
     * The implementation uses specific multiplication and addition
     * algorithms to preserve accuracy and reduce cancellation effects.
     * It should be very accurate even for nearly orthogonal vectors.
     * &lt;/p&gt;
     * @see MathArrays#linearCombination(double, double, double, double, double, double)
     * @param v second vector
     * @return the dot product this.v
     */
    public T dotProduct(final FieldVector3D&lt;T&gt; v) {
<span class="fc" id="L761">        return x.linearCombination(x, v.x, y, v.y, z, v.z);</span>
    }

    /** Compute the dot-product of the instance and another vector.
     * &lt;p&gt;
     * The implementation uses specific multiplication and addition
     * algorithms to preserve accuracy and reduce cancellation effects.
     * It should be very accurate even for nearly orthogonal vectors.
     * &lt;/p&gt;
     * @see MathArrays#linearCombination(double, double, double, double, double, double)
     * @param v second vector
     * @return the dot product this.v
     */
    public T dotProduct(final Vector3D v) {
<span class="fc" id="L775">        return x.linearCombination(v.getX(), x, v.getY(), y, v.getZ(), z);</span>
    }

    /** Compute the cross-product of the instance with another vector.
     * @param v other vector
     * @return the cross product this ^ v as a new Vector3D
     */
    public FieldVector3D&lt;T&gt; crossProduct(final FieldVector3D&lt;T&gt; v) {
<span class="fc" id="L783">        return new FieldVector3D&lt;T&gt;(x.linearCombination(y, v.z, z.negate(), v.y),</span>
<span class="fc" id="L784">                                    y.linearCombination(z, v.x, x.negate(), v.z),</span>
<span class="fc" id="L785">                                    z.linearCombination(x, v.y, y.negate(), v.x));</span>
    }

    /** Compute the cross-product of the instance with another vector.
     * @param v other vector
     * @return the cross product this ^ v as a new Vector3D
     */
    public FieldVector3D&lt;T&gt; crossProduct(final Vector3D v) {
<span class="fc" id="L793">        return new FieldVector3D&lt;T&gt;(x.linearCombination(v.getZ(), y, -v.getY(), z),</span>
<span class="fc" id="L794">                                    y.linearCombination(v.getX(), z, -v.getZ(), x),</span>
<span class="fc" id="L795">                                    z.linearCombination(v.getY(), x, -v.getX(), y));</span>
    }

    /** Compute the distance between the instance and another vector according to the L&lt;sub&gt;1&lt;/sub&gt; norm.
     * &lt;p&gt;Calling this method is equivalent to calling:
     * &lt;code&gt;q.subtract(p).getNorm1()&lt;/code&gt; except that no intermediate
     * vector is built&lt;/p&gt;
     * @param v second vector
     * @return the distance between the instance and p according to the L&lt;sub&gt;1&lt;/sub&gt; norm
     */
    public T distance1(final FieldVector3D&lt;T&gt; v) {
<span class="fc" id="L806">        final T dx = v.x.subtract(x).abs();</span>
<span class="fc" id="L807">        final T dy = v.y.subtract(y).abs();</span>
<span class="fc" id="L808">        final T dz = v.z.subtract(z).abs();</span>
<span class="fc" id="L809">        return dx.add(dy).add(dz);</span>
    }

    /** Compute the distance between the instance and another vector according to the L&lt;sub&gt;1&lt;/sub&gt; norm.
     * &lt;p&gt;Calling this method is equivalent to calling:
     * &lt;code&gt;q.subtract(p).getNorm1()&lt;/code&gt; except that no intermediate
     * vector is built&lt;/p&gt;
     * @param v second vector
     * @return the distance between the instance and p according to the L&lt;sub&gt;1&lt;/sub&gt; norm
     */
    public T distance1(final Vector3D v) {
<span class="fc" id="L820">        final T dx = x.subtract(v.getX()).abs();</span>
<span class="fc" id="L821">        final T dy = y.subtract(v.getY()).abs();</span>
<span class="fc" id="L822">        final T dz = z.subtract(v.getZ()).abs();</span>
<span class="fc" id="L823">        return dx.add(dy).add(dz);</span>
    }

    /** Compute the distance between the instance and another vector according to the L&lt;sub&gt;2&lt;/sub&gt; norm.
     * &lt;p&gt;Calling this method is equivalent to calling:
     * &lt;code&gt;q.subtract(p).getNorm()&lt;/code&gt; except that no intermediate
     * vector is built&lt;/p&gt;
     * @param v second vector
     * @return the distance between the instance and p according to the L&lt;sub&gt;2&lt;/sub&gt; norm
     */
    public T distance(final FieldVector3D&lt;T&gt; v) {
<span class="fc" id="L834">        final T dx = v.x.subtract(x);</span>
<span class="fc" id="L835">        final T dy = v.y.subtract(y);</span>
<span class="fc" id="L836">        final T dz = v.z.subtract(z);</span>
<span class="fc" id="L837">        return dx.multiply(dx).add(dy.multiply(dy)).add(dz.multiply(dz)).sqrt();</span>
    }

    /** Compute the distance between the instance and another vector according to the L&lt;sub&gt;2&lt;/sub&gt; norm.
     * &lt;p&gt;Calling this method is equivalent to calling:
     * &lt;code&gt;q.subtract(p).getNorm()&lt;/code&gt; except that no intermediate
     * vector is built&lt;/p&gt;
     * @param v second vector
     * @return the distance between the instance and p according to the L&lt;sub&gt;2&lt;/sub&gt; norm
     */
    public T distance(final Vector3D v) {
<span class="fc" id="L848">        final T dx = x.subtract(v.getX());</span>
<span class="fc" id="L849">        final T dy = y.subtract(v.getY());</span>
<span class="fc" id="L850">        final T dz = z.subtract(v.getZ());</span>
<span class="fc" id="L851">        return dx.multiply(dx).add(dy.multiply(dy)).add(dz.multiply(dz)).sqrt();</span>
    }

    /** Compute the distance between the instance and another vector according to the L&lt;sub&gt;&amp;infin;&lt;/sub&gt; norm.
     * &lt;p&gt;Calling this method is equivalent to calling:
     * &lt;code&gt;q.subtract(p).getNormInf()&lt;/code&gt; except that no intermediate
     * vector is built&lt;/p&gt;
     * @param v second vector
     * @return the distance between the instance and p according to the L&lt;sub&gt;&amp;infin;&lt;/sub&gt; norm
     */
    public T distanceInf(final FieldVector3D&lt;T&gt; v) {
<span class="fc" id="L862">        final T dx = v.x.subtract(x).abs();</span>
<span class="fc" id="L863">        final T dy = v.y.subtract(y).abs();</span>
<span class="fc" id="L864">        final T dz = v.z.subtract(z).abs();</span>
<span class="fc bfc" id="L865" title="All 2 branches covered.">        if (dx.getReal() &lt;= dy.getReal()) {</span>
<span class="fc bfc" id="L866" title="All 2 branches covered.">            if (dy.getReal() &lt;= dz.getReal()) {</span>
<span class="fc" id="L867">                return dz;</span>
            } else {
<span class="fc" id="L869">                return dy;</span>
            }
        } else {
<span class="fc bfc" id="L872" title="All 2 branches covered.">            if (dx.getReal() &lt;= dz.getReal()) {</span>
<span class="fc" id="L873">                return dz;</span>
            } else {
<span class="fc" id="L875">                return dx;</span>
            }
        }
    }

    /** Compute the distance between the instance and another vector according to the L&lt;sub&gt;&amp;infin;&lt;/sub&gt; norm.
     * &lt;p&gt;Calling this method is equivalent to calling:
     * &lt;code&gt;q.subtract(p).getNormInf()&lt;/code&gt; except that no intermediate
     * vector is built&lt;/p&gt;
     * @param v second vector
     * @return the distance between the instance and p according to the L&lt;sub&gt;&amp;infin;&lt;/sub&gt; norm
     */
    public T distanceInf(final Vector3D v) {
<span class="fc" id="L888">        final T dx = x.subtract(v.getX()).abs();</span>
<span class="fc" id="L889">        final T dy = y.subtract(v.getY()).abs();</span>
<span class="fc" id="L890">        final T dz = z.subtract(v.getZ()).abs();</span>
<span class="fc bfc" id="L891" title="All 2 branches covered.">        if (dx.getReal() &lt;= dy.getReal()) {</span>
<span class="fc bfc" id="L892" title="All 2 branches covered.">            if (dy.getReal() &lt;= dz.getReal()) {</span>
<span class="fc" id="L893">                return dz;</span>
            } else {
<span class="fc" id="L895">                return dy;</span>
            }
        } else {
<span class="fc bfc" id="L898" title="All 2 branches covered.">            if (dx.getReal() &lt;= dz.getReal()) {</span>
<span class="fc" id="L899">                return dz;</span>
            } else {
<span class="fc" id="L901">                return dx;</span>
            }
        }
    }

    /** Compute the square of the distance between the instance and another vector.
     * &lt;p&gt;Calling this method is equivalent to calling:
     * &lt;code&gt;q.subtract(p).getNormSq()&lt;/code&gt; except that no intermediate
     * vector is built&lt;/p&gt;
     * @param v second vector
     * @return the square of the distance between the instance and p
     */
    public T distanceSq(final FieldVector3D&lt;T&gt; v) {
<span class="fc" id="L914">        final T dx = v.x.subtract(x);</span>
<span class="fc" id="L915">        final T dy = v.y.subtract(y);</span>
<span class="fc" id="L916">        final T dz = v.z.subtract(z);</span>
<span class="fc" id="L917">        return dx.multiply(dx).add(dy.multiply(dy)).add(dz.multiply(dz));</span>
    }

    /** Compute the square of the distance between the instance and another vector.
     * &lt;p&gt;Calling this method is equivalent to calling:
     * &lt;code&gt;q.subtract(p).getNormSq()&lt;/code&gt; except that no intermediate
     * vector is built&lt;/p&gt;
     * @param v second vector
     * @return the square of the distance between the instance and p
     */
    public T distanceSq(final Vector3D v) {
<span class="fc" id="L928">        final T dx = x.subtract(v.getX());</span>
<span class="fc" id="L929">        final T dy = y.subtract(v.getY());</span>
<span class="fc" id="L930">        final T dz = z.subtract(v.getZ());</span>
<span class="fc" id="L931">        return dx.multiply(dx).add(dy.multiply(dy)).add(dz.multiply(dz));</span>
    }

    /** Compute the dot-product of two vectors.
     * @param v1 first vector
     * @param v2 second vector
     * @param &lt;T&gt; the type of the field elements
     * @return the dot product v1.v2
     */
    public static &lt;T extends RealFieldElement&lt;T&gt;&gt; T dotProduct(final FieldVector3D&lt;T&gt; v1,
                                                                   final FieldVector3D&lt;T&gt; v2) {
<span class="fc" id="L942">        return v1.dotProduct(v2);</span>
    }

    /** Compute the dot-product of two vectors.
     * @param v1 first vector
     * @param v2 second vector
     * @param &lt;T&gt; the type of the field elements
     * @return the dot product v1.v2
     */
    public static &lt;T extends RealFieldElement&lt;T&gt;&gt; T dotProduct(final FieldVector3D&lt;T&gt; v1,
                                                                   final Vector3D v2) {
<span class="fc" id="L953">        return v1.dotProduct(v2);</span>
    }

    /** Compute the dot-product of two vectors.
     * @param v1 first vector
     * @param v2 second vector
     * @param &lt;T&gt; the type of the field elements
     * @return the dot product v1.v2
     */
    public static &lt;T extends RealFieldElement&lt;T&gt;&gt; T dotProduct(final Vector3D v1,
                                                                   final FieldVector3D&lt;T&gt; v2) {
<span class="fc" id="L964">        return v2.dotProduct(v1);</span>
    }

    /** Compute the cross-product of two vectors.
     * @param v1 first vector
     * @param v2 second vector
     * @param &lt;T&gt; the type of the field elements
     * @return the cross product v1 ^ v2 as a new Vector
     */
    public static &lt;T extends RealFieldElement&lt;T&gt;&gt; FieldVector3D&lt;T&gt; crossProduct(final FieldVector3D&lt;T&gt; v1,
                                                                                    final FieldVector3D&lt;T&gt; v2) {
<span class="fc" id="L975">        return v1.crossProduct(v2);</span>
    }

    /** Compute the cross-product of two vectors.
     * @param v1 first vector
     * @param v2 second vector
     * @param &lt;T&gt; the type of the field elements
     * @return the cross product v1 ^ v2 as a new Vector
     */
    public static &lt;T extends RealFieldElement&lt;T&gt;&gt; FieldVector3D&lt;T&gt; crossProduct(final FieldVector3D&lt;T&gt; v1,
                                                                                    final Vector3D v2) {
<span class="fc" id="L986">        return v1.crossProduct(v2);</span>
    }

    /** Compute the cross-product of two vectors.
     * @param v1 first vector
     * @param v2 second vector
     * @param &lt;T&gt; the type of the field elements
     * @return the cross product v1 ^ v2 as a new Vector
     */
    public static &lt;T extends RealFieldElement&lt;T&gt;&gt; FieldVector3D&lt;T&gt; crossProduct(final Vector3D v1,
                                                                                    final FieldVector3D&lt;T&gt; v2) {
<span class="fc" id="L997">        return new FieldVector3D&lt;T&gt;(v2.x.linearCombination(v1.getY(), v2.z, -v1.getZ(), v2.y),</span>
<span class="fc" id="L998">                                    v2.y.linearCombination(v1.getZ(), v2.x, -v1.getX(), v2.z),</span>
<span class="fc" id="L999">                                    v2.z.linearCombination(v1.getX(), v2.y, -v1.getY(), v2.x));</span>
    }

    /** Compute the distance between two vectors according to the L&lt;sub&gt;1&lt;/sub&gt; norm.
     * &lt;p&gt;Calling this method is equivalent to calling:
     * &lt;code&gt;v1.subtract(v2).getNorm1()&lt;/code&gt; except that no intermediate
     * vector is built&lt;/p&gt;
     * @param v1 first vector
     * @param v2 second vector
     * @param &lt;T&gt; the type of the field elements
     * @return the distance between v1 and v2 according to the L&lt;sub&gt;1&lt;/sub&gt; norm
     */
    public static &lt;T extends RealFieldElement&lt;T&gt;&gt; T distance1(final FieldVector3D&lt;T&gt; v1,
                                                                  final FieldVector3D&lt;T&gt; v2) {
<span class="fc" id="L1013">        return v1.distance1(v2);</span>
    }

    /** Compute the distance between two vectors according to the L&lt;sub&gt;1&lt;/sub&gt; norm.
     * &lt;p&gt;Calling this method is equivalent to calling:
     * &lt;code&gt;v1.subtract(v2).getNorm1()&lt;/code&gt; except that no intermediate
     * vector is built&lt;/p&gt;
     * @param v1 first vector
     * @param v2 second vector
     * @param &lt;T&gt; the type of the field elements
     * @return the distance between v1 and v2 according to the L&lt;sub&gt;1&lt;/sub&gt; norm
     */
    public static &lt;T extends RealFieldElement&lt;T&gt;&gt; T distance1(final FieldVector3D&lt;T&gt; v1,
                                                                  final Vector3D v2) {
<span class="fc" id="L1027">        return v1.distance1(v2);</span>
    }

    /** Compute the distance between two vectors according to the L&lt;sub&gt;1&lt;/sub&gt; norm.
     * &lt;p&gt;Calling this method is equivalent to calling:
     * &lt;code&gt;v1.subtract(v2).getNorm1()&lt;/code&gt; except that no intermediate
     * vector is built&lt;/p&gt;
     * @param v1 first vector
     * @param v2 second vector
     * @param &lt;T&gt; the type of the field elements
     * @return the distance between v1 and v2 according to the L&lt;sub&gt;1&lt;/sub&gt; norm
     */
    public static &lt;T extends RealFieldElement&lt;T&gt;&gt; T distance1(final Vector3D v1,
                                                                  final FieldVector3D&lt;T&gt; v2) {
<span class="fc" id="L1041">        return v2.distance1(v1);</span>
    }

    /** Compute the distance between two vectors according to the L&lt;sub&gt;2&lt;/sub&gt; norm.
     * &lt;p&gt;Calling this method is equivalent to calling:
     * &lt;code&gt;v1.subtract(v2).getNorm()&lt;/code&gt; except that no intermediate
     * vector is built&lt;/p&gt;
     * @param v1 first vector
     * @param v2 second vector
     * @param &lt;T&gt; the type of the field elements
     * @return the distance between v1 and v2 according to the L&lt;sub&gt;2&lt;/sub&gt; norm
     */
    public static &lt;T extends RealFieldElement&lt;T&gt;&gt; T distance(final FieldVector3D&lt;T&gt; v1,
                                                                 final FieldVector3D&lt;T&gt; v2) {
<span class="fc" id="L1055">        return v1.distance(v2);</span>
    }

    /** Compute the distance between two vectors according to the L&lt;sub&gt;2&lt;/sub&gt; norm.
     * &lt;p&gt;Calling this method is equivalent to calling:
     * &lt;code&gt;v1.subtract(v2).getNorm()&lt;/code&gt; except that no intermediate
     * vector is built&lt;/p&gt;
     * @param v1 first vector
     * @param v2 second vector
     * @param &lt;T&gt; the type of the field elements
     * @return the distance between v1 and v2 according to the L&lt;sub&gt;2&lt;/sub&gt; norm
     */
    public static &lt;T extends RealFieldElement&lt;T&gt;&gt; T distance(final FieldVector3D&lt;T&gt; v1,
                                                                 final Vector3D v2) {
<span class="fc" id="L1069">        return v1.distance(v2);</span>
    }

    /** Compute the distance between two vectors according to the L&lt;sub&gt;2&lt;/sub&gt; norm.
     * &lt;p&gt;Calling this method is equivalent to calling:
     * &lt;code&gt;v1.subtract(v2).getNorm()&lt;/code&gt; except that no intermediate
     * vector is built&lt;/p&gt;
     * @param v1 first vector
     * @param v2 second vector
     * @param &lt;T&gt; the type of the field elements
     * @return the distance between v1 and v2 according to the L&lt;sub&gt;2&lt;/sub&gt; norm
     */
    public static &lt;T extends RealFieldElement&lt;T&gt;&gt; T distance(final Vector3D v1,
                                                                 final FieldVector3D&lt;T&gt; v2) {
<span class="fc" id="L1083">        return v2.distance(v1);</span>
    }

    /** Compute the distance between two vectors according to the L&lt;sub&gt;&amp;infin;&lt;/sub&gt; norm.
     * &lt;p&gt;Calling this method is equivalent to calling:
     * &lt;code&gt;v1.subtract(v2).getNormInf()&lt;/code&gt; except that no intermediate
     * vector is built&lt;/p&gt;
     * @param v1 first vector
     * @param v2 second vector
     * @param &lt;T&gt; the type of the field elements
     * @return the distance between v1 and v2 according to the L&lt;sub&gt;&amp;infin;&lt;/sub&gt; norm
     */
    public static &lt;T extends RealFieldElement&lt;T&gt;&gt; T distanceInf(final FieldVector3D&lt;T&gt; v1,
                                                                    final FieldVector3D&lt;T&gt; v2) {
<span class="fc" id="L1097">        return v1.distanceInf(v2);</span>
    }

    /** Compute the distance between two vectors according to the L&lt;sub&gt;&amp;infin;&lt;/sub&gt; norm.
     * &lt;p&gt;Calling this method is equivalent to calling:
     * &lt;code&gt;v1.subtract(v2).getNormInf()&lt;/code&gt; except that no intermediate
     * vector is built&lt;/p&gt;
     * @param v1 first vector
     * @param v2 second vector
     * @param &lt;T&gt; the type of the field elements
     * @return the distance between v1 and v2 according to the L&lt;sub&gt;&amp;infin;&lt;/sub&gt; norm
     */
    public static &lt;T extends RealFieldElement&lt;T&gt;&gt; T distanceInf(final FieldVector3D&lt;T&gt; v1,
                                                                    final Vector3D v2) {
<span class="fc" id="L1111">        return v1.distanceInf(v2);</span>
    }

    /** Compute the distance between two vectors according to the L&lt;sub&gt;&amp;infin;&lt;/sub&gt; norm.
     * &lt;p&gt;Calling this method is equivalent to calling:
     * &lt;code&gt;v1.subtract(v2).getNormInf()&lt;/code&gt; except that no intermediate
     * vector is built&lt;/p&gt;
     * @param v1 first vector
     * @param v2 second vector
     * @param &lt;T&gt; the type of the field elements
     * @return the distance between v1 and v2 according to the L&lt;sub&gt;&amp;infin;&lt;/sub&gt; norm
     */
    public static &lt;T extends RealFieldElement&lt;T&gt;&gt; T distanceInf(final Vector3D v1,
                                                                    final FieldVector3D&lt;T&gt; v2) {
<span class="fc" id="L1125">        return v2.distanceInf(v1);</span>
    }

    /** Compute the square of the distance between two vectors.
     * &lt;p&gt;Calling this method is equivalent to calling:
     * &lt;code&gt;v1.subtract(v2).getNormSq()&lt;/code&gt; except that no intermediate
     * vector is built&lt;/p&gt;
     * @param v1 first vector
     * @param v2 second vector
     * @param &lt;T&gt; the type of the field elements
     * @return the square of the distance between v1 and v2
     */
    public static &lt;T extends RealFieldElement&lt;T&gt;&gt; T distanceSq(final FieldVector3D&lt;T&gt; v1,
                                                                   final FieldVector3D&lt;T&gt; v2) {
<span class="fc" id="L1139">        return v1.distanceSq(v2);</span>
    }

    /** Compute the square of the distance between two vectors.
     * &lt;p&gt;Calling this method is equivalent to calling:
     * &lt;code&gt;v1.subtract(v2).getNormSq()&lt;/code&gt; except that no intermediate
     * vector is built&lt;/p&gt;
     * @param v1 first vector
     * @param v2 second vector
     * @param &lt;T&gt; the type of the field elements
     * @return the square of the distance between v1 and v2
     */
    public static &lt;T extends RealFieldElement&lt;T&gt;&gt; T distanceSq(final FieldVector3D&lt;T&gt; v1,
                                                                   final Vector3D v2) {
<span class="fc" id="L1153">        return v1.distanceSq(v2);</span>
    }

    /** Compute the square of the distance between two vectors.
     * &lt;p&gt;Calling this method is equivalent to calling:
     * &lt;code&gt;v1.subtract(v2).getNormSq()&lt;/code&gt; except that no intermediate
     * vector is built&lt;/p&gt;
     * @param v1 first vector
     * @param v2 second vector
     * @param &lt;T&gt; the type of the field elements
     * @return the square of the distance between v1 and v2
     */
    public static &lt;T extends RealFieldElement&lt;T&gt;&gt; T distanceSq(final Vector3D v1,
                                                                   final FieldVector3D&lt;T&gt; v2) {
<span class="fc" id="L1167">        return v2.distanceSq(v1);</span>
    }

    /** Get a string representation of this vector.
     * @return a string representation of this vector
     */
    @Override
    public String toString() {
<span class="fc" id="L1175">        return Vector3DFormat.getInstance().format(toVector3D());</span>
    }

    /** Get a string representation of this vector.
     * @param format the custom format for components
     * @return a string representation of this vector
     */
    public String toString(final NumberFormat format) {
<span class="fc" id="L1183">        return new Vector3DFormat(format).format(toVector3D());</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>