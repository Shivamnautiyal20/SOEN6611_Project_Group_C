<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ArithmeticUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Commons Math</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math3.util</a> &gt; <span class="el_source">ArithmeticUtils.java</span></div><h1>ArithmeticUtils.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.math3.util;

import java.math.BigInteger;
import java.util.concurrent.atomic.AtomicReference;

import org.apache.commons.math3.exception.MathArithmeticException;
import org.apache.commons.math3.exception.NotPositiveException;
import org.apache.commons.math3.exception.NumberIsTooLargeException;
import org.apache.commons.math3.exception.util.Localizable;
import org.apache.commons.math3.exception.util.LocalizedFormats;

/**
 * Some useful, arithmetics related, additions to the built-in functions in
 * {@link Math}.
 *
 * @version $Id$
 */
public final class ArithmeticUtils {

    /** All long-representable factorials */
<span class="fc" id="L37">    static final long[] FACTORIALS = new long[] {</span>
                       1l,                  1l,                   2l,
                       6l,                 24l,                 120l,
                     720l,               5040l,               40320l,
                  362880l,            3628800l,            39916800l,
               479001600l,         6227020800l,         87178291200l,
           1307674368000l,     20922789888000l,     355687428096000l,
        6402373705728000l, 121645100408832000l, 2432902008176640000l };

    /** Stirling numbers of the second kind. */
<span class="fc" id="L47">    static final AtomicReference&lt;long[][]&gt; STIRLING_S2 = new AtomicReference&lt;long[][]&gt; (null);</span>

    /** Private constructor. */
    private ArithmeticUtils() {
        super();
    }

    /**
     * Add two integers, checking for overflow.
     *
     * @param x an addend
     * @param y an addend
     * @return the sum {@code x+y}
     * @throws MathArithmeticException if the result can not be represented
     * as an {@code int}.
     * @since 1.1
     */
    public static int addAndCheck(int x, int y)
            throws MathArithmeticException {
<span class="fc" id="L66">        long s = (long)x + (long)y;</span>
<span class="fc bfc" id="L67" title="All 4 branches covered.">        if (s &lt; Integer.MIN_VALUE || s &gt; Integer.MAX_VALUE) {</span>
<span class="fc" id="L68">            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, x, y);</span>
        }
<span class="fc" id="L70">        return (int)s;</span>
    }

    /**
     * Add two long integers, checking for overflow.
     *
     * @param a an addend
     * @param b an addend
     * @return the sum {@code a+b}
     * @throws MathArithmeticException if the result can not be represented as an
     *         long
     * @since 1.2
     */
    public static long addAndCheck(long a, long b) throws MathArithmeticException {
<span class="fc" id="L84">        return ArithmeticUtils.addAndCheck(a, b, LocalizedFormats.OVERFLOW_IN_ADDITION);</span>
    }

    /**
     * Returns an exact representation of the &lt;a
     * href=&quot;http://mathworld.wolfram.com/BinomialCoefficient.html&quot;&gt; Binomial
     * Coefficient&lt;/a&gt;, &quot;{@code n choose k}&quot;, the number of
     * {@code k}-element subsets that can be selected from an
     * {@code n}-element set.
     * &lt;p&gt;
     * &lt;Strong&gt;Preconditions&lt;/strong&gt;:
     * &lt;ul&gt;
     * &lt;li&gt; {@code 0 &lt;= k &lt;= n } (otherwise
     * {@code IllegalArgumentException} is thrown)&lt;/li&gt;
     * &lt;li&gt; The result is small enough to fit into a {@code long}. The
     * largest value of {@code n} for which all coefficients are
     * {@code  &lt; Long.MAX_VALUE} is 66. If the computed value exceeds
     * {@code Long.MAX_VALUE} an {@code ArithMeticException} is
     * thrown.&lt;/li&gt;
     * &lt;/ul&gt;&lt;/p&gt;
     *
     * @param n the size of the set
     * @param k the size of the subsets to be counted
     * @return {@code n choose k}
     * @throws NotPositiveException if {@code n &lt; 0}.
     * @throws NumberIsTooLargeException if {@code k &gt; n}.
     * @throws MathArithmeticException if the result is too large to be
     * represented by a long integer.
     */
    public static long binomialCoefficient(final int n, final int k)
        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {
<span class="fc" id="L115">        ArithmeticUtils.checkBinomial(n, k);</span>
<span class="fc bfc" id="L116" title="All 4 branches covered.">        if ((n == k) || (k == 0)) {</span>
<span class="fc" id="L117">            return 1;</span>
        }
<span class="fc bfc" id="L119" title="All 4 branches covered.">        if ((k == 1) || (k == n - 1)) {</span>
<span class="fc" id="L120">            return n;</span>
        }
        // Use symmetry for large k
<span class="fc bfc" id="L123" title="All 2 branches covered.">        if (k &gt; n / 2) {</span>
<span class="fc" id="L124">            return binomialCoefficient(n, n - k);</span>
        }

        // We use the formula
        // (n choose k) = n! / (n-k)! / k!
        // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
        // which could be written
        // (n choose k) == (n-1 choose k-1) * n / k
<span class="fc" id="L132">        long result = 1;</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">        if (n &lt;= 61) {</span>
            // For n &lt;= 61, the naive implementation cannot overflow.
<span class="fc" id="L135">            int i = n - k + 1;</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">            for (int j = 1; j &lt;= k; j++) {</span>
<span class="fc" id="L137">                result = result * i / j;</span>
<span class="fc" id="L138">                i++;</span>
            }
<span class="fc bfc" id="L140" title="All 2 branches covered.">        } else if (n &lt;= 66) {</span>
            // For n &gt; 61 but n &lt;= 66, the result cannot overflow,
            // but we must take care not to overflow intermediate values.
<span class="fc" id="L143">            int i = n - k + 1;</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">            for (int j = 1; j &lt;= k; j++) {</span>
                // We know that (result * i) is divisible by j,
                // but (result * i) may overflow, so we split j:
                // Filter out the gcd, d, so j/d and i/d are integer.
                // result is divisible by (j/d) because (j/d)
                // is relative prime to (i/d) and is a divisor of
                // result * (i/d).
<span class="fc" id="L151">                final long d = gcd(i, j);</span>
<span class="fc" id="L152">                result = (result / (j / d)) * (i / d);</span>
<span class="fc" id="L153">                i++;</span>
            }
<span class="fc" id="L155">        } else {</span>
            // For n &gt; 66, a result overflow might occur, so we check
            // the multiplication, taking care to not overflow
            // unnecessary.
<span class="fc" id="L159">            int i = n - k + 1;</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">            for (int j = 1; j &lt;= k; j++) {</span>
<span class="fc" id="L161">                final long d = gcd(i, j);</span>
<span class="fc" id="L162">                result = mulAndCheck(result / (j / d), i / d);</span>
<span class="fc" id="L163">                i++;</span>
            }
        }
<span class="fc" id="L166">        return result;</span>
    }

    /**
     * Returns a {@code double} representation of the &lt;a
     * href=&quot;http://mathworld.wolfram.com/BinomialCoefficient.html&quot;&gt; Binomial
     * Coefficient&lt;/a&gt;, &quot;{@code n choose k}&quot;, the number of
     * {@code k}-element subsets that can be selected from an
     * {@code n}-element set.
     * &lt;p&gt;
     * &lt;Strong&gt;Preconditions&lt;/strong&gt;:
     * &lt;ul&gt;
     * &lt;li&gt; {@code 0 &lt;= k &lt;= n } (otherwise
     * {@code IllegalArgumentException} is thrown)&lt;/li&gt;
     * &lt;li&gt; The result is small enough to fit into a {@code double}. The
     * largest value of {@code n} for which all coefficients are &lt;
     * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
     * Double.POSITIVE_INFINITY is returned&lt;/li&gt;
     * &lt;/ul&gt;&lt;/p&gt;
     *
     * @param n the size of the set
     * @param k the size of the subsets to be counted
     * @return {@code n choose k}
     * @throws NotPositiveException if {@code n &lt; 0}.
     * @throws NumberIsTooLargeException if {@code k &gt; n}.
     * @throws MathArithmeticException if the result is too large to be
     * represented by a long integer.
     */
    public static double binomialCoefficientDouble(final int n, final int k)
        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {
<span class="fc" id="L196">        ArithmeticUtils.checkBinomial(n, k);</span>
<span class="fc bfc" id="L197" title="All 4 branches covered.">        if ((n == k) || (k == 0)) {</span>
<span class="fc" id="L198">            return 1d;</span>
        }
<span class="fc bfc" id="L200" title="All 4 branches covered.">        if ((k == 1) || (k == n - 1)) {</span>
<span class="fc" id="L201">            return n;</span>
        }
<span class="fc bfc" id="L203" title="All 2 branches covered.">        if (k &gt; n/2) {</span>
<span class="fc" id="L204">            return binomialCoefficientDouble(n, n - k);</span>
        }
<span class="fc bfc" id="L206" title="All 2 branches covered.">        if (n &lt; 67) {</span>
<span class="fc" id="L207">            return binomialCoefficient(n,k);</span>
        }

<span class="fc" id="L210">        double result = 1d;</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">        for (int i = 1; i &lt;= k; i++) {</span>
<span class="fc" id="L212">             result *= (double)(n - k + i) / (double)i;</span>
        }

<span class="fc" id="L215">        return FastMath.floor(result + 0.5);</span>
    }

    /**
     * Returns the natural {@code log} of the &lt;a
     * href=&quot;http://mathworld.wolfram.com/BinomialCoefficient.html&quot;&gt; Binomial
     * Coefficient&lt;/a&gt;, &quot;{@code n choose k}&quot;, the number of
     * {@code k}-element subsets that can be selected from an
     * {@code n}-element set.
     * &lt;p&gt;
     * &lt;Strong&gt;Preconditions&lt;/strong&gt;:
     * &lt;ul&gt;
     * &lt;li&gt; {@code 0 &lt;= k &lt;= n } (otherwise
     * {@code IllegalArgumentException} is thrown)&lt;/li&gt;
     * &lt;/ul&gt;&lt;/p&gt;
     *
     * @param n the size of the set
     * @param k the size of the subsets to be counted
     * @return {@code n choose k}
     * @throws NotPositiveException if {@code n &lt; 0}.
     * @throws NumberIsTooLargeException if {@code k &gt; n}.
     * @throws MathArithmeticException if the result is too large to be
     * represented by a long integer.
     */
    public static double binomialCoefficientLog(final int n, final int k)
        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {
<span class="fc" id="L241">        ArithmeticUtils.checkBinomial(n, k);</span>
<span class="fc bfc" id="L242" title="All 4 branches covered.">        if ((n == k) || (k == 0)) {</span>
<span class="fc" id="L243">            return 0;</span>
        }
<span class="fc bfc" id="L245" title="All 4 branches covered.">        if ((k == 1) || (k == n - 1)) {</span>
<span class="fc" id="L246">            return FastMath.log(n);</span>
        }

        /*
         * For values small enough to do exact integer computation,
         * return the log of the exact value
         */
<span class="fc bfc" id="L253" title="All 2 branches covered.">        if (n &lt; 67) {</span>
<span class="fc" id="L254">            return FastMath.log(binomialCoefficient(n,k));</span>
        }

        /*
         * Return the log of binomialCoefficientDouble for values that will not
         * overflow binomialCoefficientDouble
         */
<span class="fc bfc" id="L261" title="All 2 branches covered.">        if (n &lt; 1030) {</span>
<span class="fc" id="L262">            return FastMath.log(binomialCoefficientDouble(n, k));</span>
        }

<span class="fc bfc" id="L265" title="All 2 branches covered.">        if (k &gt; n / 2) {</span>
<span class="fc" id="L266">            return binomialCoefficientLog(n, n - k);</span>
        }

        /*
         * Sum logs for values that could overflow
         */
<span class="fc" id="L272">        double logSum = 0;</span>

        // n!/(n-k)!
<span class="fc bfc" id="L275" title="All 2 branches covered.">        for (int i = n - k + 1; i &lt;= n; i++) {</span>
<span class="fc" id="L276">            logSum += FastMath.log(i);</span>
        }

        // divide by k!
<span class="fc bfc" id="L280" title="All 2 branches covered.">        for (int i = 2; i &lt;= k; i++) {</span>
<span class="fc" id="L281">            logSum -= FastMath.log(i);</span>
        }

<span class="fc" id="L284">        return logSum;</span>
    }

    /**
     * Returns n!. Shorthand for {@code n} &lt;a
     * href=&quot;http://mathworld.wolfram.com/Factorial.html&quot;&gt; Factorial&lt;/a&gt;, the
     * product of the numbers {@code 1,...,n}.
     * &lt;p&gt;
     * &lt;Strong&gt;Preconditions&lt;/strong&gt;:
     * &lt;ul&gt;
     * &lt;li&gt; {@code n &gt;= 0} (otherwise
     * {@code IllegalArgumentException} is thrown)&lt;/li&gt;
     * &lt;li&gt; The result is small enough to fit into a {@code long}. The
     * largest value of {@code n} for which {@code n!} &lt;
     * Long.MAX_VALUE} is 20. If the computed value exceeds {@code Long.MAX_VALUE}
     * an {@code ArithMeticException } is thrown.&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;/p&gt;
     *
     * @param n argument
     * @return {@code n!}
     * @throws MathArithmeticException if the result is too large to be represented
     * by a {@code long}.
     * @throws NotPositiveException if {@code n &lt; 0}.
     * @throws MathArithmeticException if {@code n &gt; 20}: The factorial value is too
     * large to fit in a {@code long}.
     */
    public static long factorial(final int n) throws NotPositiveException, MathArithmeticException {
<span class="fc bfc" id="L312" title="All 2 branches covered.">        if (n &lt; 0) {</span>
<span class="fc" id="L313">            throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,</span>
<span class="fc" id="L314">                                           n);</span>
        }
<span class="fc bfc" id="L316" title="All 2 branches covered.">        if (n &gt; 20) {</span>
<span class="fc" id="L317">            throw new MathArithmeticException();</span>
        }
<span class="fc" id="L319">        return FACTORIALS[n];</span>
    }

    /**
     * Compute n!, the&lt;a href=&quot;http://mathworld.wolfram.com/Factorial.html&quot;&gt;
     * factorial&lt;/a&gt; of {@code n} (the product of the numbers 1 to n), as a
     * {@code double}.
     * The result should be small enough to fit into a {@code double}: The
     * largest {@code n} for which {@code n! &lt; Double.MAX_VALUE} is 170.
     * If the computed value exceeds {@code Double.MAX_VALUE},
     * {@code Double.POSITIVE_INFINITY} is returned.
     *
     * @param n Argument.
     * @return {@code n!}
     * @throws NotPositiveException if {@code n &lt; 0}.
     */
    public static double factorialDouble(final int n) throws NotPositiveException {
<span class="fc bfc" id="L336" title="All 2 branches covered.">        if (n &lt; 0) {</span>
<span class="fc" id="L337">            throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,</span>
<span class="fc" id="L338">                                           n);</span>
        }
<span class="fc bfc" id="L340" title="All 2 branches covered.">        if (n &lt; 21) {</span>
<span class="fc" id="L341">            return FACTORIALS[n];</span>
        }
<span class="fc" id="L343">        return FastMath.floor(FastMath.exp(ArithmeticUtils.factorialLog(n)) + 0.5);</span>
    }

    /**
     * Compute the natural logarithm of the factorial of {@code n}.
     *
     * @param n Argument.
     * @return {@code n!}
     * @throws NotPositiveException if {@code n &lt; 0}.
     */
    public static double factorialLog(final int n) throws NotPositiveException {
<span class="fc bfc" id="L354" title="All 2 branches covered.">        if (n &lt; 0) {</span>
<span class="fc" id="L355">            throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,</span>
<span class="fc" id="L356">                                           n);</span>
        }
<span class="fc bfc" id="L358" title="All 2 branches covered.">        if (n &lt; 21) {</span>
<span class="fc" id="L359">            return FastMath.log(FACTORIALS[n]);</span>
        }
<span class="fc" id="L361">        double logSum = 0;</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">        for (int i = 2; i &lt;= n; i++) {</span>
<span class="fc" id="L363">            logSum += FastMath.log(i);</span>
        }
<span class="fc" id="L365">        return logSum;</span>
    }

    /**
     * Computes the greatest common divisor of the absolute value of two
     * numbers, using a modified version of the &quot;binary gcd&quot; method.
     * See Knuth 4.5.2 algorithm B.
     * The algorithm is due to Josef Stein (1961).
     * &lt;br/&gt;
     * Special cases:
     * &lt;ul&gt;
     *  &lt;li&gt;The invocations
     *   {@code gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)},
     *   {@code gcd(Integer.MIN_VALUE, 0)} and
     *   {@code gcd(0, Integer.MIN_VALUE)} throw an
     *   {@code ArithmeticException}, because the result would be 2^31, which
     *   is too large for an int value.&lt;/li&gt;
     *  &lt;li&gt;The result of {@code gcd(x, x)}, {@code gcd(0, x)} and
     *   {@code gcd(x, 0)} is the absolute value of {@code x}, except
     *   for the special cases above.&lt;/li&gt;
     *  &lt;li&gt;The invocation {@code gcd(0, 0)} is the only one which returns
     *   {@code 0}.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param p Number.
     * @param q Number.
     * @return the greatest common divisor (never negative).
     * @throws MathArithmeticException if the result cannot be represented as
     * a non-negative {@code int} value.
     * @since 1.1
     */
    public static int gcd(int p,
                          int q)
        throws MathArithmeticException {
<span class="fc" id="L399">        int a = p;</span>
<span class="fc" id="L400">        int b = q;</span>
<span class="fc bfc" id="L401" title="All 4 branches covered.">        if (a == 0 ||</span>
            b == 0) {
<span class="fc bfc" id="L403" title="All 4 branches covered.">            if (a == Integer.MIN_VALUE ||</span>
                b == Integer.MIN_VALUE) {
<span class="fc" id="L405">                throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS,</span>
<span class="fc" id="L406">                                                  p, q);</span>
            }
<span class="fc" id="L408">            return FastMath.abs(a + b);</span>
        }

<span class="fc" id="L411">        long al = a;</span>
<span class="fc" id="L412">        long bl = b;</span>
<span class="fc" id="L413">        boolean useLong = false;</span>
<span class="fc bfc" id="L414" title="All 2 branches covered.">        if (a &lt; 0) {</span>
<span class="fc bfc" id="L415" title="All 2 branches covered.">            if(Integer.MIN_VALUE == a) {</span>
<span class="fc" id="L416">                useLong = true;</span>
            } else {
<span class="fc" id="L418">                a = -a;</span>
            }
<span class="fc" id="L420">            al = -al;</span>
        }
<span class="fc bfc" id="L422" title="All 2 branches covered.">        if (b &lt; 0) {</span>
<span class="fc bfc" id="L423" title="All 2 branches covered.">            if (Integer.MIN_VALUE == b) {</span>
<span class="fc" id="L424">                useLong = true;</span>
            } else {
<span class="fc" id="L426">                b = -b;</span>
            }
<span class="fc" id="L428">            bl = -bl;</span>
        }
<span class="fc bfc" id="L430" title="All 2 branches covered.">        if (useLong) {</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">            if(al == bl) {</span>
<span class="fc" id="L432">                throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS,</span>
<span class="fc" id="L433">                                                  p, q);</span>
            }
<span class="fc" id="L435">            long blbu = bl;</span>
<span class="fc" id="L436">            bl = al;</span>
<span class="fc" id="L437">            al = blbu % al;</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">            if (al == 0) {</span>
<span class="pc bpc" id="L439" title="1 of 2 branches missed.">                if (bl &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L440">                    throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS,</span>
<span class="nc" id="L441">                                                      p, q);</span>
                }
<span class="fc" id="L443">                return (int) bl;</span>
            }
<span class="fc" id="L445">            blbu = bl;</span>

            // Now &quot;al&quot; and &quot;bl&quot; fit in an &quot;int&quot;.
<span class="fc" id="L448">            b = (int) al;</span>
<span class="fc" id="L449">            a = (int) (blbu % al);</span>
        }

<span class="fc" id="L452">        return gcdPositive(a, b);</span>
    }

    /**
     * Computes the greatest common divisor of two &lt;em&gt;positive&lt;/em&gt; numbers
     * (this precondition is &lt;em&gt;not&lt;/em&gt; checked and the result is undefined
     * if not fulfilled) using the &quot;binary gcd&quot; method which avoids division
     * and modulo operations.
     * See Knuth 4.5.2 algorithm B.
     * The algorithm is due to Josef Stein (1961).
     * &lt;br/&gt;
     * Special cases:
     * &lt;ul&gt;
     *  &lt;li&gt;The result of {@code gcd(x, x)}, {@code gcd(0, x)} and
     *   {@code gcd(x, 0)} is the value of {@code x}.&lt;/li&gt;
     *  &lt;li&gt;The invocation {@code gcd(0, 0)} is the only one which returns
     *   {@code 0}.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param a Positive number.
     * @param b Positive number.
     * @return the greatest common divisor.
     */
    private static int gcdPositive(int a,
                                   int b) {
<span class="fc bfc" id="L477" title="All 2 branches covered.">        if (a == 0) {</span>
<span class="fc" id="L478">            return b;</span>
        }
<span class="pc bpc" id="L480" title="1 of 2 branches missed.">        else if (b == 0) {</span>
<span class="nc" id="L481">            return a;</span>
        }

        // Make &quot;a&quot; and &quot;b&quot; odd, keeping track of common power of 2.
<span class="fc" id="L485">        final int aTwos = Integer.numberOfTrailingZeros(a);</span>
<span class="fc" id="L486">        a &gt;&gt;= aTwos;</span>
<span class="fc" id="L487">        final int bTwos = Integer.numberOfTrailingZeros(b);</span>
<span class="fc" id="L488">        b &gt;&gt;= bTwos;</span>
<span class="fc" id="L489">        final int shift = Math.min(aTwos, bTwos);</span>

        // &quot;a&quot; and &quot;b&quot; are positive.
        // If a &gt; b then &quot;gdc(a, b)&quot; is equal to &quot;gcd(a - b, b)&quot;.
        // If a &lt; b then &quot;gcd(a, b)&quot; is equal to &quot;gcd(b - a, a)&quot;.
        // Hence, in the successive iterations:
        //  &quot;a&quot; becomes the absolute difference of the current values,
        //  &quot;b&quot; becomes the minimum of the current values.
<span class="fc bfc" id="L497" title="All 2 branches covered.">        while (a != b) {</span>
<span class="fc" id="L498">            final int delta = a - b;</span>
<span class="fc" id="L499">            b = Math.min(a, b);</span>
<span class="fc" id="L500">            a = Math.abs(delta);</span>

            // Remove any power of 2 in &quot;a&quot; (&quot;b&quot; is guaranteed to be odd).
<span class="fc" id="L503">            a &gt;&gt;= Integer.numberOfTrailingZeros(a);</span>
<span class="fc" id="L504">        }</span>

        // Recover the common power of 2.
<span class="fc" id="L507">        return a &lt;&lt; shift;</span>
    }

    /**
     * &lt;p&gt;
     * Gets the greatest common divisor of the absolute value of two numbers,
     * using the &quot;binary gcd&quot; method which avoids division and modulo
     * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
     * Stein (1961).
     * &lt;/p&gt;
     * Special cases:
     * &lt;ul&gt;
     * &lt;li&gt;The invocations
     * {@code gcd(Long.MIN_VALUE, Long.MIN_VALUE)},
     * {@code gcd(Long.MIN_VALUE, 0L)} and
     * {@code gcd(0L, Long.MIN_VALUE)} throw an
     * {@code ArithmeticException}, because the result would be 2^63, which
     * is too large for a long value.&lt;/li&gt;
     * &lt;li&gt;The result of {@code gcd(x, x)}, {@code gcd(0L, x)} and
     * {@code gcd(x, 0L)} is the absolute value of {@code x}, except
     * for the special cases above.
     * &lt;li&gt;The invocation {@code gcd(0L, 0L)} is the only one which returns
     * {@code 0L}.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param p Number.
     * @param q Number.
     * @return the greatest common divisor, never negative.
     * @throws MathArithmeticException if the result cannot be represented as
     * a non-negative {@code long} value.
     * @since 2.1
     */
    public static long gcd(final long p, final long q) throws MathArithmeticException {
<span class="fc" id="L540">        long u = p;</span>
<span class="fc" id="L541">        long v = q;</span>
<span class="fc bfc" id="L542" title="All 4 branches covered.">        if ((u == 0) || (v == 0)) {</span>
<span class="fc bfc" id="L543" title="All 4 branches covered.">            if ((u == Long.MIN_VALUE) || (v == Long.MIN_VALUE)){</span>
<span class="fc" id="L544">                throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS,</span>
<span class="fc" id="L545">                                                  p, q);</span>
            }
<span class="fc" id="L547">            return FastMath.abs(u) + FastMath.abs(v);</span>
        }
        // keep u and v negative, as negative integers range down to
        // -2^63, while positive numbers can only be as large as 2^63-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 &amp;&amp; v!=0; */
<span class="fc bfc" id="L554" title="All 2 branches covered.">        if (u &gt; 0) {</span>
<span class="fc" id="L555">            u = -u;</span>
        } // make u negative
<span class="fc bfc" id="L557" title="All 2 branches covered.">        if (v &gt; 0) {</span>
<span class="fc" id="L558">            v = -v;</span>
        } // make v negative
        // B1. [Find power of 2]
<span class="fc" id="L561">        int k = 0;</span>
<span class="pc bpc" id="L562" title="1 of 6 branches missed.">        while ((u &amp; 1) == 0 &amp;&amp; (v &amp; 1) == 0 &amp;&amp; k &lt; 63) { // while u and v are</span>
                                                            // both even...
<span class="fc" id="L564">            u /= 2;</span>
<span class="fc" id="L565">            v /= 2;</span>
<span class="fc" id="L566">            k++; // cast out twos.</span>
        }
<span class="fc bfc" id="L568" title="All 2 branches covered.">        if (k == 63) {</span>
<span class="fc" id="L569">            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS,</span>
<span class="fc" id="L570">                                              p, q);</span>
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
<span class="fc bfc" id="L574" title="All 2 branches covered.">        long t = ((u &amp; 1) == 1) ? v : -(u / 2)/* B3 */;</span>
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u&lt;0 &amp;&amp; v&lt;0; */
            // B4/B3: cast out twos from t.
<span class="fc bfc" id="L580" title="All 2 branches covered.">            while ((t &amp; 1) == 0) { // while t is even..</span>
<span class="fc" id="L581">                t /= 2; // cast out twos</span>
            }
            // B5 [reset max(u,v)]
<span class="fc bfc" id="L584" title="All 2 branches covered.">            if (t &gt; 0) {</span>
<span class="fc" id="L585">                u = -t;</span>
            } else {
<span class="fc" id="L587">                v = t;</span>
            }
            // B6/B3. at this point both u and v should be odd.
<span class="fc" id="L590">            t = (v - u) / 2;</span>
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
<span class="fc bfc" id="L593" title="All 2 branches covered.">        } while (t != 0);</span>
<span class="fc" id="L594">        return -u * (1L &lt;&lt; k); // gcd is u*2^k</span>
    }

    /**
     * &lt;p&gt;
     * Returns the least common multiple of the absolute value of two numbers,
     * using the formula {@code lcm(a,b) = (a / gcd(a,b)) * b}.
     * &lt;/p&gt;
     * Special cases:
     * &lt;ul&gt;
     * &lt;li&gt;The invocations {@code lcm(Integer.MIN_VALUE, n)} and
     * {@code lcm(n, Integer.MIN_VALUE)}, where {@code abs(n)} is a
     * power of 2, throw an {@code ArithmeticException}, because the result
     * would be 2^31, which is too large for an int value.&lt;/li&gt;
     * &lt;li&gt;The result of {@code lcm(0, x)} and {@code lcm(x, 0)} is
     * {@code 0} for any {@code x}.
     * &lt;/ul&gt;
     *
     * @param a Number.
     * @param b Number.
     * @return the least common multiple, never negative.
     * @throws MathArithmeticException if the result cannot be represented as
     * a non-negative {@code int} value.
     * @since 1.1
     */
    public static int lcm(int a, int b) throws MathArithmeticException {
<span class="fc bfc" id="L620" title="All 4 branches covered.">        if (a == 0 || b == 0){</span>
<span class="fc" id="L621">            return 0;</span>
        }
<span class="fc" id="L623">        int lcm = FastMath.abs(ArithmeticUtils.mulAndCheck(a / gcd(a, b), b));</span>
<span class="fc bfc" id="L624" title="All 2 branches covered.">        if (lcm == Integer.MIN_VALUE) {</span>
<span class="fc" id="L625">            throw new MathArithmeticException(LocalizedFormats.LCM_OVERFLOW_32_BITS,</span>
<span class="fc" id="L626">                                              a, b);</span>
        }
<span class="fc" id="L628">        return lcm;</span>
    }

    /**
     * &lt;p&gt;
     * Returns the least common multiple of the absolute value of two numbers,
     * using the formula {@code lcm(a,b) = (a / gcd(a,b)) * b}.
     * &lt;/p&gt;
     * Special cases:
     * &lt;ul&gt;
     * &lt;li&gt;The invocations {@code lcm(Long.MIN_VALUE, n)} and
     * {@code lcm(n, Long.MIN_VALUE)}, where {@code abs(n)} is a
     * power of 2, throw an {@code ArithmeticException}, because the result
     * would be 2^63, which is too large for an int value.&lt;/li&gt;
     * &lt;li&gt;The result of {@code lcm(0L, x)} and {@code lcm(x, 0L)} is
     * {@code 0L} for any {@code x}.
     * &lt;/ul&gt;
     *
     * @param a Number.
     * @param b Number.
     * @return the least common multiple, never negative.
     * @throws MathArithmeticException if the result cannot be represented
     * as a non-negative {@code long} value.
     * @since 2.1
     */
    public static long lcm(long a, long b) throws MathArithmeticException {
<span class="fc bfc" id="L654" title="All 4 branches covered.">        if (a == 0 || b == 0){</span>
<span class="fc" id="L655">            return 0;</span>
        }
<span class="fc" id="L657">        long lcm = FastMath.abs(ArithmeticUtils.mulAndCheck(a / gcd(a, b), b));</span>
<span class="fc bfc" id="L658" title="All 2 branches covered.">        if (lcm == Long.MIN_VALUE){</span>
<span class="fc" id="L659">            throw new MathArithmeticException(LocalizedFormats.LCM_OVERFLOW_64_BITS,</span>
<span class="fc" id="L660">                                              a, b);</span>
        }
<span class="fc" id="L662">        return lcm;</span>
    }

    /**
     * Multiply two integers, checking for overflow.
     *
     * @param x Factor.
     * @param y Factor.
     * @return the product {@code x * y}.
     * @throws MathArithmeticException if the result can not be
     * represented as an {@code int}.
     * @since 1.1
     */
    public static int mulAndCheck(int x, int y) throws MathArithmeticException {
<span class="fc" id="L676">        long m = ((long)x) * ((long)y);</span>
<span class="fc bfc" id="L677" title="All 4 branches covered.">        if (m &lt; Integer.MIN_VALUE || m &gt; Integer.MAX_VALUE) {</span>
<span class="fc" id="L678">            throw new MathArithmeticException();</span>
        }
<span class="fc" id="L680">        return (int)m;</span>
    }

    /**
     * Multiply two long integers, checking for overflow.
     *
     * @param a Factor.
     * @param b Factor.
     * @return the product {@code a * b}.
     * @throws MathArithmeticException if the result can not be represented
     * as a {@code long}.
     * @since 1.2
     */
    public static long mulAndCheck(long a, long b) throws MathArithmeticException {
        long ret;
<span class="fc bfc" id="L695" title="All 2 branches covered.">        if (a &gt; b) {</span>
            // use symmetry to reduce boundary cases
<span class="fc" id="L697">            ret = mulAndCheck(b, a);</span>
        } else {
<span class="fc bfc" id="L699" title="All 2 branches covered.">            if (a &lt; 0) {</span>
<span class="fc bfc" id="L700" title="All 2 branches covered.">                if (b &lt; 0) {</span>
                    // check for positive overflow with negative a, negative b
<span class="fc bfc" id="L702" title="All 2 branches covered.">                    if (a &gt;= Long.MAX_VALUE / b) {</span>
<span class="fc" id="L703">                        ret = a * b;</span>
                    } else {
<span class="fc" id="L705">                        throw new MathArithmeticException();</span>
                    }
<span class="fc bfc" id="L707" title="All 2 branches covered.">                } else if (b &gt; 0) {</span>
                    // check for negative overflow with negative a, positive b
<span class="fc bfc" id="L709" title="All 2 branches covered.">                    if (Long.MIN_VALUE / b &lt;= a) {</span>
<span class="fc" id="L710">                        ret = a * b;</span>
                    } else {
<span class="fc" id="L712">                        throw new MathArithmeticException();</span>

                    }
                } else {
                    // assert b == 0
<span class="fc" id="L717">                    ret = 0;</span>
                }
<span class="fc bfc" id="L719" title="All 2 branches covered.">            } else if (a &gt; 0) {</span>
                // assert a &gt; 0
                // assert b &gt; 0

                // check for positive overflow with positive a, positive b
<span class="fc bfc" id="L724" title="All 2 branches covered.">                if (a &lt;= Long.MAX_VALUE / b) {</span>
<span class="fc" id="L725">                    ret = a * b;</span>
                } else {
<span class="fc" id="L727">                    throw new MathArithmeticException();</span>
                }
            } else {
                // assert a == 0
<span class="fc" id="L731">                ret = 0;</span>
            }
        }
<span class="fc" id="L734">        return ret;</span>
    }

    /**
     * Subtract two integers, checking for overflow.
     *
     * @param x Minuend.
     * @param y Subtrahend.
     * @return the difference {@code x - y}.
     * @throws MathArithmeticException if the result can not be represented
     * as an {@code int}.
     * @since 1.1
     */
    public static int subAndCheck(int x, int y) throws MathArithmeticException {
<span class="fc" id="L748">        long s = (long)x - (long)y;</span>
<span class="fc bfc" id="L749" title="All 4 branches covered.">        if (s &lt; Integer.MIN_VALUE || s &gt; Integer.MAX_VALUE) {</span>
<span class="fc" id="L750">            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, x, y);</span>
        }
<span class="fc" id="L752">        return (int)s;</span>
    }

    /**
     * Subtract two long integers, checking for overflow.
     *
     * @param a Value.
     * @param b Value.
     * @return the difference {@code a - b}.
     * @throws MathArithmeticException if the result can not be represented as a
     * {@code long}.
     * @since 1.2
     */
    public static long subAndCheck(long a, long b) throws MathArithmeticException {
        long ret;
<span class="fc bfc" id="L767" title="All 2 branches covered.">        if (b == Long.MIN_VALUE) {</span>
<span class="fc bfc" id="L768" title="All 2 branches covered.">            if (a &lt; 0) {</span>
<span class="fc" id="L769">                ret = a - b;</span>
            } else {
<span class="fc" id="L771">                throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, a, -b);</span>
            }
        } else {
            // use additive inverse
<span class="fc" id="L775">            ret = addAndCheck(a, -b, LocalizedFormats.OVERFLOW_IN_ADDITION);</span>
        }
<span class="fc" id="L777">        return ret;</span>
    }

    /**
     * Raise an int to an int power.
     *
     * @param k Number to raise.
     * @param e Exponent (must be positive or zero).
     * @return k&lt;sup&gt;e&lt;/sup&gt;
     * @throws NotPositiveException if {@code e &lt; 0}.
     */
    public static int pow(final int k, int e) throws NotPositiveException {
<span class="fc bfc" id="L789" title="All 2 branches covered.">        if (e &lt; 0) {</span>
<span class="fc" id="L790">            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);</span>
        }

<span class="fc" id="L793">        int result = 1;</span>
<span class="fc" id="L794">        int k2p    = k;</span>
<span class="fc bfc" id="L795" title="All 2 branches covered.">        while (e != 0) {</span>
<span class="fc bfc" id="L796" title="All 2 branches covered.">            if ((e &amp; 0x1) != 0) {</span>
<span class="fc" id="L797">                result *= k2p;</span>
            }
<span class="fc" id="L799">            k2p *= k2p;</span>
<span class="fc" id="L800">            e = e &gt;&gt; 1;</span>
        }

<span class="fc" id="L803">        return result;</span>
    }

    /**
     * Raise an int to a long power.
     *
     * @param k Number to raise.
     * @param e Exponent (must be positive or zero).
     * @return k&lt;sup&gt;e&lt;/sup&gt;
     * @throws NotPositiveException if {@code e &lt; 0}.
     */
    public static int pow(final int k, long e) throws NotPositiveException {
<span class="fc bfc" id="L815" title="All 2 branches covered.">        if (e &lt; 0) {</span>
<span class="fc" id="L816">            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);</span>
        }

<span class="fc" id="L819">        int result = 1;</span>
<span class="fc" id="L820">        int k2p    = k;</span>
<span class="fc bfc" id="L821" title="All 2 branches covered.">        while (e != 0) {</span>
<span class="pc bpc" id="L822" title="1 of 2 branches missed.">            if ((e &amp; 0x1) != 0) {</span>
<span class="fc" id="L823">                result *= k2p;</span>
            }
<span class="fc" id="L825">            k2p *= k2p;</span>
<span class="fc" id="L826">            e = e &gt;&gt; 1;</span>
        }

<span class="fc" id="L829">        return result;</span>
    }

    /**
     * Raise a long to an int power.
     *
     * @param k Number to raise.
     * @param e Exponent (must be positive or zero).
     * @return k&lt;sup&gt;e&lt;/sup&gt;
     * @throws NotPositiveException if {@code e &lt; 0}.
     */
    public static long pow(final long k, int e) throws NotPositiveException {
<span class="fc bfc" id="L841" title="All 2 branches covered.">        if (e &lt; 0) {</span>
<span class="fc" id="L842">            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);</span>
        }

<span class="fc" id="L845">        long result = 1l;</span>
<span class="fc" id="L846">        long k2p    = k;</span>
<span class="fc bfc" id="L847" title="All 2 branches covered.">        while (e != 0) {</span>
<span class="pc bpc" id="L848" title="1 of 2 branches missed.">            if ((e &amp; 0x1) != 0) {</span>
<span class="fc" id="L849">                result *= k2p;</span>
            }
<span class="fc" id="L851">            k2p *= k2p;</span>
<span class="fc" id="L852">            e = e &gt;&gt; 1;</span>
        }

<span class="fc" id="L855">        return result;</span>
    }

    /**
     * Raise a long to a long power.
     *
     * @param k Number to raise.
     * @param e Exponent (must be positive or zero).
     * @return k&lt;sup&gt;e&lt;/sup&gt;
     * @throws NotPositiveException if {@code e &lt; 0}.
     */
    public static long pow(final long k, long e) throws NotPositiveException {
<span class="fc bfc" id="L867" title="All 2 branches covered.">        if (e &lt; 0) {</span>
<span class="fc" id="L868">            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);</span>
        }

<span class="fc" id="L871">        long result = 1l;</span>
<span class="fc" id="L872">        long k2p    = k;</span>
<span class="fc bfc" id="L873" title="All 2 branches covered.">        while (e != 0) {</span>
<span class="pc bpc" id="L874" title="1 of 2 branches missed.">            if ((e &amp; 0x1) != 0) {</span>
<span class="fc" id="L875">                result *= k2p;</span>
            }
<span class="fc" id="L877">            k2p *= k2p;</span>
<span class="fc" id="L878">            e = e &gt;&gt; 1;</span>
        }

<span class="fc" id="L881">        return result;</span>
    }

    /**
     * Raise a BigInteger to an int power.
     *
     * @param k Number to raise.
     * @param e Exponent (must be positive or zero).
     * @return k&lt;sup&gt;e&lt;/sup&gt;
     * @throws NotPositiveException if {@code e &lt; 0}.
     */
    public static BigInteger pow(final BigInteger k, int e) throws NotPositiveException {
<span class="fc bfc" id="L893" title="All 2 branches covered.">        if (e &lt; 0) {</span>
<span class="fc" id="L894">            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);</span>
        }

<span class="fc" id="L897">        return k.pow(e);</span>
    }

    /**
     * Raise a BigInteger to a long power.
     *
     * @param k Number to raise.
     * @param e Exponent (must be positive or zero).
     * @return k&lt;sup&gt;e&lt;/sup&gt;
     * @throws NotPositiveException if {@code e &lt; 0}.
     */
    public static BigInteger pow(final BigInteger k, long e) throws NotPositiveException {
<span class="fc bfc" id="L909" title="All 2 branches covered.">        if (e &lt; 0) {</span>
<span class="fc" id="L910">            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);</span>
        }

<span class="fc" id="L913">        BigInteger result = BigInteger.ONE;</span>
<span class="fc" id="L914">        BigInteger k2p    = k;</span>
<span class="fc bfc" id="L915" title="All 2 branches covered.">        while (e != 0) {</span>
<span class="fc bfc" id="L916" title="All 2 branches covered.">            if ((e &amp; 0x1) != 0) {</span>
<span class="fc" id="L917">                result = result.multiply(k2p);</span>
            }
<span class="fc" id="L919">            k2p = k2p.multiply(k2p);</span>
<span class="fc" id="L920">            e = e &gt;&gt; 1;</span>
        }

<span class="fc" id="L923">        return result;</span>

    }

    /**
     * Raise a BigInteger to a BigInteger power.
     *
     * @param k Number to raise.
     * @param e Exponent (must be positive or zero).
     * @return k&lt;sup&gt;e&lt;/sup&gt;
     * @throws NotPositiveException if {@code e &lt; 0}.
     */
    public static BigInteger pow(final BigInteger k, BigInteger e) throws NotPositiveException {
<span class="fc bfc" id="L936" title="All 2 branches covered.">        if (e.compareTo(BigInteger.ZERO) &lt; 0) {</span>
<span class="fc" id="L937">            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);</span>
        }

<span class="fc" id="L940">        BigInteger result = BigInteger.ONE;</span>
<span class="fc" id="L941">        BigInteger k2p    = k;</span>
<span class="fc bfc" id="L942" title="All 2 branches covered.">        while (!BigInteger.ZERO.equals(e)) {</span>
<span class="fc bfc" id="L943" title="All 2 branches covered.">            if (e.testBit(0)) {</span>
<span class="fc" id="L944">                result = result.multiply(k2p);</span>
            }
<span class="fc" id="L946">            k2p = k2p.multiply(k2p);</span>
<span class="fc" id="L947">            e = e.shiftRight(1);</span>
        }

<span class="fc" id="L950">        return result;</span>
    }

    /**
     * Returns the &lt;a
     * href=&quot;http://mathworld.wolfram.com/StirlingNumberoftheSecondKind.html&quot;&gt;
     * Stirling number of the second kind&lt;/a&gt;, &quot;{@code S(n,k)}&quot;, the number of
     * ways of partitioning an {@code n}-element set into {@code k} non-empty
     * subsets.
     * &lt;p&gt;
     * The preconditions are {@code 0 &lt;= k &lt;= n } (otherwise
     * {@code NotPositiveException} is thrown)
     * &lt;/p&gt;
     * @param n the size of the set
     * @param k the number of non-empty subsets
     * @return {@code S(n,k)}
     * @throws NotPositiveException if {@code k &lt; 0}.
     * @throws NumberIsTooLargeException if {@code k &gt; n}.
     * @throws MathArithmeticException if some overflow happens, typically for n exceeding 25 and
     * k between 20 and n-2 (S(n,n-1) is handled specifically and does not overflow)
     * @since 3.1
     */
    public static long stirlingS2(final int n, final int k)
        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {
<span class="fc bfc" id="L974" title="All 2 branches covered.">        if (k &lt; 0) {</span>
<span class="fc" id="L975">            throw new NotPositiveException(k);</span>
        }
<span class="fc bfc" id="L977" title="All 2 branches covered.">        if (k &gt; n) {</span>
<span class="fc" id="L978">            throw new NumberIsTooLargeException(k, n, true);</span>
        }

<span class="fc" id="L981">        long[][] stirlingS2 = STIRLING_S2.get();</span>

<span class="fc bfc" id="L983" title="All 2 branches covered.">        if (stirlingS2 == null) {</span>
            // the cache has never been initialized, compute the first numbers
            // by direct recurrence relation

            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE
            // we must stop computation at row 26
<span class="fc" id="L989">            final int maxIndex = 26;</span>
<span class="fc" id="L990">            stirlingS2 = new long[maxIndex][];</span>
<span class="fc" id="L991">            stirlingS2[0] = new long[] { 1l };</span>
<span class="fc bfc" id="L992" title="All 2 branches covered.">            for (int i = 1; i &lt; stirlingS2.length; ++i) {</span>
<span class="fc" id="L993">                stirlingS2[i] = new long[i + 1];</span>
<span class="fc" id="L994">                stirlingS2[i][0] = 0;</span>
<span class="fc" id="L995">                stirlingS2[i][1] = 1;</span>
<span class="fc" id="L996">                stirlingS2[i][i] = 1;</span>
<span class="fc bfc" id="L997" title="All 2 branches covered.">                for (int j = 2; j &lt; i; ++j) {</span>
<span class="fc" id="L998">                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];</span>
                }
            }

            // atomically save the cache
<span class="fc" id="L1003">            STIRLING_S2.compareAndSet(null, stirlingS2);</span>

        }

<span class="fc bfc" id="L1007" title="All 2 branches covered.">        if (n &lt; stirlingS2.length) {</span>
            // the number is in the small cache
<span class="fc" id="L1009">            return stirlingS2[n][k];</span>
        } else {
            // use explicit formula to compute the number without caching it
<span class="fc bfc" id="L1012" title="All 2 branches covered.">            if (k == 0) {</span>
<span class="fc" id="L1013">                return 0;</span>
<span class="fc bfc" id="L1014" title="All 4 branches covered.">            } else if (k == 1 || k == n) {</span>
<span class="fc" id="L1015">                return 1;</span>
<span class="fc bfc" id="L1016" title="All 2 branches covered.">            } else if (k == 2) {</span>
<span class="fc" id="L1017">                return (1l &lt;&lt; (n - 1)) - 1l;</span>
<span class="fc bfc" id="L1018" title="All 2 branches covered.">            } else if (k == n - 1) {</span>
<span class="fc" id="L1019">                return binomialCoefficient(n, 2);</span>
            } else {
                // definition formula: note that this may trigger some overflow
<span class="fc" id="L1022">                long sum = 0;</span>
<span class="pc bpc" id="L1023" title="1 of 2 branches missed.">                long sign = ((k &amp; 0x1) == 0) ? 1 : -1;</span>
<span class="pc bpc" id="L1024" title="1 of 2 branches missed.">                for (int j = 1; j &lt;= k; ++j) {</span>
<span class="fc" id="L1025">                    sign = -sign;</span>
<span class="fc" id="L1026">                    sum += sign * binomialCoefficient(k, j) * pow(j, n);</span>
<span class="fc bfc" id="L1027" title="All 2 branches covered.">                    if (sum &lt; 0) {</span>
                        // there was an overflow somewhere
<span class="fc" id="L1029">                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,</span>
<span class="fc" id="L1030">                                                          n, 0, stirlingS2.length - 1);</span>
                    }
                }
<span class="nc" id="L1033">                return sum / factorial(k);</span>
            }
        }

    }

    /**
     * Add two long integers, checking for overflow.
     *
     * @param a Addend.
     * @param b Addend.
     * @param pattern Pattern to use for any thrown exception.
     * @return the sum {@code a + b}.
     * @throws MathArithmeticException if the result cannot be represented
     * as a {@code long}.
     * @since 1.2
     */
     private static long addAndCheck(long a, long b, Localizable pattern) throws MathArithmeticException {
        long ret;
<span class="fc bfc" id="L1052" title="All 2 branches covered.">        if (a &gt; b) {</span>
            // use symmetry to reduce boundary cases
<span class="fc" id="L1054">            ret = addAndCheck(b, a, pattern);</span>
        } else {
            // assert a &lt;= b

<span class="fc bfc" id="L1058" title="All 2 branches covered.">            if (a &lt; 0) {</span>
<span class="fc bfc" id="L1059" title="All 2 branches covered.">                if (b &lt; 0) {</span>
                    // check for negative overflow
<span class="fc bfc" id="L1061" title="All 2 branches covered.">                    if (Long.MIN_VALUE - b &lt;= a) {</span>
<span class="fc" id="L1062">                        ret = a + b;</span>
                    } else {
<span class="fc" id="L1064">                        throw new MathArithmeticException(pattern, a, b);</span>
                    }
                } else {
                    // opposite sign addition is always safe
<span class="fc" id="L1068">                    ret = a + b;</span>
                }
            } else {
                // assert a &gt;= 0
                // assert b &gt;= 0

                // check for positive overflow
<span class="fc bfc" id="L1075" title="All 2 branches covered.">                if (a &lt;= Long.MAX_VALUE - b) {</span>
<span class="fc" id="L1076">                    ret = a + b;</span>
                } else {
<span class="fc" id="L1078">                    throw new MathArithmeticException(pattern, a, b);</span>
                }
            }
        }
<span class="fc" id="L1082">        return ret;</span>
    }

    /**
     * Check binomial preconditions.
     *
     * @param n Size of the set.
     * @param k Size of the subsets to be counted.
     * @throws NotPositiveException if {@code n &lt; 0}.
     * @throws NumberIsTooLargeException if {@code k &gt; n}.
     */
    private static void checkBinomial(final int n, final int k) throws NumberIsTooLargeException, NotPositiveException {
<span class="fc bfc" id="L1094" title="All 2 branches covered.">        if (n &lt; k) {</span>
<span class="fc" id="L1095">            throw new NumberIsTooLargeException(LocalizedFormats.BINOMIAL_INVALID_PARAMETERS_ORDER,</span>
<span class="fc" id="L1096">                                                k, n, true);</span>
        }
<span class="fc bfc" id="L1098" title="All 2 branches covered.">        if (n &lt; 0) {</span>
<span class="fc" id="L1099">            throw new NotPositiveException(LocalizedFormats.BINOMIAL_NEGATIVE_PARAMETER, n);</span>
        }
<span class="fc" id="L1101">    }</span>

    /**
     * Returns true if the argument is a power of two.
     *
     * @param n the number to test
     * @return true if the argument is a power of two
     */
    public static boolean isPowerOfTwo(long n) {
<span class="fc bfc" id="L1110" title="All 4 branches covered.">        return (n &gt; 0) &amp;&amp; ((n &amp; (n - 1)) == 0);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>